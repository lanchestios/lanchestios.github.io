<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="并发处理的广泛应用是使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。 为了解决内存和处理器的速度矛盾，增加了高速缓存进行存储交互。为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-of-Order Execution）优化。与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有类似的">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 内存模型">
<meta property="og:url" content="http://example.com/2021/02/24/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="Lanchester Blog">
<meta property="og:description" content="并发处理的广泛应用是使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。 为了解决内存和处理器的速度矛盾，增加了高速缓存进行存储交互。为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-of-Order Execution）优化。与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有类似的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/JDK/CPUCache模型.png">
<meta property="og:image" content="http://example.com/images/JDK/主存以及各级缓存之间响应速度对比图.png">
<meta property="og:image" content="http://example.com/images/JDK/CPU通过Cache和内存交互.png">
<meta property="og:image" content="http://example.com/images/JDK/缓存一致性协议解决数据不一致问题.png">
<meta property="og:image" content="http://example.com/images/JDK/线程主内存工作内存三者的交互关系.png">
<meta property="og:image" content="http://example.com/images/JDK/线程主内存的交互关系.png">
<meta property="og:image" content="http://example.com/images/JDK/系统总线.png">
<meta property="og:image" content="http://example.com/images/JDK/64位数据半读半写.png">
<meta property="og:image" content="http://example.com/images/JDK/线程状态转换关系.png">
<meta property="og:image" content="http://example.com/images/JDK/volatile重排序规则表.png">
<meta property="og:image" content="http://example.com/images/JDK/volatile写内存屏障.png">
<meta property="og:image" content="http://example.com/images/JDK/volatile读内存屏障.png">
<meta property="og:image" content="http://example.com/images/JDK/readAndWrite方法编译器生成字节码.png">
<meta property="og:image" content="http://example.com/images/JDK/readAndWrite方法编译器优化生成字节码.png">
<meta property="og:image" content="http://example.com/images/JDK/VolatileExample示例程序被重排序.png">
<meta property="og:image" content="http://example.com/images/JDK/写final域的重排序规则.png">
<meta property="og:image" content="http://example.com/images/JDK/读final域的重排序规则.png">
<meta property="og:image" content="http://example.com/images/JDK/final引用类型.png">
<meta property="og:image" content="http://example.com/images/JDK/final引用逸出.png">
<meta property="og:image" content="http://example.com/images/JDK/JMM在不同处理器内存模型中需要插入的内存屏障的示意图.png">
<meta property="og:image" content="http://example.com/images/JDK/语言内存模型处理器内存模型和顺序一致性内存模型的强弱对比示意图.png">
<meta property="article:published_time" content="2021-02-24T13:47:28.000Z">
<meta property="article:modified_time" content="2023-02-06T06:39:42.622Z">
<meta property="article:author" content="Wang Zihao">
<meta property="article:tag" content="JDK">
<meta property="article:tag" content="CAS">
<meta property="article:tag" content="JMM">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="volitile">
<meta property="article:tag" content="happen-before">
<meta property="article:tag" content="final">
<meta property="article:tag" content="线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/JDK/CPUCache模型.png">

<link rel="canonical" href="http://example.com/2021/02/24/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>JVM 内存模型 | Lanchester Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lanchester Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Leave a leaf</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/24/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Zihao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lanchester Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM 内存模型
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-24 21:47:28" itemprop="dateCreated datePublished" datetime="2021-02-24T21:47:28+08:00">2021-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-06 14:39:42" itemprop="dateModified" datetime="2023-02-06T14:39:42+08:00">2023-02-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>并发处理的广泛应用是使得 Amdahl 定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。</p>
<p>为了解决内存和处理器的速度矛盾，增加了高速缓存进行存储交互。为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-of-Order Execution）优化。与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。</p>
<span id="more"></span>
<h1 id="CPU-Cache模型"><a href="#CPU-Cache模型" class="headerlink" title="CPU Cache模型"></a>CPU Cache模型</h1><p>在计算机中，所有的运算操作都是由 CPU 的寄存器来完成的，CPU 指令的执行过程需要涉及数据的读取和写入操作，CPU 所能访问的所有数据只能是计算机的主存（通常是指 RAM），虽然 CPU 的发展频率不断地得到提升，但受制于制造工艺以及成本等的限制算机的内存反倒在访问速度上并没有多大的突破，因此 CPU 的处理速度和内存的访问速度之间的差距越拉越大，通常这种差距可以达到上千倍，极端情况下甚至会在上万倍以上。</p>
<p>由于两边速度严重的不对等，通过传统FSB直连内存的访问方式很明显会导致 CPU 资源受到大量的限制，降低 CPU 整体的吞吐量，于是就有了在 CPU 和主内存之间增加缓存的设计，现在缓存的数量都可以增加到 3 级了，最靠近 CPU 的缓存称为 L1，然后依次是 L2，L3 和主内存，CPU缓存模型如下图所示。</p>
<p><img src="/images/JDK/CPUCache模型.png" style="zoom:50%;" /></p>
<p>由于程序指令和程序数据的行为和热点分布差异很大，因此 L1 Cache 又被划分成了 L1i（i 是 instruction 的首字母）和 L1d（d 是 data 的首字母）这两种有各自专门用途的缓存，CPU Cache 又是由很多个 Cache Line 构成的，Cache Line 可以认为是 CPU Cache 中的最小缓存单位，目前主流 CPU Cache 的 Cache Line 大小都是 64 字节。</p>
<p><img src="/images/JDK/主存以及各级缓存之间响应速度对比图.png" alt=""></p>
<p>通过上图，我们可以发现主内存的读写速度远远落后于 CPU Cache 的速度，更别说 CPU 本身的计算速度了。</p>
<p>Cache 的出现是为了解决 CPU 直接访问内存效率低下问题的，程序在运行的过程中，会将运算所需要的数据从主存复制一份到 CPU Cache 中，这样 CPU 进行计算时就可以直接对 CPU Cache 中的数据进行读取和写入，当运算结束之后，再将 CPU Cache 中的最新数据刷新到主内存当中，CPU 通过直接访问 Cache 的方式替代直接访问主存的方式极大地提高了 CPU 的吞吐能力，有了 CPU Cache 之后，整体的 CPU 和主内存之间交互的架构大致如下图所示。</p>
<p><img src="/images/JDK/CPU通过Cache和内存交互.png" style="zoom:50%;" /></p>
<p>但随着中间缓存的引入，数据不一致的问题也随之而来，通常主流的解决方式有两种：</p>
<ul>
<li>通过总线加锁的方式</li>
<li>通过缓存一致性协议</li>
</ul>
<p>第一种方式常见于早期的 CPU 当中，而且是一种悲观的实现方式，CPU 和其他组件的通信都是通过总线（数据总线、控制总线、地址总线）来进行的，如果采用总线加锁的方式，则会阻塞其他 CPU 对其他组件的访问从而使得只有一个 CPU（抢到总线锁）能够访问这个变量的内存。这种方式效率低下，所以就有了第二种通过缓存一致性协议的方式来解决不一致的问题（见下图)。</p>
<p><img src="/images/JDK/缓存一致性协议解决数据不一致问题.png" alt=""></p>
<p>在缓存一致性协议中最为出名的是 Intel 的 MESI 协议，MESI 协议保证了每一个缓存中使用的共享变量副本都是一致的，它的大致思想是，当 CPU 在操作 Cache 中的数据时，如果发现该变量是一个共享变量，也就是说在其他的 CPU Cache 中也存在一个副本，那么进行如下操作：</p>
<ol>
<li>读取操作，不做任何处理，只是将 Cache 中的数据读取到寄存器。</li>
<li>写入操作，发出信号通知其他 CPU 将该变量的 Cache line 置为无效状态，其他 CPU 在进行该变量读取的时候不得不到主内存中再次获取。</li>
</ol>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java 虚拟机规范中试图定义一种 Java 内存模型 [JSR-133]（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如 C/C++ 等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。</p>
<h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>Java 内存模型的主要目标定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内在和从内存中取出变量这样的底层细节此处的变量（Variables）与 Java 编程中所说的变量有所区别，<strong>它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量（Local variables），方法定义参数（formal method parameters）和异常处理器参数（exception handler parameters）。前者存储在堆内存中，堆内存在线程之间共享，而后者是线程私有的，不会被共享，自然就不会存在竞争问题。</strong>为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。</p>
<p>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图所示。</p>
<p><img src="/images/JDK/线程主内存工作内存三者的交互关系.png" style="zoom: 67%;" /></p>
<p>这里所讲的主内存、工作内存与 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作內存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。</p>
<p>这也就是程序不同步的原因之一：私有堆栈和公共堆栈的值不同步，因此在 Java 中可以通过 vollatile、Sync、Lock 等机制，使得线程主体强制从主内存读写数据来保证阶段性的数据一致。</p>
<p><img src="/images/JDK/线程主内存的交互关系.png" style="zoom: 50%;" /></p>
<h2 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h2><p>关于主内存与作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步叫主内存之类的实现细节，Java 内存模型中定义了以下 8 种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说，load、store、read 和 write 操作在某些平台上允许有例外）</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放人主内存的变量中。</li>
</ul>
<p>如果要把一个变量从主内存复制到工作内存，那就要顺序地执行 read 和 load 操作，如果要把变量从工作内存同步回主内存，就要顺序地执行 store 和 write 操作。注意，Java 内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read 与 load 之间、store 与 write 之间是可插入其他指令的，如对主内存中的变量 a、b 进行访问时，一种可能出现顺序是 read a、read b、load b、load a。除此之外，Java 内存模型还规定了在执行上述 8 种基木操作时必须满足如下规则：</p>
<ul>
<li>不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存</li>
<li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说，就是对一个变量实施 use、 store 操作之前，必须先执行过了 assign 和 load 操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</li>
<li>如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li>
<li>如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li>
<li>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。</li>
</ul>
<h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><p>普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是 Java 内存模型中描述的所谓的“线程内表现为串行的语义”（Within Thread As-If-Serial Semantics）。</p>
<p>从硬件架构上讲，指令重排序是指 CPU 采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU 需要能正确处理指令依赖情况以保障程序能得岀正确的执行结果。</p>
<h3 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h3><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</p>
<p>数据依赖分下列三种类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>代码示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>写后读</td>
<td>a = 1;b = a;</td>
<td>写一个变量之后，再读这个位置</td>
</tr>
<tr>
<td>写后写</td>
<td>a = 1;a = 2;</td>
<td>写一个变量之后，再写这个变量</td>
</tr>
<tr>
<td>读后写</td>
<td>a = b;b = 1;</td>
<td>读一个变量之后，再写这个变量</td>
</tr>
</tbody>
</table>
</div>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。而编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。即使是重排序后的操作，对于最后的执行结果也是无影响的。</p>
<blockquote>
<p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
</blockquote>
<h3 id="重排序分类"><a href="#重排序分类" class="headerlink" title="重排序分类"></a>重排序分类</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ol>
<li><p>编译器优化的重排序</p>
<p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li><p>指令级并行的重排序</p>
<p>现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
</li>
<li><p>内存系统的重排序</p>
<p>由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
</li>
</ol>
<h3 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h3><p>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。</p>
<p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens- before 的定义可以看出，JMM 同样遵从这一目标。</p>
<h2 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h2><p>当一个变量定义为 volatile 之后，它将具备两种特性。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>第一是保证此变量<strong>对所有线程的可见性</strong>，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见。</p>
<p>但这个可见性只在程序获取到或修改它时得到保证，如果操作不是原子性的，仍需通过加锁来保证并发一致性。</p>
<blockquote>
<p>值得一提的是，Java 还有两个关键字能实现可见性，即 synchronized代码块 和 final。</p>
<p>同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行store、 write操作）”这条规则获得的</p>
<p>final 关键字的可见性是指：被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见 final 字段的值。</p>
</blockquote>
<h3 id="禁止指令重排序优化"><a href="#禁止指令重排序优化" class="headerlink" title="禁止指令重排序优化"></a>禁止指令重排序优化</h3><p>第二是<strong>禁止指令重排序优化</strong>。禁止指令重排序的原理是在执行 voliate 变量赋值时，在赋值操作的后面加上一个内存屏障（Memory Barrier 或 Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个 CPU 访问内存时，并不需要内存屏障；但如果有多个 CPU 访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。并且在 voliate 变量赋值操作完成后，需要进行将工作内存变量拷贝至主内存变量的操作。本 CPU 的 Cache 写入了主内存，该写入动作也会引起别的 CPU 或者别的内核无效化（Invalidate）其 Cache，这种操作相当于对 Cache 中的变量做了一次 Java 内存模式中所说的“store”和”write”操作。通过这样一个操作，可让前面 volatile 变量的修改对其他 CPU 立即可见。因此，其他 CPU 把修改同步到工作内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。</p>
<blockquote>
<p>大多数场景下 volatile 的总开销仍然要比锁低，我们在 volatile 与锁之中选择的唯一依据仅仅是 volatile 的语义能否满足使用场景的需求。</p>
</blockquote>
<h2 id="对于long和double型变量的特殊规则"><a href="#对于long和double型变量的特殊规则" class="headerlink" title="对于long和double型变量的特殊规则"></a>对于long和double型变量的特殊规则</h2><p>Java 内存模型要求 lock、unlock、read、load、assign、use、store、write 这 8 个操作都具有原子性，但是对于 64 位的数据类型（long 和 double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虛拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性，这点就是所谓的 long 和 double 的非原子性协定（Nonatomic Treatment of double and long variables）。</p>
<p>如果有多个线程共享一个并未声明为 volatile 的 long 或 double 类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。这个现象与处理器总线的工作机制密切相关。</p>
<p>在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus transaction）。总线事务包括读事务（read transaction）和写事务（write transaction）。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，每个事务会读 / 写内存中一个或多个物理上连续的字。这里的关键是，总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和 I/O 设备执行内存的读 / 写。</p>
<p>下面让我们通过一个示意图来说明总线的工作机制：</p>
<p><img src="/images/JDK/系统总线.png" alt=""></p>
<p>如上图所示，假设处理器 A，B 和 C 同时向总线发起总线事务，这时总线仲裁（bus arbitration）会对竞争作出裁决，这里我们假设总线在仲裁后判定处理器 A 在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器 A 继续它的总线事务，而其它两个处理器则要等待处理器 A 的总线事务完成后才能开始再次执行内存访问。假设在处理器 A 执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器 D 向总线发起了总线事务，此时处理器 D 的这个请求会被总线禁止。</p>
<p>总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行；在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存读 / 写操作具有原子性。</p>
<p>在一些 32 位的处理器上，如果要求对 64 位数据的读 / 写操作具有原子性，会有比较大的开销。为了照顾这种处理器，Java 语言规范鼓励但不强求 JVM 对 64 位的 long 型变量和 double 型变量的读 / 写具有原子性。当 JVM 在这种处理器上运行时，会把一个 64 位 long / double 型变量的读 / 写操作拆分为两个 32 位的读 / 写操作来执行。这两个 32 位的读 / 写操作可能会被分配到不同的总线事务中执行，此时对这个 64 位变量的读 / 写将不具有原子性。</p>
<p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：</p>
<p><img src="/images/JDK/64位数据半读半写.png" alt=""></p>
<p>如上图所示，假设处理器 A 写一个 long 型变量，同时处理器 B 要读这个 long 型变量。处理器 A 中 64 位的写操作被拆分为两个 32 位的写操作，且这两个 32 位的写操作被分配到不同的写事务中执行。同时处理器 B 中 64 位的读操作被拆分为两个 32 位的读操作，且这两个 32 位的读操作被分配到同一个的读事务中执行。当处理器 A 和 B 按上图的时序来执行时，处理器 B 将看到仅仅被处理器 A“写了一半“的无效值。</p>
<p>不过这种读取到“半个变量”的情况非常罕见（在目前商用 Java 虚拟机中不会出现），因为 Java 内存模型虽然允许虚拟机不把 long 和 double 变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现在实际开发中，目前各种平台下的商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的 long 和 double 变量专门声明为 volatile。</p>
<h2 id="happen-before原则"><a href="#happen-before原则" class="headerlink" title="happen-before原则"></a>happen-before原则</h2><p>“先行发生”（happens- before）原则是判断数据是否存在竞争、线程是否安全的主要依据。Java 内存模型实现了以下几种天然的先行发生关系。</p>
<ul>
<li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构</li>
<li>管程锁定规则（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是同个锁，而“后面”是指时间上的先后顺序。</li>
<li>volatile变量规则（Volatile Variable Rule）：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序</li>
<li>线程启动规则（Thread Start Rule）：Thread 对象的 start 方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则（Thread Fermination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则（Thread Interruption Rule）；对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过<code>Thread.interrupted()</code>方法检测到是否有中断发生。</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的<code>finalize()</code>方法的开始。</li>
<li>传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。</li>
</ul>
<h3 id="示例一：对happen-before的理解"><a href="#示例一：对happen-before的理解" class="headerlink" title="示例一：对happen-before的理解"></a>示例一：对happen-before的理解</h3><p>假设线程 A 中的操作<code>i=1</code>先行发生于线程 B 的操作<code>j=i</code>，那么可以确定在线程 B 的操作执行后，变量 j 的值一定等于 1，得出这个结论的依据有两个：一是根据先行发生原则，<code>i=1</code>的结果可以被观察到；二是线程 C 还没“登场”，线程 A 操作结束之后没有其他线程会修改变量 i 的值。现在再来考虑线程 C，我们依然保持线程 A 和线程 B 之间的先行发生关系，而线程 C 出现在线程 A 和线程 B 的操作之间，但是线程 C 与线程 B 没有先行发生关系，那 j 的值会是多少呢？答案是不确定！1 和 2 都有可能，因为线程 C 对变量 i 的影响可能会被线程 B 观察到，也可能不会，这时候线程 B 就存在读取到过期数据的风险，不具备多线程安全性。</p>
<h3 id="示例二：对happen-before的分析"><a href="#示例二：对happen-before的分析" class="headerlink" title="示例二：对happen-before的分析"></a>示例二：对happen-before的分析</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面显示的是一组 getter/setter方法，假设存在线程 A 和 B，线程 A 先（时间上的先后）调用了<code>setValue(1)</code>，然后线程 B 调用了同一个对象的<code>getValue()</code>，那么线程 B 收到的返回值是什么？</p>
<p>我们依次分析一下先行发生原则中的各项规则，由于两个方法分别由线程 A 和线程 B 调用，不在一个线程中，所以程序次序规则在这里不适用；由于没有同步块，自然就不会发生 lock 和 unlock 操作，所以管程锁定规则不适用；由于 value 变量没有被 volatile 关键字修饰，所以 volatile 变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，因此我们可以判定尽管线程 A 在操作时间上先于线程 B，但是无法确定线程 B 中<code>getValue()</code>方法的返回结果，换句话说，这里面的操作不是线程安全的。</p>
<p>那怎么修复这个问题呢？我们至少有两种比较简单的方案可以选择：要么把 getter/setter 方法都定义为 synchronized 方法，这样就可以套用管程锁定规则；要么把 value 定义为 volatile 变量，由于 setter 方法对 value 的修改不依赖 value 的原值，满足 volatile 关键字使用场景，这样就可以套用 volatile 变量规则来实现先行发生关系。</p>
<h3 id="示例三：对happen-before的注意事项"><a href="#示例三：对happen-before的注意事项" class="headerlink" title="示例三：对happen-before的注意事项"></a>示例三：对happen-before的注意事项</h3><p>一个操作“时间上的先发生”不代表这个操作会是“先行发生”，并且一个操作“先行发生”不代表这个操作会是“时间上的先发生”呢。针对第二条，如下代码</p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;代码定义
int i &#x3D; 1;
int j &#x3D; 2;
&#x2F;&#x2F;运行顺序
int j &#x3D; 2;
int i &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="Java线程模型"><a href="#Java线程模型" class="headerlink" title="Java线程模型"></a>Java线程模型</h1><p>并发不一定要依赖多线程（如PHP中很常见的多进程并发）。</p>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>关于线程实现，<a target="_blank" rel="noopener" href="https://lanchestios.github.io/2021/02/08/OS-线程/">OS 线程 | 用户级和内核级线程</a>有详细的介绍。</p>
<p>对于 Sun JDK 来说，它的 Windows 版与 Linux 版都是使用一对一的线程模型实现的，一条 Java 线程就映射到一条轻量级进程之中，因为 Windows 和 Linux 系统提供的线程模型就是一对一的。而在 Solaris 平台中，由于操作系统的线程特性可以同时支持一对一（通过 Bound Threads 或 Alternate Libthread 实现）及多对多（通过 LWP/Thread Based Synchronization 实现）的线程模型，因此在 Solaris 版的 JDK 中也对应提供了两个平台专有的虚拟机参数<code>-XX:+UseLWPSynchronization（默认值）</code>和<code>-XX:+UseBoundThreads</code>来明确指定虚拟机使用哪种线程模型。</p>
<h2 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h2><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Scheduling）。</p>
<p>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。</p>
<p>Lua 语言中的“协同例程”就是这类实现。它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。很久以前的 Windows 3.x 系统就是使用协同式来实现多进程多任务的，相当不稳定，一个进程坚持不让出 CPU 执行时间就可能会导致整个系统崩溃。</p>
<p>如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在 Java 中，<code>Thread.yield()</code>可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，Java 使用的线程调度方式就是抢占式调度。与前面所说的 Windows 3.x 的例子相对，在 Windows 9x/NT 内核中就是使用抢占式来实现多进程的，当一个进程出了问题，我们还可以使用任务管理器把这个进程“杀掉”，而不至于导致系统崩溃。</p>
<p>虽然 Java 线程调度是系统自动完成的，但是我们还是可以“建议”系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点 —— 这项操作可以通过设置线程优先级来完成。Java 语言一共设置了 10 个级别的线程优先级（<code>Thread.MIN_PRIORITY</code>至<code>Thread.MAX_PRIORITY</code>），在两个线程同时处于 Ready 状态时，优先级越高的线程越容易被系统选择执行。</p>
<p>不过，线程优先级并不是太靠谱，原因是 Java 的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与 Java 线程的优先级一一对应，如 Solaris 中有 2147483648（2^32）种优先级，但 Windows 中就只有 7 种，比 Java 线程优先级多的系统还好说，中间留下点空位就可以了，但比 Java 线程优先级少的系统，就不得不出现几个优先级相同的情况了，</p>
<p>上文说到“线程优先级并不是太靠谱”，不仅仅是说在一些平台上不同的优先级实际会变得相同这一点，还有其他情况让我们能太依赖优先级：优先级可能会被系统自行改变例如，在 Windows 系统中存在一个称为“优先级推进器”（Priority Boosting，当然它以被关闭掉）的功能，它的大致作用就是当系统发现一个线程执行得特别“勤奋努力”的话，可能会越过线程优先级去为它分配执行时间。因此，我们不能在程序中通过优先级来完全准确地判断一组状态都为 Ready 的线程将会先执行哪一个。</p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p>Java 语言定义了 5 种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这 5 种状态分别如下。</p>
<p><img src="/images/JDK/线程状态转换关系.png" alt="image-20210807191730335" style="zoom: 50%;" /></p>
<ul>
<li>新建（New）：创建后尚未启动的线程处于新建状态。</li>
<li>运行（Runnable）：Runnable 包括了操作系统线程状态中的 Running 和 Ready。也就是说，处于此状态的线程有可能正在执行（Running），也有可能正在等待着 CPU 为它分配执行时间（Ready）。</li>
<li>无限期等待（Waiting）：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态：<ul>
<li><code>Object.wait()</code>方法、<code>Thread.join()</code>方法、</li>
<li><code>LockSupport.park()</code>方法</li>
<li>I/O 阻塞</li>
</ul>
</li>
<li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配 CPU 执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：<ul>
<li><code>Thread.sleep(timeout)</code>方法、<code>Object.wait(timeout)</code>方法、<code>Thread.join(timeout)</code>方法</li>
<li><code>LockSupport.parkNanos()</code>方法、<code>LockSupport.parkUntil()</code>方法</li>
</ul>
</li>
<li>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个 Monitor Lock，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li>
<li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li>
</ul>
<h2 id="线程锁与队列"><a href="#线程锁与队列" class="headerlink" title="线程锁与队列"></a>线程锁与队列</h2><p>每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待 CPU 的调度；反之，一个线程被 wait 后，就会进入阻塞队列，等待下一次被唤醒。</p>
<h1 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h1><h2 id="锁释放和获取的内存语义"><a href="#锁释放和获取的内存语义" class="headerlink" title="锁释放和获取的内存语义"></a>锁释放和获取的内存语义</h2><p>当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。</p>
<p>当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。</p>
<p>对比锁释放 - 获取的内存语义与 volatile 写 - 读的内存语义，可以看出：锁释放与 volatile 写有相同的内存语义；锁获取与 volatile 读有相同的内存语义。</p>
<h2 id="CAS内存语义"><a href="#CAS内存语义" class="headerlink" title="CAS内存语义"></a>CAS内存语义</h2><p><code>compareAndSet()</code>方法调用简称为 CAS。JDK 文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有 volatile 读和写的内存语义。</p>
<p>编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与 volatile 写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现 volatile 读和 volatile 写的内存语义，编译器不能对 CAS 与 CAS 前面和后面的任意内存操作重排序。</p>
<p>下面分析常见的 intel x86 处理器中，CAS 是如何同时具有 volatile 读和 volatile 写的内存语义的。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//sun.misc.Unsafe 类的 compareAndSwapInt() 方法</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span>
                                             <span class="token keyword">int</span> expected<span class="token punctuation">,</span>
                                             <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到这是个本地方法调用。这个本地方法在 openjdk 中依次调用的 c++ 代码为：<code>unsafe.cpp</code>、<code>atomic.cpp</code>和<code>atomic_windows_x86.inline.hpp</code>。</p>
<p>这个本地方法的最终实现在 openjdk 的如下位置：<code>openjdk-7-fcs-src-b147-27_jun_2011\openjdk\hotspot\src\os_cpu\windows_x86\vm\atomic_windows_x86.inline.hpp</code>（对应于 windows 操作系统，X86 处理器）。下面是对应于 intel x86 处理器的源代码的片段：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Adding a lock prefix to an instruction on MP machine</span>
<span class="token comment">// VC++ doesn't like the lock prefix to be on a single line</span>
<span class="token comment">// so we can't insert a label after the lock prefix.</span>
<span class="token comment">// By emitting a lock prefix, we can define a label after it.</span>
#define <span class="token function">LOCK_IF_MP</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span> __asm cmp mp<span class="token punctuation">,</span> <span class="token number">0</span>  \
                      __asm je L0      \
                      __asm _emit <span class="token number">0xF0</span> \
                      __asm L0<span class="token operator">:</span>
 
inline jint <span class="token class-name">Atomic</span><span class="token operator">::</span><span class="token function">cmpxchg</span> <span class="token punctuation">(</span>jint exchange_value<span class="token punctuation">,</span> <span class="token keyword">volatile</span> jint<span class="token operator">*</span> dest<span class="token punctuation">,</span> jint     compare_value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token comment">// alternative for InterlockedCompareExchange</span>
 <span class="token keyword">int</span> mp <span class="token operator">=</span> os<span class="token operator">::</span><span class="token function">is_MP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 __asm <span class="token punctuation">&#123;</span>
   mov edx<span class="token punctuation">,</span> dest
   mov ecx<span class="token punctuation">,</span> exchange_value
   mov eax<span class="token punctuation">,</span> compare_value
   <span class="token function">LOCK_IF_MP</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span>
   cmpxchg dword ptr <span class="token punctuation">[</span>edx<span class="token punctuation">]</span><span class="token punctuation">,</span> ecx
 <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上面源代码所示，程序会根据当前处理器的类型来决定是否为 cmpxchg 指令添加 lock 前缀。如果程序是在多处理器上运行，就为 cmpxchg 指令加上 lock 前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略 lock 前缀（单处理器自身会维护单处理器内的顺序一致性，不需要 lock 前缀提供的内存屏障效果）。</p>
<p>intel 的手册对 lock 前缀的说明如下：</p>
<ol>
<li>确保对内存的读 - 改 - 写操作原子执行。在 Pentium 及 Pentium 之前的处理器中，带有 lock 前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从 Pentium 4，Intel Xeon 及 P6 处理器开始，intel 在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在 lock 前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读 / 写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低 lock 前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li>
<li>禁止该指令与之前和之后的读和写指令重排序。</li>
<li>把写缓冲区中的所有数据刷新到内存中。</li>
</ol>
<p>上面的第 2 点和第 3 点所具有的内存屏障效果，足以同时实现 volatile 读和 volatile 写的内存语义。</p>
<p>经过上面的分析，已经介绍清楚为什么 JDK 文档说 CAS 同时具有 volatile 读和 volatile 写的内存语义了。</p>
<p>现在对公平锁和非公平锁的内存语义做个总结：</p>
<ul>
<li>公平锁和非公平锁释放时，最后都要写一个 volatile 变量 state。</li>
<li>公平锁获取时，首先会去读这个 volatile 变量。</li>
<li>非公平锁获取时，首先会用 CAS 更新这个 volatile 变量, 这个操作同时具有 volatile 读和 volatile 写的内存语义。</li>
</ul>
<p>锁释放 - 获取的内存语义的实现至少有下面两种方式：</p>
<ol>
<li>利用 volatile 变量的写 - 读所具有的内存语义。</li>
<li>利用 CAS 所附带的 volatile 读和 volatile 写的内存语义。</li>
</ol>
<blockquote>
<p><strong>CAS 的 ABA 问题</strong></p>
<p>CAS 可以认为它是一种乐观锁，其实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p>
<p>假设 X 链表为 HEAD-&gt;A-&gt;B-&gt;A，只一次 CAS (A-&gt;D) 的话，结果应为 HEAD-&gt;A-&gt;B-&gt;D。但如果中间被其他线程抢占，如被删除尾部两个节点，现在 X 链表为 HEAD-&gt;A，再进行一次 CAS (A-&gt;D) 结果为 HEAD-&gt;D。</p>
<p>尽管操作是原子且正确的，但不代表过程没有问题，其造成的结果是不正确的。</p>
<p><strong>对ABA问题的解决</strong></p>
<p>新增版本号机制，对每次修改版本号自增，对比版本号即可知道是否在执行过程中操作对象发生了变化。</p>
</blockquote>
<h2 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h2><p>重排序分为编译器重排序和处理器重排序。为了实现 volatile 内存语义，JMM 会分别限制这两种类型的重排序类型。下面是 JMM 针对编译器制定的 volatile 重排序规则表：</p>
<p><img src="/images/JDK/volatile重排序规则表.png" alt=""></p>
<p>从上表我们可以看出：</p>
<ul>
<li>当第二个操作是 volatile 写时，不管第一个操作是什么，都不能重排序。这个规则确保 volatile 写之前的操作不会被编译器重排序到 volatile 写之后。</li>
<li>当第一个操作是 volatile 读时，不管第二个操作是什么，都不能重排序。这个规则确保 volatile 读之后的操作不会被编译器重排序到 volatile 读之前。</li>
<li>当第一个操作是 volatile 写，第二个操作是 volatile 读时，不能重排序。</li>
</ul>
<p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM 采取保守策略。下面是基于保守策略的 JMM 内存屏障插入策略：</p>
<ul>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li>
</ul>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的 volatile 内存语义。</p>
<p><strong>volatile写内存屏障</strong></p>
<p>下面是保守策略下，volatile 写插入内存屏障后生成的指令序列示意图：</p>
<p><img src="/images/JDK/volatile写内存屏障.png" alt=""></p>
<p>上图中的 StoreStore 屏障可以保证在 volatile 写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为 StoreStore 屏障将保障上面所有的普通写在 volatile 写之前刷新到主内存。</p>
<p>这里比较有意思的是 volatile 写后面的 StoreLoad 屏障。这个屏障的作用是避免 volatile 写与后面可能有的 volatile 读 / 写操作重排序。因为编译器常常无法准确判断在一个 volatile 写的后面，是否需要插入一个 StoreLoad 屏障（比如，一个 volatile 写之后方法立即 return）。为了保证能正确实现 volatile 的内存语义，JMM 在这里采取了保守策略：在每个 volatile 写的后面或在每个 volatile 读的前面插入一个 StoreLoad 屏障。从整体执行效率的角度考虑，JMM 选择了在每个 volatile 写的后面插入一个 StoreLoad 屏障。因为 volatile 写 - 读内存语义的常见使用模式是：一个写线程写 volatile 变量，多个读线程读同一个 volatile 变量。当读线程的数量大大超过写线程时，选择在 volatile 写之后插入 StoreLoad 屏障将带来可观的执行效率的提升。从这里我们可以看到 JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</p>
<p>下面是在保守策略下，volatile 读插入内存屏障后生成的指令序列示意图：</p>
<p><img src="/images/JDK/volatile读内存屏障.png" alt=""></p>
<p>上图中的 LoadLoad 屏障用来禁止处理器把上面的 volatile 读与下面的普通读重排序。LoadStore 屏障用来禁止处理器把上面的 volatile 读与下面的普通写重排序。</p>
<p>上述 volatile 写和 volatile 读的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile 写 - 读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面我们通过具体的示例代码来说明：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">class</span> <span class="token class-name">VolatileBarrierExample</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">int</span> a<span class="token punctuation">;</span>
   <span class="token keyword">volatile</span> <span class="token keyword">int</span> v1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token keyword">volatile</span> <span class="token keyword">int</span> v2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
 
   <span class="token keyword">void</span> <span class="token function">readAndWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       <span class="token keyword">int</span> i <span class="token operator">=</span> v1<span class="token punctuation">;</span>           <span class="token comment">// 第一个 volatile 读</span>
       <span class="token keyword">int</span> j <span class="token operator">=</span> v2<span class="token punctuation">;</span>           <span class="token comment">// 第二个 volatile 读</span>
       a <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>            <span class="token comment">// 普通写</span>
       v1 <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>           <span class="token comment">// 第一个 volatile 写</span>
       v2 <span class="token operator">=</span> j <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>           <span class="token comment">// 第二个 volatile 写</span>
   <span class="token punctuation">&#125;</span>
 
   …                    <span class="token comment">// 其他方法</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>针对 readAndWrite() 方法，编译器在生成字节码时可以做如下的优化：</p>
<p><img src="/images/JDK/readAndWrite方法编译器生成字节码.png" alt=""></p>
<p>注意，最后的 StoreLoad 屏障不能省略。因为第二个 volatile 写之后，方法立即 return。此时编译器可能无法准确断定后面是否会有 volatile 读或写，为了安全起见，编译器常常会在这里插入一个 StoreLoad 屏障。</p>
<p>上面的优化是针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以 x86 处理器为例，上图中除最后的 StoreLoad 屏障外，其它的屏障都会被省略。</p>
<p>前面保守策略下的 volatile 读和写，在 x86 处理器平台可以优化成：</p>
<p><img src="/images/JDK/readAndWrite方法编译器优化生成字节码.png" alt=""></p>
<p>前文提到过，x86 处理器仅会对写 - 读操作做重排序。X86 不会对读 - 读，读 - 写和写 - 写操作做重排序，因此在 x86 处理器中会省略掉这三种操作类型对应的内存屏障。在 x86 中，JMM 仅需在 volatile 写后面插入一个 StoreLoad 屏障即可正确实现 volatile 写 - 读的内存语义。这意味着在 x86 处理器中，volatile 写的开销比 volatile 读的开销会大很多（因为执行 StoreLoad 屏障开销会比较大）。</p>
<blockquote>
<p><strong>JSR-133 为什么要增强 volatile 的内存语义</strong></p>
<p>在 JSR-133 之前的旧 Java 内存模型中，虽然不允许 volatile 变量之间重排序，但旧的 Java 内存模型允许 volatile 变量与普通变量之间重排序。在旧的内存模型中，VolatileExample 示例程序可能被重排序成下列时序来执行：</p>
<p><img src="/images/JDK/VolatileExample示例程序被重排序.png" alt=""></p>
<p>在旧的内存模型中，当 1 和 2 之间没有数据依赖关系时，1 和 2 之间就可能被重排序（3 和 4 类似）。其结果就是：读线程 B 执行 4 时，不一定能看到写线程 A 在执行 1 时对共享变量的修改。</p>
<p>因此在旧的内存模型中 ，volatile 的写 - 读没有监视器的释放 - 获所具有的内存语义。为了提供一种比监视器锁更轻量级的线程之间通信的机制，JSR-133 专家组决定增强 volatile 的内存语义：严格限制编译器和处理器对 volatile 变量与普通变量的重排序，确保 volatile 的写 - 读和监视器的释放 - 获取一样，具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要 volatile 变量与普通变量之间的重排序可能会破坏 volatile 的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</p>
<p>由于 volatile 仅仅保证对单个 volatile 变量的读 / 写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比 volatile 更强大；在可伸缩性和执行性能上，volatile 更有优势。如果读者想在程序中用 volatile 代替监视器锁，请一定谨慎。</p>
</blockquote>
<h2 id="final内存语义"><a href="#final内存语义" class="headerlink" title="final内存语义"></a>final内存语义</h2><h3 id="final的重排序规则"><a href="#final的重排序规则" class="headerlink" title="final的重排序规则"></a>final的重排序规则</h3><p>与前面介绍的锁和 volatile 相比较，对 final 域的读和写更像是普通的变量访问。对于 final 域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含 final 域的对象的引用，与随后初次读这个对象的 final 域，这两个操作之间不能重排序。</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalExample</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">int</span> i<span class="token punctuation">;</span>                            <span class="token comment">// 普通变量</span>
   <span class="token keyword">final</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span>                      <span class="token comment">//final 变量</span>
   <span class="token keyword">static</span> <span class="token class-name">FinalExample</span> obj<span class="token punctuation">;</span>
 
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">FinalExample</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 构造函数</span>
       i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token comment">// 写普通域</span>
       j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                        <span class="token comment">// 写 final 域</span>
   <span class="token punctuation">&#125;</span>
 
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> writer <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 写线程 A 执行</span>
       obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalExample</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
 
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> reader <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 读线程 B 执行</span>
       <span class="token class-name">FinalExample</span> object <span class="token operator">=</span> obj<span class="token punctuation">;</span>       <span class="token comment">// 读对象引用</span>
       <span class="token keyword">int</span> a <span class="token operator">=</span> object<span class="token punctuation">.</span>i<span class="token punctuation">;</span>                <span class="token comment">// 读普通域</span>
       <span class="token keyword">int</span> b <span class="token operator">=</span> object<span class="token punctuation">.</span>j<span class="token punctuation">;</span>                <span class="token comment">// 读 final 域</span>
   <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里假设一个线程 A 执行 writer () 方法，随后另一个线程 B 执行 reader () 方法。下面我们通过这两个线程的交互来说明两个重排序规则。</p>
<h4 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a>写final域的重排序规则</h4><p>写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面 2 个方面：</p>
<ul>
<li><strong>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</strong></li>
<li><strong>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</strong></li>
</ul>
<p>现在让我们分析<code>writer()</code>方法。<code>writer()</code>方法只包含一行代码：<code>finalExample = new FinalExample()</code>。这行代码包含两个步骤：</p>
<ol>
<li>构造一个 FinalExample 类型的对象；</li>
<li>把这个对象的引用赋值给引用变量 obj。</li>
</ol>
<p>假设线程 B 读对象引用与读对象的成员域之间没有重排序，下图是一种可能的执行时序：</p>
<p><img src="/images/JDK/写final域的重排序规则.png" alt=""></p>
<p>在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程 B 错误的读取了普通变量 i 初始化之前的值。而写 final 域的操作，被写 final 域的重排序规则“限定”在了构造函数之内，读线程 B 正确的读取了 final 变量初始化之后的值。</p>
<p>写 final 域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程 B“看到”对象引用 obj 时，很可能 obj 对象还没有构造完成（对普通域 i 的写操作被重排序到构造函数外，此时初始值 2 还没有写入普通域 i）。</p>
<h4 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a>读final域的重排序规则</h4><p>读 final 域的重排序规则如下：</p>
<p><strong>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</strong></p>
<p>初次读对象引用与初次读该对象包含的 final 域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如 alpha 处理器），这个规则就是专门用来针对这种处理器。</p>
<p>reader() 方法包含三个操作：</p>
<ol>
<li>初次读引用变量 obj。</li>
<li>初次读引用变量 obj 指向对象的普通域 j。</li>
<li>初次读引用变量 obj 指向对象的 final 域 i。</li>
</ol>
<p>现在我们假设写线程 A 没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：</p>
<p><img src="/images/JDK/读final域的重排序规则.png" alt=""></p>
<p>在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程 A 写入，这是一个错误的读取操作。而读 final 域的重排序规则会把读对象 final 域的操作“限定”在读对象引用之后，此时该 final 域已经被 A 线程初始化过了，这是一个正确的读取操作。</p>
<p>读 final 域的重排序规则可以确保：在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象的引用。在这个示例程序中，如果该引用不为 null，那么引用对象的 final 域一定已经被 A 线程初始化过了。</p>
<h3 id="final域是引用类型"><a href="#final域是引用类型" class="headerlink" title="final域是引用类型"></a>final域是引用类型</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalReferenceExample</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intArray<span class="token punctuation">;</span>                     <span class="token comment">//final 是引用类型</span>
    <span class="token keyword">static</span> <span class="token class-name">FinalReferenceExample</span> obj<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">FinalReferenceExample</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 构造函数</span>
       intArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">//1</span>
       intArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                   <span class="token comment">//2</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> writerOne <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 写线程 A 执行</span>
       obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalReferenceExample</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//3</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> writerTwo <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 写线程 B 执行</span>
       obj<span class="token punctuation">.</span>intArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                 <span class="token comment">//4</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> reader <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token comment">// 读线程 C 执行</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">//5</span>
           <span class="token keyword">int</span> temp1 <span class="token operator">=</span> obj<span class="token punctuation">.</span>intArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//6</span>
       <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里 final 域为一个引用类型，它引用一个 int 型的数组对象。对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：</p>
<p><strong>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</strong></p>
<p>对上面的示例程序，我们假设首先线程 A 执行<code>writerOne()</code>方法，执行完后线程 B 执行<code>writerTwo()</code>方法，执行完后线程 C 执行<code>reader()</code>方法。下面是一种可能的线程执行时序：</p>
<p><img src="/images/JDK/final引用类型.png" alt=""></p>
<p>在上图中，1 是对 final 域的写入，2 是对这个 final 域引用的对象的成员域的写入，3 是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的 1 不能和 3 重排序外，2 和 3 也不能重排序。</p>
<p>JMM 可以确保读线程 C 至少能看到写线程 A 在构造函数中对 final 引用对象的成员域的写入。即 C 至少能看到数组下标 0 的值为 1。而写线程 B 对数组元素的写入，读线程 C 可能看的到，也可能看不到。JMM 不保证线程 B 的写入对读线程 C 可见，因为写线程 B 和读线程 C 之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程 C 看到写线程 B 对数组元素的写入，写线程 B 和读线程 C 之间需要使用同步原语（lock 或 volatile）来确保内存可见性。</p>
<h3 id="为什么final引用不能从构造函数内“逸出”"><a href="#为什么final引用不能从构造函数内“逸出”" class="headerlink" title="为什么final引用不能从构造函数内“逸出”"></a>为什么final引用不能从构造函数内“逸出”</h3><p>前面我们提到过，写 final 域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的 final 域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。为了说明问题，让我们来看下面示例代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalReferenceEscapeExample</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token class-name">FinalReferenceEscapeExample</span> obj<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">FinalReferenceEscapeExample</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                              <span class="token comment">//1 写 final 域</span>
       obj <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>                          <span class="token comment">//2 this 引用在此“逸出”</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       <span class="token keyword">new</span> <span class="token class-name">FinalReferenceEscapeExample</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> reader <span class="token punctuation">&#123;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                     <span class="token comment">//3</span>
           <span class="token keyword">int</span> temp <span class="token operator">=</span> obj<span class="token punctuation">.</span>i<span class="token punctuation">;</span>                 <span class="token comment">//4</span>
       <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假设一个线程 A 执行<code>writer()</code>方法，另一个线程 B 执行<code>reader()</code>方法。这里的操作 2 使得对象还未完成构造前就为线程 B 可见。即使这里的操作 2 是构造函数的最后一步，且即使在程序中操作 2 排在操作 1 后面，执行<code>read()</code>方法的线程仍然可能无法看到 final 域被初始化后的值，因为这里的操作 1 和操作 2 之间可能被重排序。实际的执行时序可能如下图所示：</p>
<p><img src="/images/JDK/final引用逸出.png" alt=""></p>
<p>从上图我们可以看出：在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的 final 域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到 final 域正确初始化之后的值。</p>
<h3 id="final-语义在处理器中的实现"><a href="#final-语义在处理器中的实现" class="headerlink" title="final 语义在处理器中的实现"></a>final 语义在处理器中的实现</h3><p>现在我们以 x86 处理器为例，说明 final 语义在处理器中的具体实现。</p>
<p>上面我们提到，写 final 域的重排序规则会要求译编器在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 障屏。读 final 域的重排序规则要求编译器在读 final 域的操作前面插入一个 LoadLoad 屏障。</p>
<p>由于 x86 处理器不会对写 - 写操作做重排序，所以在 x86 处理器中，写 final 域需要的 StoreStore 屏障会被省略掉。同样，由于 x86 处理器不会对存在间接依赖关系的操作做重排序，所以在 x86 处理器中，读 final 域需要的 LoadLoad 屏障也会被省略掉。也就是说在 x86 处理器中，final 域的读 / 写不会插入任何内存屏障！</p>
<h3 id="JSR-133-为什么要增强-final-的语义"><a href="#JSR-133-为什么要增强-final-的语义" class="headerlink" title="JSR-133 为什么要增强 final 的语义"></a>JSR-133 为什么要增强 final 的语义</h3><p>在旧的 Java 内存模型中 ，最严重的一个缺陷就是线程可能看到 final 域的值会改变。比如，一个线程当前看到一个整形 final 域的值为 0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个 final 域的值时，却发现值变为了 1（被某个线程初始化之后的值）。最常见的例子就是在旧的 Java 内存模型中，String 的值可能会改变（<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/users/pugh/java/memoryModel/jsr-133-faq.html">示例链接</a>）。</p>
<p>为了修补这个漏洞，JSR-133 专家组增强了 final 的语义。通过为 final 域增加写和读重排序规则，可以为 java 程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指 lock 和 volatile 的使用），就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。</p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="处理器内存模型"><a href="#处理器内存模型" class="headerlink" title="处理器内存模型"></a>处理器内存模型</h2><p>顺序一致性内存模型是一个理论参考模型，JMM 和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM 和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和 JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。</p>
<p>根据对不同类型读 / 写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为下面几种类型：</p>
<ol>
<li>放松程序中写 - 读操作的顺序，由此产生了<code>Total Store Ordering</code>内存模型（简称为 TSO）。</li>
<li>在前面 1 的基础上，继续放松程序中写 - 写操作的顺序，由此产生了<code>Partial Store Order</code>内存模型（简称为 PSO）。</li>
<li>在前面 1 和 2 的基础上，继续放松程序中读 - 写和读 - 读操作的顺序，由此产生了<code>Relaxed Memory Order</code>内存模型（简称为 RMO）和 PowerPC 内存模型。</li>
</ol>
<p>注意，这里处理器对读 / 写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守 as-if-serial 语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。</p>
<p>下面的表格展示了常见处理器内存模型的细节特征：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内存模型名称</th>
<th>对应的处理器</th>
<th>Store-Load 重排序</th>
<th>Store-Store 重排序</th>
<th>Load-Load 和 Load-Store 重排序</th>
<th>可以更早读取到其它处理器的写</th>
<th>可以更早读取到当前处理器的写</th>
</tr>
</thead>
<tbody>
<tr>
<td>TSO</td>
<td>sparc-TSO X64</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td>PSO</td>
<td>sparc-PSO</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td>RMO</td>
<td>ia64</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td>PowerPC</td>
<td>PowerPC</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
</div>
<p>在这个表格中，我们可以看到所有处理器内存模型都允许写 - 读重排序。因为它们都使用了写缓存区，写缓存区可能导致写 - 读操作重排序。同时，我们可以看到这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写。</p>
<p>上面表格中的各种处理器内存模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计的会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。</p>
<p>由于常见的处理器内存模型比 JMM 要弱，Java 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM 在不同的处理器中需要插入的内存屏障的数量和种类也不相同。下图展示了 JMM 在不同处理器内存模型中需要插入的内存屏障的示意图：</p>
<p><img src="/images/JDK/JMM在不同处理器内存模型中需要插入的内存屏障的示意图.png" alt=""></p>
<p>如上图所示，JMM 屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 Java 程序员呈现了一个一致的内存模型。</p>
<h2 id="语言内存模型，处理器内存模型和顺序一致性内存模型的对比"><a href="#语言内存模型，处理器内存模型和顺序一致性内存模型的对比" class="headerlink" title="语言内存模型，处理器内存模型和顺序一致性内存模型的对比"></a>语言内存模型，处理器内存模型和顺序一致性内存模型的对比</h2><p>JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p>
<p><img src="/images/JDK/语言内存模型处理器内存模型和顺序一致性内存模型的强弱对比示意图.png" alt=""></p>
<p>从上图我们可以看出：常见的 4 种处理器内存模型比常用的 3 中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计的会越弱。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JDK/" rel="tag"># JDK</a>
              <a href="/tags/CAS/" rel="tag"># CAS</a>
              <a href="/tags/JMM/" rel="tag"># JMM</a>
              <a href="/tags/JVM/" rel="tag"># JVM</a>
              <a href="/tags/volitile/" rel="tag"># volitile</a>
              <a href="/tags/happen-before/" rel="tag"># happen-before</a>
              <a href="/tags/final/" rel="tag"># final</a>
              <a href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag"># 线程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/22/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" rel="prev" title="JVM 字节码执行引擎">
      <i class="fa fa-chevron-left"></i> JVM 字节码执行引擎
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/26/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6/" rel="next" title="JVM 内存分配和回收">
      JVM 内存分配和回收 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU-Cache%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">CPU Cache模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98"><span class="nav-number">2.1.</span> <span class="nav-text">主内存与工作内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.</span> <span class="nav-text">内存间的交互操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="nav-number">2.3.</span> <span class="nav-text">指令重排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="nav-number">2.3.1.</span> <span class="nav-text">数据依赖性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E5%BA%8F%E5%88%86%E7%B1%BB"><span class="nav-number">2.3.2.</span> <span class="nav-text">重排序分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#as-if-serial-%E8%AF%AD%E4%B9%89"><span class="nav-number">2.3.3.</span> <span class="nav-text">as-if-serial 语义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8Evolatile%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="nav-number">2.4.</span> <span class="nav-text">对于volatile型变量的特殊规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">2.4.1.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="nav-number">2.4.2.</span> <span class="nav-text">禁止指令重排序优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8Elong%E5%92%8Cdouble%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="nav-number">2.5.</span> <span class="nav-text">对于long和double型变量的特殊规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#happen-before%E5%8E%9F%E5%88%99"><span class="nav-number">2.6.</span> <span class="nav-text">happen-before原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%AF%B9happen-before%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">2.6.1.</span> <span class="nav-text">示例一：对happen-before的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%AF%B9happen-before%E7%9A%84%E5%88%86%E6%9E%90"><span class="nav-number">2.6.2.</span> <span class="nav-text">示例二：对happen-before的分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%89%EF%BC%9A%E5%AF%B9happen-before%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.6.3.</span> <span class="nav-text">示例三：对happen-before的注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">Java线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.</span> <span class="nav-text">线程的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">3.2.</span> <span class="nav-text">Java线程调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.3.</span> <span class="nav-text">状态转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%94%81%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-number">3.4.</span> <span class="nav-text">线程锁与队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="nav-number">4.</span> <span class="nav-text">内存语义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E9%87%8A%E6%94%BE%E5%92%8C%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text">锁释放和获取的内存语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="nav-number">4.2.</span> <span class="nav-text">CAS内存语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="nav-number">4.3.</span> <span class="nav-text">volatile内存语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="nav-number">4.4.</span> <span class="nav-text">final内存语义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="nav-number">4.4.1.</span> <span class="nav-text">final的重排序规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99final%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">写final域的重排序规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BBfinal%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">读final域的重排序规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%9F%9F%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.2.</span> <span class="nav-text">final域是引用类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88final%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BB%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%85%E2%80%9C%E9%80%B8%E5%87%BA%E2%80%9D"><span class="nav-number">4.4.3.</span> <span class="nav-text">为什么final引用不能从构造函数内“逸出”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-%E8%AF%AD%E4%B9%89%E5%9C%A8%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.4.4.</span> <span class="nav-text">final 语义在处理器中的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSR-133-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A2%9E%E5%BC%BA-final-%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="nav-number">4.4.5.</span> <span class="nav-text">JSR-133 为什么要增强 final 的语义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">5.</span> <span class="nav-text">扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">处理器内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%A4%84%E7%90%86%E5%99%A8%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">5.2.</span> <span class="nav-text">语言内存模型，处理器内存模型和顺序一致性内存模型的对比</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang Zihao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">144</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">287</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Zihao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
