<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流（Exceptional Control Flow，ECF）。">
<meta property="og:type" content="article">
<meta property="og:title" content="CS 异常控制流">
<meta property="og:url" content="http://example.com/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-8-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/index.html">
<meta property="og:site_name" content="Lanchester Blog">
<meta property="og:description" content="现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流（Exceptional Control Flow，ECF）。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/ComputerSystems/异常的剖析.png">
<meta property="og:image" content="http://example.com/images/ComputerSystems/异常表.png">
<meta property="og:image" content="http://example.com/images/ComputerSystems/生成异常处理程序的地址.png">
<meta property="og:image" content="http://example.com/images/ComputerSystems/中断处理.png">
<meta property="og:image" content="http://example.com/images/ComputerSystems/陷阱处理.png">
<meta property="og:image" content="http://example.com/images/ComputerSystems/故障处理.png">
<meta property="og:image" content="http://example.com/images/ComputerSystems/终止处理.png">
<meta property="og:image" content="http://example.com/images/ComputerSystems/逻辑控制流.png">
<meta property="og:image" content="http://example.com/images/ComputerSystems/进程地址空间.png">
<meta property="og:image" content="http://example.com/images/ComputerSystems/进程上下文切换的剖析.png">
<meta property="og:image" content="http://example.com/images/ComputerSystems/信号处理.png">
<meta property="og:image" content="http://example.com/images/ComputerSystems/信号处理程序可以被其他信号处理程序中断.png">
<meta property="article:published_time" content="2021-11-02T07:36:55.000Z">
<meta property="article:modified_time" content="2022-11-07T05:34:03.723Z">
<meta property="article:author" content="Wang Zihao">
<meta property="article:tag" content="Computer Systems">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/ComputerSystems/异常的剖析.png">

<link rel="canonical" href="http://example.com/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-8-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CS 异常控制流 | Lanchester Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lanchester Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Leave a leaf</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-8-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Zihao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lanchester Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CS 异常控制流
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-02 15:36:55" itemprop="dateCreated datePublished" datetime="2021-11-02T15:36:55+08:00">2021-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-07 13:34:03" itemprop="dateModified" datetime="2022-11-07T13:34:03+08:00">2022-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Systems/" itemprop="url" rel="index"><span itemprop="name">Computer Systems</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为<strong>异常控制流</strong>（Exceptional Control Flow，ECF）。</p>
<span id="more"></span>
<p>从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列</p>
<script type="math/tex; mode=display">
a_0, a_1, \cdots, a_{n-1}</script><p>其中，每个 <script type="math/tex">a_k</script> 是某个相应的指令 <script type="math/tex">I_k</script> 的地址。每次从 <script type="math/tex">a_k</script> 到 <script type="math/tex">a_{k+1}</script> 的过渡称为<strong>控制转移</strong>（control transfer）。这样的控制转移序列叫做处理器的<strong>控制流</strong>（flow of control 或 control flow）。</p>
<p>最简单的一种控制流是一个“平滑的”序列，其中每个<script type="math/tex">I_k</script>和<script type="math/tex">I_{k+1}</script>在内存中都是相邻的。这种平滑流的突变（也就是<script type="math/tex">I_{k+1}</script>与<script type="math/tex">I_k</script>不相邻）通常是由诸如跳转、调用和返回这样一些熟悉的程序指令造成的。这样一些指令都是必要的机制，使得程序能够对由程序变量表示的内部程序状态中的变化做出反应。</p>
<p>但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。当子进程终止时，创造这些子进程的父进程必须得到通知。</p>
<p>现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为<strong>异常控制流</strong>（Exceptional Control Flow，ECF）。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。—个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。</p>
<p>有四种不同类型的异常：中断、故障、终止和陷阱。当一个外部 I/O 设备（例如定时器芯片或者磁盘控制器）设置了处理器芯片上的中断管脚时，（对于任意指令）中断会异步地发生。控制返回到故障指令后面的那条指令。一条指令的执行可能导致故障和终止同步发生。故障处理程序会重新启动故障指令，而终止处理程序从不将控制返回给被中断的流。最后，陷阱就像是用来实现向应用提供到操作系统代码的受控的人口点的系统调用的函数调用。</p>
<p>在操作系统层，内核用 ECF 提供进程的基本概念。进程提供给应用两个重要的抽象：</p>
<ol>
<li>逻辑控制流，它提供给每个程序一个假象，好像它是在独占地使用处理器；</li>
<li>私有地址空间，它提供给每个程序一个假象，好像它是在独占地使用主存。</li>
</ol>
<p>在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及捕获来自其他进程的信号。信号处理的语义是微妙的，并且随系统不同而不同。然而，在与 Posix 兼容的系统上存在着一些机制，允许程序清楚地指定期望的信号处理语义。</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。在这一节中我们的目的是让你对异常和异常处理有一个一般性的了解，并且向你揭示现代计算机系统的一个经常令人感到迷惑的方面。</p>
<p><strong>异常</strong>（exception）就是控制流中的突变，用来响应处理器状态中的某些变化。图 8-1 展示了基本的思想。</p>
<p><img src="/images/ComputerSystems/异常的剖析.png" alt=""></p>
<p>在图中，当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令 <script type="math/tex">I_{curr}</script> 。在处理器中，状态被编码为不同的位和信号。状态变化称为<strong>事件</strong>（event）. 事件可能和当前指令的执行直接相关。比如，发生虚拟内存缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个 I/O 请求完成。</p>
<p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>（exception table）的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（<strong>异常处理程序</strong>（exception handler））.当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下 3 种情况中的一种：</p>
<ol>
<li>处理程序将控制返回给当前指令 <script type="math/tex">I_{curr}</script> ，即当事件发生时正在执行的指令。</li>
<li>处理程序将控制返回给 <script type="math/tex">I_{next}</script> ，如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序终止被中断的程序。</li>
</ol>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常可能会难以理解，因为处理异常需要硬件和软件紧密合作。很容易搞混哪个部分执行哪个任务。让我们更详细地来看看硬件和软件的分工吧。</p>
<p>系统中可能的每种类型的异常都分配了一个唯一的非负整数的<strong>异常号</strong>（exception number）。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻内存的部分）的设计者分配的。前者的示例包括被零除、缺页、内存访问违例、断点以及算术运算溢出。后者的示例包括系统调用和来自外部 I/O 设备的信号。</p>
<p>在系统启动时（当计算机重启或者加电时），操作系统分配和初始化一张称为<strong>异常表</strong>的跳转表，使得表目 k 包含异常 k 的处理程序的地址。图 8-2 展示了异常表的格式。</p>
<p><img src="/images/ComputerSystems/异常表.png" alt=""></p>
<p>在运行时（当系统在执行某个程序时），处理器检测到发生了一个事件，并且确定了相应的异常号 k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目 k，转到相应的处理程序。图 8-3 展示了处理器如何使用异常表来形成适当的异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>（exception table base register）的特殊 CPU 寄存器里。</p>
<p><img src="/images/ComputerSystems/生成异常处理程序的地址.png" alt=""></p>
<p>异常类似于过程调用，但是有一些重要的不同之处：</p>
<ul>
<li>过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在当前指令后执行的指令）。</li>
<li>处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。比如，x86-64 系统会将包含当前条件码的 EFLAGS 寄存器和其他内容压入栈中。</li>
<li>如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中。</li>
<li>异常处理程序运行在内核模式下（见 8.2.4 节），这意味着它们对所有的系统资源都有完全的访问权限。</li>
</ul>
<p>一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完事件之后，它通过执行一条特殊的“从中断返回”指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，就将状态恢复为<strong>用户模式</strong>（见 8.2.4 节），然后将控制返回给被中断的程序。</p>
<h2 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h2><p>异步异常是由处理器外部的 I/O 设备中的事件产生的。同步异常是执行一条指令的直接产物。异常可以分为四类：<strong>中断</strong>（interrupt），<strong>陷阱</strong>（trap）、<strong>故障</strong>（fault）和<strong>终止</strong>（abort）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:left">原因</th>
<th style="text-align:center">异步/同步</th>
<th style="text-align:left">返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">中断</td>
<td style="text-align:left">来自 I/O 设备的信号</td>
<td style="text-align:center">异步</td>
<td style="text-align:left">总是返回到下一条指令</td>
</tr>
<tr>
<td style="text-align:center">陷阱</td>
<td style="text-align:left">有意的异常</td>
<td style="text-align:center">同步</td>
<td style="text-align:left">总是返回到下一条指令</td>
</tr>
<tr>
<td style="text-align:center">故障</td>
<td style="text-align:left">潜在可恢复的错误</td>
<td style="text-align:center">同步</td>
<td style="text-align:left">可能返回到当前指令</td>
</tr>
<tr>
<td style="text-align:center">终止</td>
<td style="text-align:left">不可恢复的错误</td>
<td style="text-align:center">同步</td>
<td style="text-align:left">不会返回</td>
</tr>
</tbody>
</table>
</div>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p><strong>中断</strong>是异步发生的，是来自处理器外部的 I/O 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为<strong>中断处理程序</strong>（interrupt handler）。</p>
<p>图 8-5 概述了一个中断的处理。I/O 设备，例如网络适配器、磁盘控制器和定时器芯片，通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。</p>
<p><img src="/images/ComputerSystems/中断处理.png" alt=""></p>
<p>在当前指令完成执行之后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，它就将控制返回给下一条指令（也即如果没有发生中断，在控制流中会在当前指令之后的那条指令）。结果是程序继续执行，就好像没有发生过中断一样。</p>
<p>剩下的异常类型（陷阱、故障和终止）是同步发生的，是执行当前指令的结果。我们把这类指令叫做<strong>故障指令</strong>（faulting instruction）。</p>
<h3 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h3><p>陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p>
<p>用户程序经常需要向内核请求服务，比如读一个文件（read）、创建一个新的进程（fork），加载一个新的程序（execve），或者终止当前进程（exit）。为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的 “syscall n” 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 syscall 指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。图 8-6 概述了一个系统调用的处理。</p>
<p><img src="/images/ComputerSystems/陷阱处理.png" alt=""></p>
<p>从程序员的角度来看，系统调用和普通的函数调用是一样的。然而，它们的实现非常不同。普通的函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。8.2.4 节会更详细地讨论用户模式和内核模式。</p>
<h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序。图 8-7 概述了一个故障的处理。</p>
<p><img src="/images/ComputerSystems/故障处理.png" alt=""></p>
<p>一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。就像我们将在第 9 章中看到的那样，一个页面就是虚拟内存的一个连续的块（典型的是 4KB）。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。</p>
<h3 id="4-终止"><a href="#4-终止" class="headerlink" title="4. 终止"></a>4. 终止</h3><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。如图 8-8 所示，处理程序将控制返回给一个 abort 例程，该例程会终止这个应用程序。</p>
<p><img src="/images/ComputerSystems/终止处理.png" alt=""></p>
<h2 id="Linux-x86-64-系统中的异常"><a href="#Linux-x86-64-系统中的异常" class="headerlink" title="Linux/x86-64 系统中的异常"></a>Linux/x86-64 系统中的异常</h2><p>为了使描述更具体，让我们来看看为 x86-64 系统定义的一些异常。有高达 256 种不同的异常类型【50】。0 ∼ 31 的号码对应的是由 Intel 架构师定义的异常，因此对任何 x86-64 系统都是一样的。32 ∼ 255 的号码对应的是操作系统定义的中断和陷阱。图 8-9 展示了一些示例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">异常号</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">异常类别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">除法错误</td>
<td style="text-align:left">故障</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">一般保护故障</td>
<td style="text-align:left">故障</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left">缺页</td>
<td style="text-align:left">故障</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left">机器检查</td>
<td style="text-align:left">终止</td>
</tr>
<tr>
<td style="text-align:left">32 ~ 255</td>
<td style="text-align:left">操作系统定义的异常</td>
<td style="text-align:left">中断或陷阱</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>图 8-9 x86-64 系统中的异常示例</p>
</blockquote>
<h3 id="Linux-x86-64-故障和终止"><a href="#Linux-x86-64-故障和终止" class="headerlink" title="Linux/x86-64 故障和终止"></a>Linux/x86-64 故障和终止</h3><p><strong>除法错误。</strong>当应用试图除以零时，或者当一个除法指令的结果对于目标操作数来说太大了的时候，就会发生除法错误（异常 0）。Unix 不会试图从除法错误中恢复，而是选择终止程序。Linuxshell 通常会把除法错误报告为“浮点异常（Floating exception）”。</p>
<p><strong>一般保护故障。</strong>许多原因都会导致不为人知的一般保护故障（异常 13），通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux 不会尝试恢复这类故障。Linux shell 通常会把这种一般保护故障报告为“段故障（Segmentation fault）”。</p>
<p><strong>缺页</strong>（异常 14）是会重新执行产生故障的指令的一个异常示例。处理程序将适当的磁盘上虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条产生故障的指令。我们将在第 9 章中看到缺页是如何工作的细节。</p>
<p><strong>机器检查。</strong>机器检查（异常 18）是在导致故障的指令执行中检测到致命的硬件错误时发生的。机器检查处理程序从不返回控制给应用程序。</p>
<h3 id="Linux-86-64-系统调用"><a href="#Linux-86-64-系统调用" class="headerlink" title="Linux/86-64 系统调用"></a>Linux/86-64 系统调用</h3><p>Linux 提供几百种系统调用，当应用程序想要请求内核服务时可以使用，包括读文件、写文件或是创建一个新进程。图 8-10 给出了一些常见的 Linux 系统调用。每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量。（注意：这个跳转表和异常表不一样。）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:right">编号</th>
<th style="text-align:center">名字</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">编号</th>
<th style="text-align:center">名字</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:center">read</td>
<td style="text-align:left">读文件</td>
<td style="text-align:center">33</td>
<td style="text-align:center">pause</td>
<td style="text-align:left">挂起进程直到信号到达</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:center">write</td>
<td style="text-align:left">写文件</td>
<td style="text-align:center">37</td>
<td style="text-align:center">alarm</td>
<td style="text-align:left">调度告警信号的传送</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:center">open</td>
<td style="text-align:left">打开文件</td>
<td style="text-align:center">39</td>
<td style="text-align:center">getpid</td>
<td style="text-align:left">获得进程ID</td>
</tr>
<tr>
<td style="text-align:right">3</td>
<td style="text-align:center">close</td>
<td style="text-align:left">关闭文件</td>
<td style="text-align:center">57</td>
<td style="text-align:center">fork</td>
<td style="text-align:left">创建进程</td>
</tr>
<tr>
<td style="text-align:right">4</td>
<td style="text-align:center">stat</td>
<td style="text-align:left">获得文件信息</td>
<td style="text-align:center">59</td>
<td style="text-align:center">execve</td>
<td style="text-align:left">执行一个程序</td>
</tr>
<tr>
<td style="text-align:right">9</td>
<td style="text-align:center">mmap</td>
<td style="text-align:left">将内存页映射到文件</td>
<td style="text-align:center">60</td>
<td style="text-align:center">_exit</td>
<td style="text-align:left">终止进程</td>
</tr>
<tr>
<td style="text-align:right">12</td>
<td style="text-align:center">brk</td>
<td style="text-align:left">重置堆顶</td>
<td style="text-align:center">61</td>
<td style="text-align:center">wait4</td>
<td style="text-align:left">等待一个进程终止</td>
</tr>
<tr>
<td style="text-align:right">32</td>
<td style="text-align:center">dup2</td>
<td style="text-align:left">复制文件描述符</td>
<td style="text-align:center">62</td>
<td style="text-align:center">kill</td>
<td style="text-align:left">发送信号到一个进程</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>图 8-10 Linux x86-64 系统中常用的系统调用示例</p>
</blockquote>
<p>C 程序用 syscall 函数可以直接调用任何系统调用。然而，实际中几乎没必要这么做。对于大多数系统调用，标准 C 库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。在本书中，我们将系统调用和与它们相关联的包装函数都称为<strong>系统级函数</strong>，这两个术语可以互换地使用。</p>
<p>在 X86-64 系统上，系统调用是通过一条称为 syscall 的陷阱指令来提供的。研究程序能够如何使用这条指令来直接调用 Linux 系统调用是很有趣的。所有到 Linux 系统调用的参数都是通过通用寄存器而不是栈传递的。按照惯例，寄存器 ％rax 包含系统调用号，寄存器 %rdi、%rsi、%rdx、%r10、%r8  和 ％r9 包含最多 6 个参数。第一个参数在  ％rdi 中，第二个在 ％rsi 中，以此类推。从系统调用返回时，寄存器 %rcx 和 ％r11 都会被破坏，％rax 包含返回值。-4095 到 -1 之间的负数返回值表明发生了错误，对应于负的 errno。</p>
<p>例如，考虑大家熟悉的 hello 程序的下面这个版本，用系统级函数 write（见 10.4 节）来写，而不是用 printf：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"hello, world\n"</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>write 函数的第一个参数将输出发送到 stdout。第二个参数是要写的字节序列，而第三个参数是要写的字节数。</p>
<p>图 8-11 给出的是 hello 程序的汇编语言版本，直接使用 syscall 指令来调用 write 和 exit 系统调用。第 9 ∼ 13 行调用 write 函数。首先，第 9 行将系统调用 write 的编号存放在 ％rax 中，第 10 ∼ 12 行设置参数列表。然后第 13 行使用 syscall 指令来调用系统调用。类似地，第 14 ∼ 16 行调用 _exit 系统调用。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>section <span class="token punctuation">.</span>data
string<span class="token operator">:</span>
  <span class="token punctuation">.</span>ascii <span class="token string">"hello, world\n"</span>
string_end<span class="token operator">:</span>
  <span class="token punctuation">.</span>equ len<span class="token punctuation">,</span> string_end <span class="token operator">-</span> string
<span class="token punctuation">.</span>section <span class="token punctuation">.</span>text
<span class="token punctuation">.</span>globl main
main<span class="token operator">:</span>
  <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">First<span class="token punctuation">,</span> call <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> </span><span class="token string">"hello, world\n"</span><span class="token expression"><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span></span></span>
  movq $<span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax                 # write is system call <span class="token number">1</span>
  movq $<span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">%</span>rdi                 # Arg1<span class="token operator">:</span> <span class="token constant">stdout</span> has descriptor <span class="token number">1</span>
  movq $string<span class="token punctuation">,</span> <span class="token operator">%</span>rsi            # Arg2<span class="token operator">:</span> hello world string
  movq $len<span class="token punctuation">,</span> <span class="token operator">%</span>rdx               # Arg3<span class="token operator">:</span> string length
  syscall                       # Make the system call

  <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Next<span class="token punctuation">,</span> call <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></span></span>
  movq $<span class="token number">60</span><span class="token punctuation">,</span> <span class="token operator">%</span>rax                # _exit is system call <span class="token number">60</span>
  movq $<span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">%</span>rdi                 # Arg1<span class="token operator">:</span> exit status is <span class="token number">0</span>
  syscall                       # Make the system call<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>图 8-11 直接用 Linux 系统调用来实现 hello 程序</p>
</blockquote>
<p><strong>旁注 - 关于术语的注释</strong></p>
<p>各种异常类型的术语根据系统的不同而有所不同。处理器 ISA 规范通常会区分异步“中断”和同步“异常”，但是并没有提供描述这些非常相似的概念的概括性的术语。为了避免不断地提到“异常和中断”以及“异常或者中断”，我们用单词“异常”作为通用的术语，而且只有在必要时才区别异步异常（中断）和同步异常（陷阱、故障和终止）。正如我们提到过的，对于每个系统而言，基本的概念都是相同的，但是你应该意识到一些制造厂商的手册会用“异常” 仅仅表示同步事件引起的控制流的改变。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>异常是允许操作系统内核提供<strong>进程</strong>（process）概念的基本构造块，进程是计算机科学中最深刻、最成功的概念之一。</p>
<p>在现代系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。</p>
<p>进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的<strong>上下文</strong>（context）中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>
<p>每次用户通过向 shell 输入一个可执行目标文件的名字，运行程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。</p>
<p>关于操作系统如何实现进程的细节的讨论超出了本书的范围。反之，我们将关注进程提供给应用程序的关键抽象：</p>
<ul>
<li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。</li>
<li>一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。让我们更深入地看看这些抽象。</li>
</ul>
<h2 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h2><p>即使在系统中通常有许多其他程序在运行，像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器（PC）的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个 PC 值的序列叫做<strong>逻辑控制流</strong>，或者简称<strong>逻辑流</strong>。</p>
<p>考虑一个运行着三个进程的系统，如图 8-12 所示。处理器的一个物理控制流被分成了三个逻辑流，每个进程一个。图 8 一每个竖直的条表示一个进程的逻辑流的一部分。在这个例子中，三个逻辑流的执行是交错的。进程 A 运行了一会儿，然后是进程 B 开始运行到完成。然后，进程 C 运行了一会儿，进程 A 接着运行直到完成。最后，进程 C 可以运行到结束了。</p>
<p>图 8-12 的关键点在于进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被<strong>抢占</strong>（preempted）（暂时挂起），然后轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占地使用处理器。唯一的反面例证是，如果我们精确地测量每条指令使用的时间，会发现在程序中一些指令的执行之间，CPU 好像会周期性地停顿。然而，每次处理器停顿，它随后会继续执行我们的程序，并不改变程序内存位置或寄存器的内容。</p>
<p><img src="/images/ComputerSystems/逻辑控制流.png" alt=""></p>
<h2 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h2><p>计算机系统中逻辑流有许多不同的形式。异常处理程序、进程、信号处理程序、线程和 Java 进程都是逻辑流的例子。</p>
<p>一个逻辑流的执行在时间上与另一个流重叠，称为<strong>并发流</strong>（concurrent flow），这两个流被称为<strong>并发地运行</strong>。更准确地说，流 X 和 Y 互相并发，当且仅当 X 在 Y 开始之后和 Y 结束之前开始，或者 Y 在 X 开始之后和 X 结束之前开始。例如，图 8-12 中，进程 A 和 B 并发地运行，A 和 C 也一样。另一方面，B 和 C 没有并发地运行，因为 B 的最后一条指令在 C 的第一条指令之前执行。</p>
<p>多个流并发地执行的一般现象被称为<strong>并发</strong>（concurrency）。一个进程和其他进程轮流运行的概念称为<strong>多任务</strong>（multitasking）o 一个进程执行它的控制流的一部分的每一时间段叫做<strong>时间片</strong>（time slice）。因此，多任务也叫做<strong>时间分片</strong>（timeslicing）。例如，图 8-12 中，进程 A 的流由两个时间片组成。</p>
<p>注意，并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上。不过，有时我们会发现确认并行流是很有帮助的，它是并发流的一个真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为<strong>并行流</strong>（parallel flow），它们<strong>并行地运行</strong>（running in parallel），且<strong>并行地执行</strong>（parallel execution）。</p>
<h2 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h2><p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。在一台 n 位地址的机器上，地址空间是<script type="math/tex">2^n</script>个可能地址的集合，0，1，⋯，<script type="math/tex">\small 2^n -1</script> 。进程为每个程序提供它自己的<strong>私有地址空间</strong>。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。</p>
<p>尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构。比如，图 8-13 展示了一个 x86-64 Linux 进程的地址空间的组织结构。</p>
<p><img src="/images/ComputerSystems/进程地址空间.png" alt=""></p>
<p>地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。代码段总是从地址 0x400000 开始。地址空间顶部保留给内核（操作系统常驻内存的部分）。地址空间的这个部分包含内核在代表进程执行指令时（比如当应用程序执行系统调用时）使用的代码、数据和栈。</p>
<h2 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h2><p>为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。</p>
<p>处理器通常是用某个控制寄存器中的一个<strong>模式位</strong>（mode bit）来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在<strong>内核模式</strong>中（有时叫做<strong>超级用户模式</strong>）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。</p>
<p>没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行<strong>特权指令</strong>（privileged instruction），比如停止处理器、改变模式位，或者发起一个 I/O 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p>
<p>运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。</p>
<p>Linux 提供了一种聪明的机制，叫做 /proc 文件系统，它允许用户模式进程访问内核数据结构的内容。/proc 文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。比如，你可以使用 / proc 文件系统找出一般的系统属性，比如 CPU 类型（/proc/cpuinfo），或者某个特殊的进程使用的内存段（/proc/&lt;process-id&gt;/maps）。2.6 版本的 Linux 内核引入 /sys 文件系统，它输岀关于系统总线和设备的额外的低层信息。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>操作系统内核使用一种称为<strong>上下文切换</strong>（context switch）的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在 8.1 节中已经讨论过的那些较低层异常机制之上的。</p>
<p>内核为每个进程维持一个<strong>上下文</strong>（context）。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。</p>
<p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做<strong>调度</strong>（scheduling），是由内核中称为<strong>调度器</strong>（scheduler）的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换 1）保存当前进程的上下文，2）恢复某个先前被抢占的进程被保存的上下文，3）将控制传递给这个新恢复的进程。</p>
<p>当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果一个 read 系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。另一个示例是 sleep 系统调用，它显式地请求让调用进程休眠。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。</p>
<p>中断也可能引发上下文切换。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每 1 毫秒或每 10 毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。</p>
<p>图 8-14 展示了一对进程 A 和 B 之间上下文切换的示例。在这个例子中，进程 A 初始运行在用户模式中，直到它通过执行系统调用 read 陷入到内核。内核中的陷阱处理程序请求来自磁盘控制器的 DMA 传输，并且安排在磁盘控制器完成从磁盘到内存的数据传输后，磁盘中断处理器。</p>
<p><img src="/images/ComputerSystems/进程上下文切换的剖析.png" alt=""></p>
<p>磁盘取数据要用一段相对较长的时间（数量级为几十毫秒），所以内核执行从进程 A 到进程 B 的上下文切换，而不是在这个间歇时间内等待，什么都不做。注意在切换之前，内核正代表进程 A 在用户模式下执行指令（即没有单独的内核进程）。在切换的第一部分中，内核代表进程 A 在内核模式下执行指令。然后在某一时刻，它开始代表进程 B（仍然是内核模式下）执行指令。在切换之后，内核代表进程 B 在用户模式下执行指令。</p>
<p>随后，进程 B 在用户模式下运行一会儿，直到磁盘发出一个中断信号，表示数据已经从磁盘传送到了内存。内核判定进程 B 已经运行了足够长的时间，就执行一个从进程 B 到进程 A 的上下文切换，将控制返回给进程 A 中紧随在系统调用 read 之后的那条指令。进程 A 继续运行，直到下一次异常发生，依此类推。</p>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>到目前为止对异常控制流的学习中，我们已经看到了硬件和软件是如何合作以提供基本的低层异常机制的。我们也看到了操作系统如何利用异常来支持进程上下文切换的异常控制流形式。在本节中，我们将研究一种更高层的软件形式的异常，称为 <strong>Linux 信号</strong>，它允许进程和内核中断其他进程。</p>
<p>一个<strong>信号</strong>就是一条小消息，它通知进程系统中发生了一个某种类型的事件。比如，图 8-26 展示了 Linux 系统上支持的 30 种不同类型的信号。</p>
<p>每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。比如，如果一个进程试图除以 0，那么内核就发送给它一个 SIGFPE 信号（号码 8）。如果一个进程执行一条非法指令，那么内核就发送给它一个 SIGILL 信号（号码 4）。如果进程进行非法内存引用，内核就发送给它一个 SIGSEGV 信号（号码 11）。其他信号对应于内核或者其他用户进程中较高层的软件事件。比如，如果当进程在前台运行时，你键入 Ctrl+C（也就是同时按下 Ctrl 键和 C 键），那么内核就会发送一个 SIGINT 信号（号码 2）给这个前台进程组中的每个进程。一个进程可以通过向另一个进程发送一个 SIGKILL 信号（号码 9）强制终止它。当一个子进程终止或者停止时，内核会发送一个 SIGCHLD 信号（号码 17）给父进程。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">默认行为</th>
<th style="text-align:left">相应事件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">SIGHUP</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">终端线挂断</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">SIGINT</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">来自键盘的中断</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">SIGQUIT</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">来自键盘的退出</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">SIGILL</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">非法指令</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">SIGTRAP</td>
<td style="text-align:left">终止并转储内存</td>
<td style="text-align:left">跟踪陷阱</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">SIGABRT</td>
<td style="text-align:left">终止并转储内存</td>
<td style="text-align:left">来自 abort 函数的终止信号</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">SIGBUS</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">总线错误</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">SIGFPE</td>
<td style="text-align:left">终止并转储内存</td>
<td style="text-align:left">浮点异常</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">SIGKILL</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">杀死程序</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">SIGUSR1</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">用户定义的信号 1</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">SIGSEGV</td>
<td style="text-align:left">终止并转储内存</td>
<td style="text-align:left">无效的内存引用（段故障）</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">SIGUSR2</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">用户定义的信号 2</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">SIGPIPE</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">向一个没有读用户的管道做写操作</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left">SIGALRM</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">来自 alarm 函数的定时器信号</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left">SIGTERM</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">软件终止信号</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left">SIGSTKFLT</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">协处理器上的栈故障</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left">SIGCHLD</td>
<td style="text-align:left">忽略</td>
<td style="text-align:left">一个子进程停止或者终止</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left">SIGCONT</td>
<td style="text-align:left">忽略</td>
<td style="text-align:left">继续进程如果该进程停止</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left">SIGSTOP</td>
<td style="text-align:left">停止直到下一个SIGCONT</td>
<td style="text-align:left">不是来自终端的停止信号</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left">SIGTSTP</td>
<td style="text-align:left">停止直到下一个SIGCONT</td>
<td style="text-align:left">来自终端的停止信号</td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left">SIGTTIN</td>
<td style="text-align:left">停止直到下一个SIGCONT</td>
<td style="text-align:left">后台进程从终端读</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left">SIGTTOU</td>
<td style="text-align:left">停止直到下一个SIGCONT</td>
<td style="text-align:left">后台进程向终端写</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left">SIGURG</td>
<td style="text-align:left">忽略</td>
<td style="text-align:left">套接字上的紧急情况</td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td style="text-align:left">SIGXCPU</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">CPU 时间限制超出</td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left">SIGXFSZ</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">文件大小限制超出</td>
</tr>
<tr>
<td style="text-align:left">26</td>
<td style="text-align:left">SIGVTALRM</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">虚拟定时器期满</td>
</tr>
<tr>
<td style="text-align:left">27</td>
<td style="text-align:left">SIGPROF</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">剖析定时器期满</td>
</tr>
<tr>
<td style="text-align:left">28</td>
<td style="text-align:left">SIGWINCH</td>
<td style="text-align:left">忽略</td>
<td style="text-align:left">窗口大小变化</td>
</tr>
<tr>
<td style="text-align:left">29</td>
<td style="text-align:left">SIGIO</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">在某个描述符上可执行 I/O 操作</td>
</tr>
<tr>
<td style="text-align:left">30</td>
<td style="text-align:left">SIGPWR</td>
<td style="text-align:left">终止</td>
<td style="text-align:left">电源故障</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>图 8-26 Linux 信号</p>
</blockquote>
<ul>
<li>① 多年前，主存是用一种称为磁芯存储器（core memory）的技术来实现的。“转储内存”（dumping core）是一个历史术语，意思是把代码和数据内存段的映像写到磁盘上。</li>
<li>② 这个信号既不能被捕获，也不能被忽略。</li>
</ul>
<h2 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h2><p>传送一个信号到目的进程是由两个不同步骤组成的：</p>
<ul>
<li><p><strong>发送信号。</strong>内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：</p>
<ul>
<li>1）内核检测到一个系统事件，比如除零错误或者子进程终止。</li>
<li><p>2）一个进程调用了 kill 函数（在下一节中讨论），显式地要求内核发送一个信号给目的进程。</p>
<p>一个进程可以发送信号给它自己。</p>
</li>
</ul>
</li>
<li><p><strong>接收信号。</strong>当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为<strong>信号处理程序</strong>（signal handler）的用户层函数捕获这个信号。图 8-27 给出了信号处理程序捕获信号的基本思想。</p>
</li>
</ul>
<p><img src="/images/ComputerSystems/信号处理.png" alt=""></p>
<p>一个发出而没有被接收的信号叫做<strong>待处理信号</strong>（pending signal）。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为上的待处理信号，那么任何接下来发送到这个进程的类型为左的信号都不会排队等待；它们只是被简单地丢弃。一个进程可以有选择性地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p>
<p>一个待处理信号最多只能被接收一次。内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在 blocked 位向量中维护着被阻塞的信号集合。只要传送了一个类型为 k 的信号，内核就会设置 pending 中的第 k 位，而只要接收了一个类型为 k 的信号，内核就会清除 pending 中的第 k 位。</p>
<blockquote>
<p>  blocked 位向量：也称为信号掩码（signal mask）。</p>
</blockquote>
<h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组（process group）这个概念的。</p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。默认地，一个子进程和它的父进程同属于一个进程组。</p>
<h3 id="用-bin-kill-程序发送信号"><a href="#用-bin-kill-程序发送信号" class="headerlink" title="用 /bin/kill 程序发送信号"></a>用 /bin/kill 程序发送信号</h3><p>/bin/kill 程序可以向另外的进程发送任意的信号。比如，命令</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">linux<span class="token operator">></span> <span class="token operator">/</span>bin<span class="token operator">/</span>kill <span class="token operator">-</span><span class="token number">9</span> <span class="token number">15213</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>发送信号 9（SIGKILL）给进程 15213。一个为负的 PID 会导致信号被发送到进程组 PID 中的每个进程。比如，命令</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">linux<span class="token operator">></span> <span class="token operator">/</span>bin<span class="token operator">/</span>kill <span class="token operator">-</span><span class="token number">9</span> <span class="token operator">-</span><span class="token number">15213</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>发送一个 SIGKILL 信号给进程组 15213 中的每个进程。注意，在此我们使用完整路径 /bin/kill，因为有些 Unix shell 有自己内置的 kill 命令。</p>
<h2 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h2><p>当内核把进程 p 从内核模式切换到用户模式时（例如，从系统调用返回或是完成了一次上下文切换），它会检查进程 p 的未被阻塞的待处理信号的集合（pending &amp;~blocked）。如果这个集合为空（通常情况下），那么内核将控制传递到 p 的逻辑控制流中的下一条指令（<script type="math/tex">\small I_{next}</script>）。然而，如果集合是非空的，那么内核选择集合中的某个信号 k （通常是最小的 k），并且强制 p 接收信号 k。收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回 p 的逻辑控制流中的下一条指令（<script type="math/tex">\small I_{next}</script>）。每个信号类型都有一个预定义的<strong>默认行为</strong>，是下面中的一种：</p>
<ul>
<li>进程终止。</li>
<li>进程终止并转储内存。</li>
<li>进程停止（挂起）直到被 SIGCONT 信号重启。</li>
<li>进程忽略该信号。</li>
</ul>
<p>下面展示了与每个信号类型相关联的默认行为。比如，收到 SIGKILL 的默认行为就是终止接收进程。另外，接收到 SIGCHLD 的默认行为就是忽略这个信号。进程可以通过使用 signal 函数修改和信号相关联的默认行为。唯一的例外是 SIGSTOP 和 SIGKILL，它们的默认行为是不能修改的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">sighandler_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">sighandler_t</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token class-name">sighandler_t</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回：若成功则为指向前次处理程序的指针，若出错则为 SIG_ERR（不设置 errno）。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>signal 函数可以通过下列三种方法之一来改变和信号 signum 相关联的行为：</p>
<ul>
<li>如果 handler 是 SIG_IGN，那么忽略类型为 signum 的信号。</li>
<li>如果 handler 是 SIG_DFL，那么类型为 signum 的信号行为恢复为默认行为。</li>
<li>否则，handler 就是用户定义的函数的地址，这个函数被称为<strong>信号处理程序</strong>，只要进程接收到一个类型为 signum 的信号，就会调用这个程序。通过把处理程序的地址传递到 signal 函数从而改变默认行为，这叫做<strong>设置信号处理程序</strong>（installing the handler）。调用信号处理程序被称为<strong>捕获信号</strong>。执行信号处理程序被称为<strong>处理信号</strong>。</li>
</ul>
<p>当一个进程捕获了一个类型为 k 的信号时，会调用为信号 k 设置的处理程序，一个整数参数被设置为 k。这个参数允许同一个处理函数捕获不同类型的信号。</p>
<p>当处理程序执行它的 return 语句时，控制（通常）传递回控制流中进程被信号接收中断位置处的指令。我们说“通常”是因为在某些系统中，被中断的系统调用会立即返回一个错误。</p>
<p><img src="/images/ComputerSystems/信号处理程序可以被其他信号处理程序中断.png" alt=""></p>
<h2 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h2><p>Linux 提供阻塞信号的隐式和显式的机制：</p>
<ul>
<li><strong>隐式阻塞机制。</strong>内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。例如，图 8-31 中，假设程序捕获了信号 s，当前正在运行处理程序 S。如果发送给该进程另一个信号 s，那么直到处理程序 S 返回，s 会变成待处理而没有被接收。</li>
<li><strong>显式阻塞机制。</strong>应用程序可以使用 sigprocmask 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span>
<span class="token keyword">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token class-name">sigset_t</span> <span class="token operator">*</span>oldset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sigdelset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//返回；如果成功则为 0，若出错则为 -1。int sigismember(const sigset_t *set, int signum);</span>
<span class="token comment">// 返回：若 signum 是 set 的成员则为 1，如果不是则为 0，若出错则为 -1。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>sigprocmask 函数改变当前阻塞的信号集合（8.5.1 节中描述的 blocked 位向量）。具体的行为依赖于 how 的值：</p>
<ul>
<li>SIG_BLOCK：把 set 中的信号添加到 blocked 中（<strong>blocked=blocked | set</strong>）。</li>
<li>SIG_UNBLOCK：从 blocked 中删除 set 中的信号（<strong>blocked=blocked &amp;~set</strong>）。</li>
<li>SIG_SETMASK：<strong>block=set</strong>。</li>
</ul>
<p>如果 oldset 非空，那么 blocked 位向量之前的值保存在 oldset 中。</p>
<p>使用下述函数对 set 信号集合进行操作：sigemptyset 初始化 set 为空集合。sigfillset 函数把每个信号都添加到 set 中。sigaddset 函数把 signum 添加到 set，sigdelset 从 set 中删除 signum，如果 signum 是 set 的成员，那么 sigismember 返回 1，否则返回 0。</p>
<h1 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h1><p>C 语言提供了一种用户级异常控制流形式，称为非本地跳转（non local jump），它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用—返回序列。非本地跳转是通过 setjmp 和 longjmp 函数来提供的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;setjmp.h></span></span>
<span class="token keyword">int</span> <span class="token function">setjmp</span><span class="token punctuation">(</span>jmp_buf env<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sigsetjmp</span><span class="token punctuation">(</span>sigjmp_buf env<span class="token punctuation">,</span> <span class="token keyword">int</span> savesigs<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 返回：setjmp 返回 0，longjmp 返回非零。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>setjmp 函数在 env 缓冲区中保存当前调用环境，以供后面的 longjmp 使用，并返回 0o 调用环境包括程序计数器、栈指针和通用目的寄存器。岀于某种超出本书描述范围的原因，setjmp 返回的值不能被赋值给变量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">rc <span class="token operator">=</span> <span class="token function">setjmp</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* Wrong! */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>不过它可以安全地用在 switch 或条件语句的测试中【62】。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;setjmp.h></span></span>

<span class="token keyword">void</span> <span class="token function">longjmp</span><span class="token punctuation">(</span>jmp_buf env<span class="token punctuation">,</span> <span class="token keyword">int</span> retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">siglongjmp</span><span class="token punctuation">(</span>sigjmp_buf env<span class="token punctuation">,</span> <span class="token keyword">int</span> retval<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 从不返回。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>longjmp 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化 env 的 setjmp 调用的返回。然后 setjmp 返回，并带有非零的返回值 retval。</p>
<p>第一眼看过去，setjmp 和 longjmp 之间的相互关系令人迷惑。setjmp 函数只被调用一次，但返回多次：一次是当第一次调用 setjmp，而调用环境保存在缓冲区 env 中时，一次是为每个相应的 longjmp 调用。另一方面，longjmp 函数被调用一次，但从不返回。</p>
<p>非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误情况，我们可以使用非本地跳转直接返回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。</p>
<p><strong>旁注 - C++ 和 Java 中的软件异常</strong></p>
<p>C++ 和 Java 提供的异常机制是较高层次的，是 C 语言的 setjmp 和 longjmp 函数的更加结构化的版本。你可以把 try 语句中的 catch 子句看做类似于 setjmp 函数。相似地，throw 语句就类似于 longjmp 函数。</p>
<h1 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h1><p>Linux 系统提供了大量的监控和操作进程的有用工具。</p>
<ul>
<li><strong>STRACE：</strong>打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用 -static 编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。</li>
<li><strong>PS：</strong>列出当前系统中的进程（包括僵死进程）。</li>
<li><strong>TOP：</strong>打印出关于当前进程资源使用的信息。</li>
<li><strong>PMAP：</strong>显示进程的内存映射。</li>
<li><strong>/proc：</strong>一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入 “cat/proc/loadavg”，可以看到你的 Linux 系统上当前的平均负载。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Computer-Systems/" rel="tag"># Computer Systems</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-7-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-%E9%93%BE%E6%8E%A5/" rel="prev" title="CS 链接">
      <i class="fa fa-chevron-left"></i> CS 链接
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-9-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" rel="next" title="CS 虚拟内存">
      CS 虚拟内存 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">1.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">异常的类别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">1.2.1.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%B7%E9%98%B1%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">陷阱和系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%85%E9%9A%9C"><span class="nav-number">1.2.3.</span> <span class="nav-text">故障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BB%88%E6%AD%A2"><span class="nav-number">1.2.4.</span> <span class="nav-text">4. 终止</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-x86-64-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-number">1.3.</span> <span class="nav-text">Linux&#x2F;x86-64 系统中的异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-x86-64-%E6%95%85%E9%9A%9C%E5%92%8C%E7%BB%88%E6%AD%A2"><span class="nav-number">1.3.1.</span> <span class="nav-text">Linux&#x2F;x86-64 故障和终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-86-64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.3.2.</span> <span class="nav-text">Linux&#x2F;86-64 系统调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">2.1.</span> <span class="nav-text">逻辑控制流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%B5%81"><span class="nav-number">2.2.</span> <span class="nav-text">并发流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">2.3.</span> <span class="nav-text">私有地址空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text">用户模式和内核模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">2.5.</span> <span class="nav-text">上下文切换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">3.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%9C%AF%E8%AF%AD"><span class="nav-number">3.1.</span> <span class="nav-text">信号术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="nav-number">3.2.</span> <span class="nav-text">发送信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="nav-number">3.2.1.</span> <span class="nav-text">进程组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8-bin-kill-%E7%A8%8B%E5%BA%8F%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="nav-number">3.2.2.</span> <span class="nav-text">用 &#x2F;bin&#x2F;kill 程序发送信号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E4%BF%A1%E5%8F%B7"><span class="nav-number">3.3.</span> <span class="nav-text">接收信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E8%A7%A3%E9%99%A4%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7"><span class="nav-number">3.4.</span> <span class="nav-text">阻塞和解除阻塞信号</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B7%B3%E8%BD%AC"><span class="nav-number">4.</span> <span class="nav-text">非本地跳转</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-number">5.</span> <span class="nav-text">操作进程的工具</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang Zihao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">269</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Zihao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
