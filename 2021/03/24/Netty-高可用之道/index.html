<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="作为一个基础的 NIO 通信框架，Netty 被广泛应用于大数据处理、互联网消息中间件、游戏和金融行业等。不同的行业对软件的可靠性需求不同，例如对通信软件的可靠性要求往往需要达到 5 个 9。">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty 高可用之道">
<meta property="og:url" content="http://example.com/2021/03/24/Netty-%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E9%81%93/index.html">
<meta property="og:site_name" content="Lanchester Blog">
<meta property="og:description" content="作为一个基础的 NIO 通信框架，Netty 被广泛应用于大数据处理、互联网消息中间件、游戏和金融行业等。不同的行业对软件的可靠性需求不同，例如对通信软件的可靠性要求往往需要达到 5 个 9。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/Netty/心跳检测流程.png">
<meta property="og:image" content="http://example.com/images/Netty/流量整形的原理示意图.png">
<meta property="article:published_time" content="2021-03-24T08:40:00.000Z">
<meta property="article:modified_time" content="2023-08-01T02:17:20.503Z">
<meta property="article:author" content="Wang Zihao">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="流量整形">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Netty/心跳检测流程.png">

<link rel="canonical" href="http://example.com/2021/03/24/Netty-%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E9%81%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Netty 高可用之道 | Lanchester Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lanchester Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Leave a leaf</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/24/Netty-%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E9%81%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Zihao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lanchester Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Netty 高可用之道
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-24 16:40:00" itemprop="dateCreated datePublished" datetime="2021-03-24T16:40:00+08:00">2021-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-01 10:17:20" itemprop="dateModified" datetime="2023-08-01T10:17:20+08:00">2023-08-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>作为一个基础的 NIO 通信框架，Netty 被广泛应用于大数据处理、互联网消息中间件、游戏和金融行业等。不同的行业对软件的可靠性需求不同，例如对通信软件的可靠性要求往往需要达到 5 个 9。</p>
<span id="more"></span>
<h1 id="可靠性需求"><a href="#可靠性需求" class="headerlink" title="可靠性需求"></a>可靠性需求</h1><h2 id="Netty主要应用场景"><a href="#Netty主要应用场景" class="headerlink" title="Netty主要应用场景"></a>Netty主要应用场景</h2><ol>
<li><p>RPC框架的基础网络通信框架</p>
<p> 主要用于分布式节点之间的通信和数据交换，在各个业务领域均有典型的应用，例如阿里的分布式服务框架 Dubbo、消息队列 RocketMQ、大数据处理 Hadoop 的基础通信和序列化框架 Avro</p>
</li>
<li><p>私有协议的基础通信框架：例如 Thrift 协议、Dubbo 协议等</p>
</li>
<li><p>公有协议的基础通信框架：例如 HTTP 协议、SMPP 协议等。</p>
</li>
</ol>
<h2 id="Netty的运行环境"><a href="#Netty的运行环境" class="headerlink" title="Netty的运行环境"></a>Netty的运行环境</h2><ol>
<li>手游服务运行的 GSM/3G/WIFI 网络环境可靠性差，偶尔会出现闪断、网络单通等问题。</li>
<li>互联网应用在业务高峰期会出现网络拥堵，而且各地用户的网络环境差别也很大，部分地区网速和网络质量不高。</li>
</ol>
<h2 id="Netty故障的后果"><a href="#Netty故障的后果" class="headerlink" title="Netty故障的后果"></a>Netty故障的后果</h2><p>Netty 是基础的通信框架，一旦出现 Bug，轻则需要重启应用，重则可能导致整个业务中断。它的可靠性会影响整个业务集群的数据通信和交换，在当今以分布式为主的软件架构体系中，通信中断就意味着整个业务中断，分布式架构下对通信的可靠性要求非常高。</p>
<h1 id="可靠性设计"><a href="#可靠性设计" class="headerlink" title="可靠性设计"></a>可靠性设计</h1><h2 id="网络通信类故障"><a href="#网络通信类故障" class="headerlink" title="网络通信类故障"></a>网络通信类故障</h2><h3 id="客户端连接超时"><a href="#客户端连接超时" class="headerlink" title="客户端连接超时"></a>客户端连接超时</h3><p>在 BIO 编程模式下，客户端 Socket 发起网络连接，需要指定连接超时时间，主要目的是：</p>
<ol>
<li>避免客户端 IO 线程被长时间阻塞，这会导致系统可用IO线程数的减少</li>
<li>业务层需要：大多数系统都会对业务流程执行时间有限制。客户端设置连接超时时间是为了实现业务层的超时。</li>
</ol>
<p>对于 BIO 的 Socket 来说，调用 connect 方法将被阻塞，直到连接成功或者发生连接超时等异常。</p>
<p>对于 NIO 的 SocketChannel 来说，在非阻塞模式下，它会直接返回连接结果。如果没有连接成功，也没有发生 IO 异常，则需要将 SocketChannel 注册到 Selector 上监听连接结果。所以，异步连接的超时无法在 API 层面直接设置，而是需要通过定时器来主动监测。</p>
<blockquote>
<p>在 《Netty Channel和Unsafe》文章 AbstractNioUnsafe 源码分析 章节中对连接过程的超时有详细过程介绍</p>
</blockquote>
<p>这样的超时设计既满足了用户的个性化需求，又实现了故障的分层隔离，即上层用户不用关心底层的超时实现机制。</p>
<h3 id="通信对端强制关闭连接"><a href="#通信对端强制关闭连接" class="headerlink" title="通信对端强制关闭连接"></a>通信对端强制关闭连接</h3><p>在客户端和服务端正常通信过程中，如果发生网络闪断、对方进程突然宕机或者其他非正常关闭链路事件时，TCP 链路就会发生异常。由于 TCP 是全双工的，通信双方都需要关闭和释放 Socket 句柄才不会发生句柄的泄漏。</p>
<p>在实际的 NIO 编程过程中，我们经常会发现由于句柄没有被及时关闭导致的功能和可靠性问题。究其原因总结如下：</p>
<ol>
<li>IO 的读写等操作并非仅仅集中在 Reactor 线程内部，用户上层的一些定制行为可能会导致 IO 操作的外逸，例如业务自定义心跳机制。这些定制行为加大了统一异常处理的难度，IO 操作越发散，故障发生的概率就越大</li>
<li>一些异常分支没有考虑到，由于外部环境诱因导致程序进入这些分支，就会引起故障</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ByteBuf</span> <span class="token function">writeBytes</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> src<span class="token punctuation">,</span> <span class="token keyword">int</span> srcIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">ensureWritable</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setBytes</span><span class="token punctuation">(</span>writerIndex<span class="token punctuation">,</span> src<span class="token punctuation">,</span> srcIndex<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    writerIndex <span class="token operator">+=</span> length<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在调用 Socketchannel的read方法时发生了 IOException，从 Channel中读取数据报道缓冲区中的代码如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Transfers the specified source array's data to this buffer starting at
 * the specified absolute &#123;@code index&#125;.
 * This method does not modify &#123;@code readerIndex&#125; or &#123;@code writerIndex&#125; of
 * this buffer.
 *
 * @throws IndexOutOfBoundsException
 *         if the specified &#123;@code index&#125; is less than &#123;@code 0&#125;,
 *         if the specified &#123;@code srcIndex&#125; is less than &#123;@code 0&#125;,
 *         if &#123;@code index + length&#125; is greater than
 *            &#123;@code this.capacity&#125;, or
 *         if &#123;@code srcIndex + length&#125; is greater than &#123;@code src.length&#125;
 */</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">ByteBuf</span> <span class="token function">setBytes</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> src<span class="token punctuation">,</span> <span class="token keyword">int</span> srcIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了保证 IO 异常被统一处理，该异常应该向上抛，由 NioByteUnsafe 进行统一异常处理</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">closeOnRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelPipeline</span> pipeline<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">SelectionKey</span> key <span class="token operator">=</span> <span class="token function">selectionKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setInputShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Boolean</span><span class="token punctuation">.</span>TRUE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOption</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span>ALLOW_HALF_CLOSURE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            key<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span>readInterestOp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pipeline<span class="token punctuation">.</span><span class="token function">fireUserEventTriggered</span><span class="token punctuation">(</span><span class="token class-name">ChannelInputShutdownEvent</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token function">close</span><span class="token punctuation">(</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="链路关闭"><a href="#链路关闭" class="headerlink" title="链路关闭"></a>链路关闭</h3><p>对于短连接协议，例如 HTTP 协议，通信双方数据交互完成之后，通常按照双方的约定由服务端关闭连接，客户端获得 TCP 连接关闭请求之后，关闭自身的 Socket 连接，双方正式断开连接。</p>
<p>在实际的 NIO 编程过程中，经常存在一种误区：认为只要是对方关闭连接，就会发生 IO 异常，捕获 IO 异常之后再关闭连接即可。实际上，连接的合法关闭不会发生 IO 异常，它是一种正常场景，如果遗漏了该场景的判断和处理就会导致连接句柄泄漏。</p>
<h3 id="定制IO故障"><a href="#定制IO故障" class="headerlink" title="定制IO故障"></a>定制IO故障</h3><p>在大多数场景下，当底层网络发生故障的时候，应该由底层的 NIO 框架负责释放资源，处理异常等。上层的业务应用不需要关心底层的处理细节。但是，在一些特殊的场景下，用户可能需要感知这些异常，并针对这些异常进行定制处理，例如：</p>
<ol>
<li>客户端的断连重连机制</li>
<li>消息的缓存重发</li>
<li>接口日志中详细记录故障细节</li>
<li>运维相关功能，例如告警、触发邮件/短信等</li>
</ol>
<p>Netty 的处理策略是发生 IO 异常，底层的资源由它负责释放，同时将异常堆栈信息以事件的形式通知给上层用户，由用户对异常进行定制。这种处理机制既保证了异常处理的安全性，也向上层提供了灵活的定制能力。</p>
<p>具体接口定义以及默认实现（ChannelHandlerAdapter）如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Calls &#123;@link ChannelHandlerContext#fireExceptionCaught(Throwable)&#125; to forward
 * to the next &#123;@link ChannelHandler&#125; in the &#123;@link ChannelPipeline&#125;.
 *
 * Sub-classes may override this method to change behavior.
 *
 * @deprecated is part of &#123;@link ChannelInboundHandler&#125;
 */</span>
<span class="token annotation punctuation">@Skip</span>
<span class="token annotation punctuation">@Override</span>
<span class="token annotation punctuation">@Deprecated</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
    ctx<span class="token punctuation">.</span><span class="token function">fireExceptionCaught</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="链路的有效性检测"><a href="#链路的有效性检测" class="headerlink" title="链路的有效性检测"></a>链路的有效性检测</h2><p>当网络发生单通、连接被防火墙 Hang 住、长时间 GC 或者通信线程发生非预期异常时，会导致链路不可用且不易被及时发现。特别是异常发生在凌晨业务低谷期间，当早晨业务高峰期到来时，由于链路不可用会导致瞬间的大批量业务失败或者超时，这将对系统的可靠性产生重大的威胁。</p>
<p>从技术层面看，要解决链路的可靠性问题，必须周期性的对链路进行有效性检测。目前最流行和通用的做法就是心跳检测。</p>
<p>心跳检测机制分为三个层面：</p>
<ol>
<li>TCP 层面的心跳检测，即 TCP 的 Keep-Alive 机制，它的作用域是整个 TCP 协议栈</li>
<li>协议层的心跳检测，主要存在于长连接协议中。例如 SMPP 协议</li>
<li>应用层的心跳检测，它主要由各业务产品通过约定方式定时给对方发送心跳消息实现</li>
</ol>
<p>心跳检测的目的就是确认当前链路可用，对方活着并且能够正常接收和发送消息。做为高可靠的 NIO 框架，Netty 也提供了心跳检测机制</p>
<p><img src="/images/Netty/心跳检测流程.png" alt=""></p>
<p>不同的协议，心跳检测机制也存在差异，归纳起来主要分为两类</p>
<ol>
<li>Ping-Pong 型心跳：由通信一方定时发送 Ping 消息，对方接收到 Ping 消息之后，立即返回 Pong 应答消息给对方，属于请求-响应型心跳。</li>
<li>Ping-Ping 型心跳：不区分心跳请求和应答，由通信双方按照约定定时向对方发送心跳 Ping 消息，它属于双向心跳。</li>
</ol>
<p>心跳检测策略如下</p>
<ol>
<li>连续 N 次心跳检测都没有收到对方的 Pong 应答消息或者 Ping 请求消息，则认为链路已经发生逻辑失效，这被称作心跳超时。</li>
<li>读取和发送心跳消息的时候如何直接发生了 IO 异常，说明链路已经失效，这被称为心跳失败。</li>
</ol>
<p>无论发生心跳超时还是心跳失败，都需要关闭链路，由客户端发起重连操作，保证链路能够恢复正常。</p>
<p>Netty 的心跳检测实际上是利用了链路空闲检测机制实现的，而 Netty 对该机制实现了三种方式：<code>WriteTimeoutHandler</code>、<code>ReadTimeoutHandler</code>、<code>IdleStateHandler</code></p>
<pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;WriteTimeoutHandler 写超时接口
protected void writeTimedOut(ChannelHandlerContext ctx) throws Exception &#123;
     if (!closed) &#123;
         ctx.fireExceptionCaught(WriteTimeoutException.INSTANCE);
         ctx.close();
         closed &#x3D; true;
     &#125;
 &#125;
&#x2F;&#x2F;ReadTimeoutHandler 读超时接口
protected void readTimedOut(ChannelHandlerContext ctx) throws Exception &#123;
    if (!closed) &#123;
        ctx.fireExceptionCaught(ReadTimeoutException.INSTANCE);
        ctx.close();
        closed &#x3D; true;
    &#125;
&#125;
&#x2F;&#x2F;IdleStateHandler 链路空闲超时接口
&#x2F;&#x2F;链路空闲的时候并没有关闭链路，而是触发IdleStateEvent事件，用户订阅IdleStateEvent事件，
&#x2F;&#x2F;用于自定义逻辑处理，例如关闭链路、客户端发起重新连接、告警和打印日志等。
protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception &#123;
    ctx.fireUserEventTriggered(evt);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>利用 Netty 提供的链路空闲检测机制，可以非常灵活的实现协议层的心跳检测</p>
<h2 id="Reactor线程的保护"><a href="#Reactor线程的保护" class="headerlink" title="Reactor线程的保护"></a>Reactor线程的保护</h2><p>Reactor 线程作为 IO 操作的核心，一旦出现故障则导致挂在其上面的多路复用器和多个链路无法正常工作。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>尽管 Reactor 线程主要处理 IO 操作，发生的异常通常是 lO 异常，但是，实际上在些特殊场景下会发生非 IO 异常，如果仅仅捕获 IO 异常可能就会导致 Reactor 线程跑飞为了防止发生这种意外，在循环体内一定要捕获 Throwable，而不是 IO 异常或者 Exception</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//NioEventLoop </span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        oldWakenUp <span class="token operator">=</span> wakenUp<span class="token punctuation">.</span><span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// Select操作...</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// Ignore.</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>捕获 Throwable 之后，即便发生了意外未知对异常，线程也不会跑飞，它休眠1S，防止死循环导致的异常绕接，然后继续恢复执行。</p>
<p>这样处理的核心理念就是：</p>
<ol>
<li>某个消息的异常不应该导致整条链路不可用</li>
<li>某条链路不可用不应该导致其他链路不可用</li>
<li>某个进程不可用不应该导致其他集群节点不可用</li>
</ol>
<h3 id="规避-NIO-Bug"><a href="#规避-NIO-Bug" class="headerlink" title="规避 NIO Bug"></a>规避 NIO Bug</h3><p>通常情况下，死循环是可检测、可预防但是无法完全避免的。Reactor 线程通常处理的都是 IO 相关的操作，因此我们重点关注 IO 层面的死循环。</p>
<p>JDK NIO 类库最著名的就是 epoll bug 了，它会导致 Selector 空轮询，IO 线程 CPU 100%，严重影响系统的安全性和可靠性。</p>
<p>Netty 的解决策略：</p>
<ol>
<li>根据该 BUG 的特征，首先侦测该 BUG 是否发生</li>
<li>将问题 Selector 上注册的 Channel 转移到新建的 Selector 上</li>
<li>老的问题 Selector 关闭，使用新建的 Selector 替换。</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//NioEventLoop select</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Selector</span> selector <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> selectedKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span>timeoutMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>
            selectCnt <span class="token operator">++</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>SELECTOR_AUTO_REBUILD_THRESHOLD <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
                    selectCnt <span class="token operator">>=</span> SELECTOR_AUTO_REBUILD_THRESHOLD<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
             
                <span class="token function">rebuildSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                selector <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selector<span class="token punctuation">;</span>

                <span class="token comment">// Select again to populate selectedKeys.</span>
                selector<span class="token punctuation">.</span><span class="token function">selectNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancelledKeyException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h2><p>NIO 通信的内存保护主要集中在如下几点：</p>
<ol>
<li>链路总数的控制：每条链路都包含接收和发送缓冲区，链路个数太多容易导致内存溢出</li>
<li>单个缓冲区的上限控制：防止非法长度或者消息过大导致内存溢出</li>
<li>缓冲区内存释放：防止因为缓冲区使用不当导致的内存泄露</li>
<li>NIO消息发送队列的长度上限控制</li>
</ol>
<p><strong>缓冲区的内存泄漏保护</strong></p>
<p>为了提升内存的利用率，Netty 提供了内存池和对象池。但是，基于缓存池实现以后需要对内存的申请和释放进行严格的管理，否则很容易导致内存泄漏。</p>
<p>如果不采用内存池技术实现，每次对象都是以方法的局部变量形式被创建，使用完成之后，只要不再继续引用它，JVM 会自动释放。但是，一旦引入内存池机制，对象的生命周期将由内存池负责管理，这通常是个全局引用，如果不显式释放 JVM 是不会回收这部分内存的。</p>
<p>对于 Netty 的用户而言，使用者的技术水平差异很大，一些对 JVM 内存模型和内存泄漏机制不了解的用户，可能只记得申请内存，忘记主动释放内存，特别是 JAVA 程序员为了防止因为用户遗漏导致内存泄漏，Netty 在 Pipeline 的尾 Handler 中自动对内存进行释放。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//TailHandler</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span>
                <span class="token string">"Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. "</span> <span class="token operator">+</span>
                        <span class="token string">"Please check your pipeline configuration."</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ReferenceCountUtil</span><span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//ReferenceCountUtil</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">ReferenceCounted</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ReferenceCounted</span><span class="token punctuation">)</span> msg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//PooledByteBuf extends AbstractReferenceCountedByteBuf 释放内存</span>
<span class="token comment">//对于实现了AbstractReferenceCountedByteBuf的ByteBuf，内存申请、使用和释放的时候</span>
<span class="token comment">//Netty都会自动进行引用计数检测，防止非法使用内存</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">deallocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handle <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">final</span> <span class="token keyword">long</span> handle <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handle<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>handle <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        memory <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        chunk<span class="token punctuation">.</span>arena<span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>chunk<span class="token punctuation">,</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="缓冲区溢出保护"><a href="#缓冲区溢出保护" class="headerlink" title="缓冲区溢出保护"></a>缓冲区溢出保护</h2><p>做过协议栈的读者都知道，当我们对消息进行解码的时候，需要创建缓冲区。缓冲区的创建方式通常有两种：</p>
<ol>
<li>容量预分配，在实际读写过程中如果不够再扩展</li>
<li>根据协议消息长度创建缓冲区</li>
</ol>
<p>在实际的商用环境中，如果遇到畸形码流攻击、协议消息编码异常、消息丢包等问题时，可能会解析到一个超长的长度字段。笔者曾经遇到过类似问题，报文长度字段值竟然是 2G 多，由于代码的一个分支没有对长度上限做有效保护，结果导致内存溢出。系统重启后几秒内再次内存溢出，幸好及时定位出问题根因，险些酿成严重的事故。</p>
<p>Netty 提供了编解码框架，因此对于解码缓冲区的上限保护就显得非常重要。下面，我们看下 Netty 是如何对缓冲区进行上限保护的：</p>
<p>首先，在内存分配的时候指定缓冲区长度上限：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Allocate a &#123;@link ByteBuf&#125; with the given initial capacity and the given
 * maximal capacity. If it is a direct or heap buffer depends on the actual
 * implementation.
 */</span>
<span class="token class-name">ByteBuf</span> <span class="token function">buffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">int</span> maxCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其次，在对缓冲区进行写入操作的时候，如果缓冲区容量不足需要扩展，首先对最大容量进行判断，如果扩展后的容量超过上限，则拒绝扩展；</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">ByteBuf</span> <span class="token function">capacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">==</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">ensureAccessible</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在消息解码的时候，对消息长度进行判断，如果超过最大容量上限，则抛岀解码异常，拒绝分配内存。</p>
<h2 id="流量整形"><a href="#流量整形" class="headerlink" title="流量整形"></a>流量整形</h2><p>大多数的商用系统都有多个网元或者部件组成，例如参与短信互动，会涉及手机、基站、短信中心、短信网关、SP/CP 等网元。不同网元或者部件的处理性能不同。为了防止因为浪涌业务或者下游网元性能低导致下游网元被压垮，有时候需要系统提供流量整形功能。</p>
<p>下面我们一起看下流量整形的定义；流量整形（Traffic Shaping）是一种主动调整流量输出速率的措施。一个典型应用是基于下游网络结点的 TP 指标来控制本地流量的输岀。流量整形与流量监管的主要区别在于，流量整形对流量监管中需要丢弃的报文进行缓存——通常是将它们放入缓冲区或队列内，也称流量整形（ Traffic Shaping，简称TS）。当令牌桶有足够的令牌时，再均匀的向外发送这些被缓存的报文。流量整形与流量监管的另一区别是，整形可能会增加延迟，而监管几乎不引入额外的延迟。</p>
<p>流量整形的原理示意图如下图所示。</p>
<p><img src="/images/Netty/流量整形的原理示意图.png" alt=""></p>
<p>作为高性能的 NIO 框架，Netty 的流量整形有两个作用：</p>
<ol>
<li>防止由于上下游网元性能不均衡导致下游网元被压垮，业务流程中断</li>
<li>防止由于通信模块接收消息过快，后端业务线程处理不及时导致的“撑死”问题</li>
</ol>
<h3 id="全局级流量整形"><a href="#全局级流量整形" class="headerlink" title="全局级流量整形"></a>全局级流量整形</h3><p>全局流量整形的作用范围是进程级的，无论你创建了多少个 Channel，它的作用域针对所有的 Channel。</p>
<p>用户可以通过参数设置：报文的接收速率、报文的发送速率、整形周期 GlobalTrafficShapingHandler 的接口定义如下所示：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalTrafficShapingHandler</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractTrafficShapingHandler</span> <span class="token punctuation">&#123;</span>
     <span class="token comment">/**
     * Create a new instance.
     *
     * @param executor
     *            the &#123;@link ScheduledExecutorService&#125; to use for the &#123;@link TrafficCounter&#125;.
     * @param writeLimit
     *            0 or a limit in bytes/s
     * @param readLimit
     *            0 or a limit in bytes/s
     * @param checkInterval
     *            The delay between two computations of performances for
     *            channels or 0 if no stats are to be computed.
     * @param maxTime
     *            The maximum delay to wait in case of traffic excess.
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">GlobalTrafficShapingHandler</span><span class="token punctuation">(</span><span class="token class-name">ScheduledExecutorService</span> executor<span class="token punctuation">,</span> <span class="token keyword">long</span> writeLimit<span class="token punctuation">,</span> <span class="token keyword">long</span> readLimit<span class="token punctuation">,</span>
            <span class="token keyword">long</span> checkInterval<span class="token punctuation">,</span> <span class="token keyword">long</span> maxTime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>writeLimit<span class="token punctuation">,</span> readLimit<span class="token punctuation">,</span> checkInterval<span class="token punctuation">,</span> maxTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">createGlobalTrafficCounter</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Netty 流量整形的原理是：对每次读取到的 ByteBuf 可写字节数进行计算，获取当前的报文流量，然后与流量整形阈值对比。如果已经达到或者超过了阈值。则计算等待时间 delay，将当前的 ByteBuf 放到定时任务 Task 中缓存，由定时任务线程池在延迟 delay 之后继续处理该 ByteBuf。如果达到整形阈值，则对新接收的 ByteBuf 进行缓存，放入线程池的消息队列中，稍后处理。定时任务的延时时间根据检测周期 T 和流量整形阈值计算得来。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">long</span> size <span class="token operator">=</span> <span class="token function">calculateSize</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">TrafficCounter</span><span class="token punctuation">.</span><span class="token function">milliSecondFromNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// compute the number of ms to wait before reopening the channel</span>
        <span class="token keyword">long</span> waitGlobal <span class="token operator">=</span> trafficCounter<span class="token punctuation">.</span><span class="token function">readTimeToWait</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token function">getReadLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> maxTime<span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> key <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">PerChannel</span> perChannel <span class="token operator">=</span> channelQueues<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> wait <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>perChannel <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            wait <span class="token operator">=</span> perChannel<span class="token punctuation">.</span>channelTrafficCounter<span class="token punctuation">.</span><span class="token function">readTimeToWait</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> readChannelLimit<span class="token punctuation">,</span> maxTime<span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>readDeviationActive<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// now try to balance between the channels</span>
                <span class="token keyword">long</span> maxLocalRead<span class="token punctuation">;</span>
                maxLocalRead <span class="token operator">=</span> perChannel<span class="token punctuation">.</span>channelTrafficCounter<span class="token punctuation">.</span><span class="token function">cumulativeReadBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">long</span> maxGlobalRead <span class="token operator">=</span> cumulativeReadBytes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>maxLocalRead <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    maxLocalRead <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>maxGlobalRead <span class="token operator">&lt;</span> maxLocalRead<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    maxGlobalRead <span class="token operator">=</span> maxLocalRead<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                wait <span class="token operator">=</span> <span class="token function">computeBalancedWait</span><span class="token punctuation">(</span>maxLocalRead<span class="token punctuation">,</span> maxGlobalRead<span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>wait <span class="token operator">&lt;</span> waitGlobal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            wait <span class="token operator">=</span> waitGlobal<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        wait <span class="token operator">=</span> <span class="token function">checkWaitReadTime</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>wait <span class="token operator">>=</span> MINIMAL_WAIT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// At least 10ms seems a minimal</span>
            <span class="token comment">// time in order to try to limit the traffic</span>
            <span class="token comment">// Only AutoRead AND HandlerActive True means Context Active</span>
            <span class="token class-name">Channel</span> channel <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">ChannelConfig</span> config <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Read Suspend: "</span> <span class="token operator">+</span> wait <span class="token operator">+</span> <span class="token char">':'</span> <span class="token operator">+</span> config<span class="token punctuation">.</span><span class="token function">isAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token char">':'</span>
                        <span class="token operator">+</span> <span class="token function">isHandlerActive</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">isAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isHandlerActive</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                config<span class="token punctuation">.</span><span class="token function">setAutoRead</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                channel<span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span>READ_SUSPENDED<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// Create a Runnable to reactive the read if needed. If one was create before it will just be</span>
                <span class="token comment">// reused to limit object creation</span>
                <span class="token class-name">Attribute</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> attr <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span>REOPEN_TASK<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Runnable</span> reopenTask <span class="token operator">=</span> attr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>reopenTask <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    reopenTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReopenReadTimerTask</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    attr<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>reopenTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                ctx<span class="token punctuation">.</span><span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>reopenTask<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Suspend final status => "</span> <span class="token operator">+</span> config<span class="token punctuation">.</span><span class="token function">isAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token char">':'</span>
                            <span class="token operator">+</span> <span class="token function">isHandlerActive</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" will reopened at: "</span> <span class="token operator">+</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">informReadOperation</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ctx<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要指出的是，流量整形的阈值 limit 越大，流量整形的精度越高，流量整形功能是可靠性的一种保障，它无法做到 100% 的精确。这个跟后端的编解码以及缓冲区的处理策略相关，此处不再赘述。感兴趣的朋友可以思考下，Netty 为什么不做到 100% 的精确。</p>
<p>流量整形与流控的最大区别在于流控会拒绝消息，流量整形不拒绝和丢弃消息，无论接收量多大，它总能以近似恒定的速度下发消息，跟变压器的原理和功能类似。</p>
<h3 id="链路级流量整形"><a href="#链路级流量整形" class="headerlink" title="链路级流量整形"></a>链路级流量整形</h3><p>除了全局流量整形，Netty 也支持链路级的流量整形，ChannelTrafficShapingHandler 接口定义如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChannelTrafficShapingHandler</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractTrafficShapingHandler</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/**
     * Create a new instance.
     *
     * @param writeLimit
     *            0 or a limit in bytes/s
     * @param readLimit
     *            0 or a limit in bytes/s
     * @param checkInterval
     *            The delay between two computations of performances for
     *            channels or 0 if no stats are to be computed.
     * @param maxTime
     *            The maximum delay to wait in case of traffic excess.
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">ChannelTrafficShapingHandler</span><span class="token punctuation">(</span><span class="token keyword">long</span> writeLimit<span class="token punctuation">,</span> <span class="token keyword">long</span> readLimit<span class="token punctuation">,</span>
            <span class="token keyword">long</span> checkInterval<span class="token punctuation">,</span> <span class="token keyword">long</span> maxTime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
         <span class="token keyword">super</span><span class="token punctuation">(</span>writeLimit<span class="token punctuation">,</span> readLimit<span class="token punctuation">,</span> checkInterval<span class="token punctuation">,</span> maxTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>单链路流量整形与全局流量整形的最大区别就是它以单个链路为作用域，可以对不同的链路设置不同的整形策略。它的实现原理与全局流量整形类似，我们不再赘述。值得说明的是，Netty 支持用户自定义流量整形策略，通过继承 AbstractTrafficShapingHandler 的 doAccounting 方法可以定制整形策略。</p>
<h2 id="优雅停机接口"><a href="#优雅停机接口" class="headerlink" title="优雅停机接口"></a>优雅停机接口</h2><blockquote>
<p>具体的优雅停机接口的内容在《Netty C/S创建与初始化》有详细讲解</p>
</blockquote>
<h1 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h1><h2 id="发送队列容量上限控制"><a href="#发送队列容量上限控制" class="headerlink" title="发送队列容量上限控制"></a>发送队列容量上限控制</h2><p>Netty 的 NIO 消息发送队列 ChannelOutboundBuffer 并没有容量上限控制，它会随着消息的积压自动扩展，直到达到<code>0x7fffffff</code>。</p>
<p>如果网络对方处理速度比较慢，导致 TCP 滑窗长时间为 0；或者消息发送方发送速度过快，或者一次批量发送消息量过大，都可能会导致 ChannelOutboundBuffer 的内存膨胀，这可能会导致系统的内存溢出。</p>
<p>建议优化方式如下：在启动客户端或者服务端的时候，通过启动项的 ChannelOption 设置发送队列的长度，或者通过 -D 启动参数配置该长度。</p>
<h2 id="回推发送失败的消息"><a href="#回推发送失败的消息" class="headerlink" title="回推发送失败的消息"></a>回推发送失败的消息</h2><p>当网络发生故障的时候，Netty 会关闭链路，然后循环释放待未发送的消息，最后通知监听 listener。</p>
<p>这样的处理策略值得商榷，对于大多数用户而言，并不关心底层的网络 IO 异常，他们希望链路恢复之后可以自动将尚未发送的消息重新发送给对方，而不是简单的销毁 Netty 销毁尚未发送的消息，用户可以通过监听器来得到消息发送异常通知，但是却无法获取原始待发送的消息。如果要实现重发，需要自己缓存消息，如果发送成功，自己删除，如果发送失败，重新发送。这对于大多数用户而言，非常麻烦，用户在开发业务代码的同时，还需要考虑网络 IO 层的异常并为之做特殊的业务逻辑处理。</p>
<p>下面我们看下 Mina 的实现，当发生链路异常之后，Mina 会将尚未发送的整包消息队列封装到异常对象中，然后推送给用户 Handler，由用户来决定后续的处理策略。相比于 Netty 的“野蛮”销毁策略，Mina 的策略更灵活和合理，由用户自己决定发送失败消息的后续处理策略大多数场景下，业务用户会使用 RPC 框架，他们通常不需要直接针对 Netty 编程，如果 Netty 提供了发送失败消息的回推功能，RPC 框架就可以进行封装，提供不同的策略给业务用户使用，例如：</p>
<ol>
<li>缓存重发策略：当链路发生异常之后，尚未发送成功的消息自动缓存，待链路恢复正常之后重发失败的消息</li>
<li>失败删除策略：当链路发生异常之后，尚未发送成功的消息自动销毁，它可能是非重要消息，例如日志消息，也可能是由业务直接监听异常并做特殊处理</li>
<li>其他策略</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Netty/" rel="tag"># Netty</a>
              <a href="/tags/%E6%B5%81%E9%87%8F%E6%95%B4%E5%BD%A2/" rel="tag"># 流量整形</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/24/Netty-%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93/" rel="prev" title="Netty 高性能之道">
      <i class="fa fa-chevron-left"></i> Netty 高性能之道
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/28/ZooKeeper-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E5%8F%8ALeader%E9%80%89%E4%B8%BE/" rel="next" title="ZooKeeper 服务器启动及Leader选举">
      ZooKeeper 服务器启动及Leader选举 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E9%9C%80%E6%B1%82"><span class="nav-number">1.</span> <span class="nav-text">可靠性需求</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">Netty主要应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">1.2.</span> <span class="nav-text">Netty的运行环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty%E6%95%85%E9%9A%9C%E7%9A%84%E5%90%8E%E6%9E%9C"><span class="nav-number">1.3.</span> <span class="nav-text">Netty故障的后果</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text">可靠性设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%B1%BB%E6%95%85%E9%9A%9C"><span class="nav-number">2.1.</span> <span class="nav-text">网络通信类故障</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6"><span class="nav-number">2.1.1.</span> <span class="nav-text">客户端连接超时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E5%AF%B9%E7%AB%AF%E5%BC%BA%E5%88%B6%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.1.2.</span> <span class="nav-text">通信对端强制关闭连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E5%85%B3%E9%97%AD"><span class="nav-number">2.1.3.</span> <span class="nav-text">链路关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6IO%E6%95%85%E9%9A%9C"><span class="nav-number">2.1.4.</span> <span class="nav-text">定制IO故障</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E6%A3%80%E6%B5%8B"><span class="nav-number">2.2.</span> <span class="nav-text">链路的有效性检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="nav-number">2.3.</span> <span class="nav-text">Reactor线程的保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">2.3.1.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%84%E9%81%BF-NIO-Bug"><span class="nav-number">2.3.2.</span> <span class="nav-text">规避 NIO Bug</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-number">2.4.</span> <span class="nav-text">内存保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E4%BF%9D%E6%8A%A4"><span class="nav-number">2.5.</span> <span class="nav-text">缓冲区溢出保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%95%B4%E5%BD%A2"><span class="nav-number">2.6.</span> <span class="nav-text">流量整形</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E7%BA%A7%E6%B5%81%E9%87%8F%E6%95%B4%E5%BD%A2"><span class="nav-number">2.6.1.</span> <span class="nav-text">全局级流量整形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E7%BA%A7%E6%B5%81%E9%87%8F%E6%95%B4%E5%BD%A2"><span class="nav-number">2.6.2.</span> <span class="nav-text">链路级流量整形</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.7.</span> <span class="nav-text">优雅停机接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">3.</span> <span class="nav-text">优化建议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E9%98%9F%E5%88%97%E5%AE%B9%E9%87%8F%E4%B8%8A%E9%99%90%E6%8E%A7%E5%88%B6"><span class="nav-number">3.1.</span> <span class="nav-text">发送队列容量上限控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%8E%A8%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%B6%88%E6%81%AF"><span class="nav-number">3.2.</span> <span class="nav-text">回推发送失败的消息</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang Zihao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">162</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">310</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Zihao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
