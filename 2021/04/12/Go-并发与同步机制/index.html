<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Go 并发与同步机制">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 并发与同步机制">
<meta property="og:url" content="http://example.com/2021/04/12/Go-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Lanchester Blog">
<meta property="og:description" content="Go 并发与同步机制">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/Go/BufferedChannels.png">
<meta property="article:published_time" content="2021-04-12T09:37:21.000Z">
<meta property="article:modified_time" content="2022-08-11T07:37:29.640Z">
<meta property="article:author" content="Wang Zihao">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Go/BufferedChannels.png">

<link rel="canonical" href="http://example.com/2021/04/12/Go-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Go 并发与同步机制 | Lanchester Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lanchester Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Leave a leaf</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/12/Go-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Zihao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lanchester Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go 并发与同步机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-12 17:37:21" itemprop="dateCreated datePublished" datetime="2021-04-12T17:37:21+08:00">2021-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-11 15:37:29" itemprop="dateModified" datetime="2022-08-11T15:37:29+08:00">2022-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Go 并发与同步机制</p>
<span id="more"></span>

<h1 id="Goroutine和Channels"><a href="#Goroutine和Channels" class="headerlink" title="Goroutine和Channels"></a>Goroutine和Channels</h1><p>goroutine 和 channels 支持“顺序通信进程”（communicating sequential processes）或被简称为 CSP。CSP 是一种现代的并发编程模型，在这种编程模型中值会在不同的运行实例（goroutine）中传递，尽管大多数情况下仍然是被限制在单一实例中。传统的并发模型：多线程共享内存，如果你在其它的主流语言中写过并发程序的话可能会更熟悉一些。</p>
<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>Goroutine 不同于 thread，threads 是操作系统中的对于一个独立运行实例的描述，不同操作系统，对于 thread 的实现也不尽相同；但是，操作系统并不知道 goroutine 的存在，goroutine 的调度是由 Golang 运行时进行管理的。启动 thread 虽然比 process 所需的资源要少，但是多个 thread 之间的上下文切换仍然是需要大量的工作的（寄存器&#x2F;Program Count&#x2F;Stack Pointer&#x2F;…），Golang 有自己的调度器，许多 goroutine 的数据都是共享的，因此 goroutine 之间的切换会快很多，启动 goroutine 所耗费的资源也很少，一个 Golang 程序同时存在几百个 goroutine 是很正常的。</p>
<p>Channel，即“管道”，是用来传递数据（叫消息更为合适）的一个数据结构，即可以从 channel 里面塞数据，也可以从中获取数据。channel 本身并没有什么神奇的地方，但是 channel 加上了 goroutine，就形成了一种既简单又强大的请求处理模型， 即 N 个工作 goroutine 将处理的中间结果或者最终结果放入一个 channel，另外有 M 个工作 goroutine 从这个 channel 拿数据，再进行进一步加工，通过组合这种过程，从而胜任各种复杂的业务模型。 当一个程序启动时，其主函数即在一个单独的 goroutine 中运行，我们叫它 main goroutine。新的 goroutine 会用 go 语句来创建。</p>
<p>在语法上，go 语句是一个普通的函数或方法调用前加上关键字 go。go 语句会使其语句中的函数在一个新创建的 goroutine 中运行。而 go 语句本身会迅速地完成。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//调用f()并等待返回</span>
<span class="token keyword">go</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//创建一个新 goroutine 执行 f() 不需要等待</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>runtime.Gosched() 用于让出 CPU 时间片。</p>
<blockquote>
<p>个人猜测与 Java 中 yield() 类似。原理以后深究。</p>
</blockquote>
<p>go 中的 goroutins 并不是同时在运行。事实上，如果没有在代码中通过 runtime.GOMAXPROCS(n) 其中 n 是整数，指定使用多核的话，goroutins 都是在一个线程里的，它们之间通过不停的让出时间片轮流运行，达到类似同时运行的效果。当一个 goroutine 发生阻塞，Go 会自动地把与该 goroutine 处于同一系统线程的其他 goroutines 转移到另一个系统线程上去，以使这些 goroutines 不阻塞。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">func <span class="token function">showNumber</span><span class="token punctuation">(</span>i <span class="token keyword">int</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>
   <span class="token class-name"><span class="token namespace">fmt<span class="token punctuation">.</span></span>Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

func <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>
   <span class="token keyword">for</span> i <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
      go <span class="token function">showNumber</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
   <span class="token punctuation">&#125;</span>

   <span class="token class-name"><span class="token namespace">runtime<span class="token punctuation">.</span></span>Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token class-name"><span class="token namespace">fmt<span class="token punctuation">.</span></span>Println</span><span class="token punctuation">(</span><span class="token string">"End"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>如果说 goroutine 是 Go 语言程序的并发体的话，那么 Channels 则是它们之间的通信机制。通过指定一个特定类型的 Channel，来建立两个 goroutine 之间的数据通信通道。</p>
<h3 id="Channels的基本操作"><a href="#Channels的基本操作" class="headerlink" title="Channels的基本操作"></a>Channels的基本操作</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Channel 对应一个 make 创建的底层数据结构的引用，当复制一个 Channel 或用于函数参数传递时，我们只是拷贝了一个 Channel 引用，因此调用者和被调用者将引用同一个 Channel 对象。</p>
<p>而对于 Channels 的值操作，分为发送和接收。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// x is specific type which is defined channel</span>
ch <span class="token operator">&lt;-</span> x <span class="token comment">// a send statement</span>
x <span class="token operator">=</span> <span class="token operator">&lt;-</span>ch <span class="token comment">// a receive expression in an assignment statement</span>
<span class="token operator">&lt;-</span>ch <span class="token comment">// a receive statement; result is discarded</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>Channels 还支持 close 操作，用于关闭 Channels，随后对基于该 Channel 的任何发送操作都将导致 panic 异常。对一个已经被 close 过的 Channel 进行接收操作依然可以接受到之前已经成功发送的数据；如果 Channel 中已经没有数据的话将产生一个零值的数据。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在方法参数的使用上，还有一种特殊用法。通过给 Channels 指定方向来避免 Channels 的滥用</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//chan&lt;- 只负责发送数据的Channel &lt;-chan 只负责接收数据的Channel</span>
<span class="token keyword">func</span> <span class="token function">squarer</span><span class="token punctuation">(</span>out <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">,</span> in <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> in <span class="token punctuation">&#123;</span>
        out <span class="token operator">&lt;-</span> v <span class="token operator">*</span> v
    <span class="token punctuation">&#125;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    naturals <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
    squares <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token comment">//...</span>
    <span class="token keyword">go</span> <span class="token function">squarer</span><span class="token punctuation">(</span>squares<span class="token punctuation">,</span> naturals<span class="token punctuation">)</span>
	<span class="token comment">//...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Channels的类型"><a href="#Channels的类型" class="headerlink" title="Channels的类型"></a>Channels的类型</h3><p>以最简单方式调用 make 函数创建的是一个无缓存的 Channel，但是我们也可以指定第二个整型参数，对应 Channel 的容量。如果 Channel 的容量大于零，那么该 Channel 就是带缓存的 Channel。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">ch <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// unbuffered channel </span>
ch <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// unbuffered channel </span>
ch <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// buffered channel with capacity 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="无缓存的Channels"><a href="#无缓存的Channels" class="headerlink" title="无缓存的Channels"></a>无缓存的Channels</h4><p>一个基于无缓存 Channel 的发送操作将导致发送者 goroutine 阻塞，直到另一个 goroutine 在相同的 Channels 上执行接收操作，当发送的值通过 Channels 成功传输 之后，两个 goroutine 可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者 goroutine 也将阻塞，直到有另一个 goroutine 在相同的 Channels 上执行发送操作。</p>
<p>基于无缓存 Channels 的发送和接收操作将导致两个 goroutine 做一次同步操作。因为这个原因，无缓存 Channels 有时候也被称为同步 Channels。当通过一个无缓存 Channels 发送数据时，接收者收到数据发生在唤醒发送者 goroutine 之前。</p>
<h4 id="可缓存的Channels"><a href="#可缓存的Channels" class="headerlink" title="可缓存的Channels"></a>可缓存的Channels</h4><p>带缓存的 Channel 内部持有一个元素队列。队列的最大容量是在调用 make 函数创建 Channel 时通过第二个参数指定的。</p>
<p><img src="/images/Go/BufferedChannels.png"></p>
<p>向缓存 Channel 的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个 goroutine 执行接收操作而释放了新的队列空间。相反，如果 Channel 是空的，接收操作将阻塞直到有另一个 goroutine 执行发送操作而向队列插入元素。</p>
<p>需要知道的是，我们可以使用<code>cap()</code>和<code>len()</code>获取 Channel 内部缓存的容量和长度。</p>
<h1 id="基于共享变量的并发"><a href="#基于共享变量的并发" class="headerlink" title="基于共享变量的并发"></a>基于共享变量的并发</h1><h2 id="Channels信号量"><a href="#Channels信号量" class="headerlink" title="Channels信号量"></a>Channels信号量</h2><p>下面使用了一个 buffered channel 作为一个计数信号量，来保证最多只有 20 个 goroutine 会同时执行 HTTP 请求。同理，我们可以用一个容量只有 1 的 channel 来保证最多只有一个 goroutine 在同一时刻访问一个共享变量。一个只能为 1 和 0 的信号量叫做二元信号量（binary semaphore）。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>
    sema    <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// a binary semaphore guarding balance</span>
    balance <span class="token builtin">int</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">Deposit</span><span class="token punctuation">(</span>amount <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    sema <span class="token operator">&lt;-</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// acquire token</span>
    balance <span class="token operator">=</span> balance <span class="token operator">+</span> amount
    <span class="token operator">&lt;-</span>sema <span class="token comment">// release token</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">Balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    sema <span class="token operator">&lt;-</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// acquire token</span>
    b <span class="token operator">:=</span> balance
    <span class="token operator">&lt;-</span>sema <span class="token comment">// release token</span>
    <span class="token keyword">return</span> b
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="sync-Mutex互斥锁"><a href="#sync-Mutex互斥锁" class="headerlink" title="sync.Mutex互斥锁"></a>sync.Mutex互斥锁</h2><p>通过调用 mutex 的 Lock 方法来获取一个互斥锁。如果其它的 goroutine 已经获得了这个锁的话，这个操作会被阻塞直到其它 goroutine 调用了 Unlock 使该锁变回可用状态。mutex 会保护共享变量。惯例来说，被 mutex 所保护的变量是在 mutex 变量声明之后立刻声明的。如果你的做法和惯例不符，确保在文档里对你的做法进行说明。</p>
<p>在 Lock 和 Unlock 之间的代码段中的内容 goroutine 可以随便读取或者修改，这个代码段叫做临界区。锁的持有者在其他 goroutine 获取该锁之前需要调用 Unlock。goroutine 在结束后释放锁是必要的，无论以哪条路径通过函数都需要释放，即使是在错误路径中，也要记得释放。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"sync"</span>

<span class="token keyword">var</span> <span class="token punctuation">(</span>
    mu      sync<span class="token punctuation">.</span>Mutex <span class="token comment">// guards balance</span>
    balance <span class="token builtin">int</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">Deposit</span><span class="token punctuation">(</span>amount <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    balance <span class="token operator">=</span> balance <span class="token operator">+</span> amount
    mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">Balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    b <span class="token operator">:=</span> balance
    mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> b
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于在存款和查询余额函数中的临界区代码这么短 —— 只有一行，没有分支调用——在代码最后去调用 Unlock 就显得更为直截了当。在更复杂的临界区的应用中，尤其是必须要尽早处理错误并返回的情况下，就很难去（靠人）判断对 Lock 和 Unlock 的调用是在所有路径中都能够严格配对的了。Go 语言里的 defer 简直就是这种情况下的救星：我们用 defer 来调用 Unlock，临界区会隐式地延伸到函数作用域的最后，这样我们就从“总要记得在函数返回之后或者发生错误返回时要记得调用一次 Unlock”这种状态中获得了解放。Go 会自动帮我们完成这些事情。</p>
<p>此外，一个 deferred Unlock 即使在临界区发生 panic 时依然会执行，这对于用 recover（§5.10）来恢复的程序来说是很重要的。defer 调用只会比显式地调用 Unlock 成本高那么一点点，不过却在很大程度上保证了代码的整洁性。大多数情况下对于并发程序来说，代码的整洁性比过度的优化更重要。如果可能的话尽量使用 defer 来将临界区扩展到函数的结束。</p>
<blockquote>
<p>Note：sync.Mutex 为非重入锁</p>
</blockquote>
<h2 id="sync-RWMutex读写锁"><a href="#sync-RWMutex读写锁" class="headerlink" title="sync.RWMutex读写锁"></a>sync.RWMutex读写锁</h2><p>“多读单写”锁（multiple readers, single writer lock）允许多个只读操作并行执行，但写操作会完全互斥。Go 语言提供的这样的锁是 sync.RWMutex：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>RWMutex
<span class="token keyword">var</span> balance <span class="token builtin">int</span>
<span class="token keyword">func</span> <span class="token function">Balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
    mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// readers lock</span>
    <span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> balance
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Balance函数现在调用了 RLock 和 RUnlock 方法来获取和释放一个读取或者共享锁。Deposit 函数没有变化，会调用 mu.Lock 和 mu.Unlock 方法来获取和释放一个写或互斥锁。</p>
<p>RWMutex 只有当获得锁的大部分 goroutine 都是读操作，而锁在竞争条件下，也就是说，goroutine 们必须等待才能获取到锁的时候，RWMutex 才是最能带来好处的。RWMutex 需要更复杂的内部记录，所以会让它比一般的无竞争锁的 mutex 慢一些。</p>
<h2 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h2><p>你可能比较纠结为什么 Balance 方法需要用到互斥条件，无论是基于 channel 还是基于互斥量。毕竟和存款不一样，它只由一个简单的操作组成，所以不会碰到其它 goroutine 在其执行“期间”执行其它逻辑的风险。这里使用 mutex 有两方面考虑。第一 Balance 不会在其它操作比如 Deposit “中间”执行。第二（更重要的）是“同步”不仅仅是一堆 goroutine 执行顺序的问题，同样也会涉及到内存的问题。</p>
<p>在现代计算机中可能会有一堆处理器，每一个都会有其本地缓存（local cache）。为了效率，对内存的写入一般会在每一个处理器中缓冲，并在必要时一起 flush 到主存。这种情况下这些数据可能会以与当初 goroutine 写入顺序不同的顺序被提交到主存。像 channel 通信或者互斥量操作这样的原语会使处理器将其聚集的写入 flush 并 commit，这样 goroutine 在某个时间点上的执行结果才能被其它处理器上运行的 goroutine 得到。</p>
<p>考虑一下下面代码片段的可能输出：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x<span class="token punctuation">,</span> y <span class="token builtin">int</span>
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    x <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// A1</span>
    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"y:"</span><span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span> <span class="token comment">// A2</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    y <span class="token operator">=</span> <span class="token number">1</span>                   <span class="token comment">// B1</span>
    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"x:"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span> <span class="token comment">// B2</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因为两个 goroutine 是并发执行，并且访问共享变量时也没有互斥，会有数据竞争，所以程序的运行结果没法预测的话也请不要惊讶。我们可能希望它能够打印出下面这四种结果中的一种，相当于几种不同的交错执行时的情况：</p>
<pre class="line-numbers language-none"><code class="language-none">y:0 x:1
x:0 y:1
x:1 y:1
y:1 x:1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>第四行可以被解释为执行顺序 A1, B1, A2, B2 或者 B1, A1, A2, B2 的执行结果。然而实际运行时还是有些情况让我们有点惊讶：</p>
<pre class="line-numbers language-none"><code class="language-none">x:0 y:0
y:0 x:0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="sync-Once惰性初始化"><a href="#sync-Once惰性初始化" class="headerlink" title="sync.Once惰性初始化"></a>sync.Once惰性初始化</h2><p>如果初始化成本比较大的话，那么将初始化延迟到需要的时候再去做就是一个比较好的选择。如果在程序启动的时候就去做这类初始化的话，会增加程序的启动时间，并且因为执行的时候可能也并不需要这些变量，所以实际上有一些浪费。让我们来看在本章早一些时候的 icons 变量：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> icons <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个版本的 Icon 用到了懒初始化（lazy initialization）。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    icons <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token punctuation">&#123;</span>
        <span class="token string">"spades.png"</span><span class="token punctuation">:</span>   <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"spades.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token string">"hearts.png"</span><span class="token punctuation">:</span>   <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"hearts.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token string">"diamonds.png"</span><span class="token punctuation">:</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"diamonds.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token string">"clubs.png"</span><span class="token punctuation">:</span>    <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"clubs.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// NOTE: not concurrency-safe!</span>
<span class="token keyword">func</span> <span class="token function">Icon</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> image<span class="token punctuation">.</span>Image <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> icons <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// one-time initialization</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> icons<span class="token punctuation">[</span>name<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果一个变量只被一个单独的 goroutine 所访问的话，我们可以使用上面的这种模板，但这种模板在 Icon 被并发调用时并不安全。因为缺少显式的同步，编译器和 CPU 是可以随意地去更改访问内存的指令顺序，以任意方式，只要保证每一个 goroutine 自己的执行顺序一致。其中一种可能 loadIcons 的语句重排是下面这样。它会在填写 icons 变量的值之前先用一个空 map 来初始化 icons 变量。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    icons <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token punctuation">)</span>
    icons<span class="token punctuation">[</span><span class="token string">"spades.png"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"spades.png"</span><span class="token punctuation">)</span>
    icons<span class="token punctuation">[</span><span class="token string">"hearts.png"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"hearts.png"</span><span class="token punctuation">)</span>
    icons<span class="token punctuation">[</span><span class="token string">"diamonds.png"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"diamonds.png"</span><span class="token punctuation">)</span>
    icons<span class="token punctuation">[</span><span class="token string">"clubs.png"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"clubs.png"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因此，一个 goroutine 在检查 icons 是非空时，也并不能就假设这个变量的初始化流程已经走完了（译注：可能只是塞了个空map，里面的值还没填完，也就是说填值的语句都没执行完呢）。</p>
<p>最简单且正确的保证所有 goroutine 能够观察到 loadIcons 效果的方式，是用一个 mutex 来同步检查。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex <span class="token comment">// guards icons</span>
<span class="token keyword">var</span> icons <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image

<span class="token comment">// Concurrency-safe.</span>
<span class="token keyword">func</span> <span class="token function">Icon</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> image<span class="token punctuation">.</span>Image <span class="token punctuation">&#123;</span>
    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> icons <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> icons<span class="token punctuation">[</span>name<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然而使用互斥访问 icons 的代价就是没有办法对该变量进行并发访问，即使变量已经被初始化完毕且再也不会进行变动。这里我们可以引入一个允许多读的锁：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>RWMutex <span class="token comment">// guards icons</span>
<span class="token keyword">var</span> icons <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image
<span class="token comment">// Concurrency-safe.</span>
<span class="token keyword">func</span> <span class="token function">Icon</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> image<span class="token punctuation">.</span>Image <span class="token punctuation">&#123;</span>
    mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> icons <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
        icon <span class="token operator">:=</span> icons<span class="token punctuation">[</span>name<span class="token punctuation">]</span>
        mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> icon
    <span class="token punctuation">&#125;</span>
    mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// acquire an exclusive lock</span>
    mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> icons <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span> <span class="token comment">// NOTE: must recheck for nil</span>
        <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    icon <span class="token operator">:=</span> icons<span class="token punctuation">[</span>name<span class="token punctuation">]</span>
    mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> icon
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的代码有两个临界区。goroutine 首先会获取一个读锁，查询 map，然后释放锁。如果条目被找到了（一般情况下），那么会直接返回。如果没有找到，那 goroutine 会获取一个写锁。不释放共享锁的话，也没有任何办法来将一个共享锁升级为一个互斥锁，所以我们必须重新检查 icons 变量是否为 nil，以防止在执行这一段代码的时候，icons 变量已经被其它 gorouine 初始化过了。</p>
<p>上面的模板使我们的程序能够更好的并发，但是有一点太复杂且容易出错。幸运的是，sync 包为我们提供了一个专门的方案来解决这种一次性初始化的问题：sync.Once。概念上来讲，一次性的初始化需要一个互斥量 mutex 和一个 boolean 变量来记录初始化是不是已经完成了；互斥量用来保护 boolean 变量和客户端数据结构。Do 这个唯一的方法需要接收初始化函数作为其参数。让我们用 sync.Once 来简化前面的 Icon 函数吧：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> loadIconsOnce sync<span class="token punctuation">.</span>Once
<span class="token keyword">var</span> icons <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image
<span class="token comment">// Concurrency-safe.</span>
<span class="token keyword">func</span> <span class="token function">Icon</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> image<span class="token punctuation">.</span>Image <span class="token punctuation">&#123;</span>
    loadIconsOnce<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>loadIcons<span class="token punctuation">)</span>
    <span class="token keyword">return</span> icons<span class="token punctuation">[</span>name<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每一次对 Do(loadIcons) 的调用都会锁定 mutex，并会检查 boolean 变量（译注：Go1.9 中会先判断 boolean 变量是否为 1(true)，只有不为 1 才锁定 mutex，不再需要每次都锁定 mutex）。在第一次调用时， boolean 变量的值是 false，Do 会调用 loadIcons 并会将 boolean 变量设置为 true。随后的调用什么都不会做，但是 mutex 同步会保证 loadIcons 对内存（这里其实就是指 icons 变量啦）产生的效果能够对所有 goroutine 可见。用这种方式来使用 sync.Once 的话，我们能够避免在变量被构建完成之前和其它 goroutine 共享该变量。</p>
<h2 id="竞争条件检测"><a href="#竞争条件检测" class="headerlink" title="竞争条件检测"></a>竞争条件检测</h2><p>即使我们小心到不能再小心，但在并发程序中犯错还是太容易了。幸运的是，Go 的 runtime 和工具链为我们装备了一个复杂但好用的动态分析工具，竞争检查器（the race detector）。</p>
<p>只要在 go build，go run 或者 go test 命令后面加上-race 的 flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的 test，并且会记录下每一个读或者写共享变量的 goroutine 的身份信息。另外，修改版的程序会记录下所有的同步事件，比如 go 语句，channel 操作，以及对<code>(*sync.Mutex).Lock</code>，<code>(*sync.WaitGroup).Wait</code>等等的调用。（完整的同步事件集合是在The Go Memory Model文档中有说明，该文档是和语言文档放在一起的。译注：<a target="_blank" rel="noopener" href="https://golang.org/ref/mem">https://golang.org/ref/mem</a> ）</p>
<p>竞争检查器会检查这些事件，会寻找在哪一个 goroutine 中出现了这样的case，例如其读或者写了一个共享变量，这个共享变量是被另一个 goroutine 在没有进行干预同步操作便直接写入的。这种情况也就表明了是对一个共享变量的并发访问，即数据竞争。这个工具会打印一份报告，内容包含变量身份，读取和写入的 goroutine 中活跃的函数的调用栈。这些信息在定位问题时通常很有用。</p>
<p>竞争检查器会报告所有的已经发生的数据竞争。然而，它只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争。所以为了使结果尽量正确，请保证你的测试并发地覆盖到了你的包。</p>
<p>由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的程序（工作）来说还是可以接受的。对于一些偶发的竞争条件来说，让竞争检查器来干活可以节省无数日夜的 debugging。</p>
<h2 id="Goroutines和线程"><a href="#Goroutines和线程" class="headerlink" title="Goroutines和线程"></a>Goroutines和线程</h2><p>goroutine 和操作系统的线程区别可以先忽略。尽管两者的区别实际上只是一个量的区别，但量变会引起质变的道理同样适用于 goroutine 和线程。现在正是我们来区分开两者的最佳时机。</p>
<h3 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h3><p>每一个 OS 线程都有一个固定大小的内存块（一般会是 2 MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量。这个固定大小的栈同时很大又很小。因为 2MB 的栈对于一个小小的 goroutine 来说是很大的内存浪费，比如对于我们用到的，一个只是用来 WaitGroup 之后关闭 channel 的 goroutine 来说。而对于 go 程序来说，同时创建成百上千个 goroutine 是非常普遍的，如果每一个 goroutine 都需要这么大的栈的话，那这么多的 goroutine 就不太可能了。除去大小的问题之外，固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。修改固定的大小可以提升空间的利用率，允许创建更多的线程，并且可以允许更深的递归调用，不过这两者是没法同时兼备的。</p>
<p>相反，一个 goroutine 会以一个很小的栈开始其生命周期，一般只需要 2KB。一个 goroutine 的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和 OS 线程不太一样的是，一个 goroutine 的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。而 goroutine 的栈的最大值有 1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多 goroutine 都不需要这么大的栈。</p>
<h3 id="Goroutine调度"><a href="#Goroutine调度" class="headerlink" title="Goroutine调度"></a>Goroutine调度</h3><p>OS 线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作 scheduler 的内核函数。这个函数会挂起当前执行的线程并将它的寄存器内容保存到内存中，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的 CPU 周期。</p>
<p>Go 的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如 m:n 调度，因为其会在 n 个操作系统线程上多工（调度）m 个 goroutine。Go 调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的 Go 程序中的 goroutine（译注：按程序独立）。</p>
<p>和操作系统的线程调度不同的是，Go 调度器并不是用一个硬件定时器，而是被Go语言“建筑”本身进行调度的。例如当一个 goroutine 调用了 time.Sleep，或者被 channel 调用或者 mutex 操作阻塞时，调度器会使其进入休眠并开始执行另一个 goroutine，直到时机到了再去唤醒第一个 goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个 goroutine 比调度一个线程代价要低得多。</p>
<h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p>Go 的调度器使用了一个叫做 GOMAXPROCS 的变量来决定会有多少个操作系统的线程同时执行 Go 的代码。其默认的值是运行机器上的 CPU 的核心数，所以在一个有 8 个核心的机器上时，调度器一次会在 8 个 OS 线程上去调度 GO 代码。（GOMAXPROCS 是前面说的 m:n 调度中的 n）。在休眠中的或者在通信中被阻塞的 goroutine 是不需要一个对应的线程来做调度的。在 I&#x2F;O 中或系统调用中或调用非 Go 语言函数时，是需要一个对应的操作系统线程的，但是 GOMAXPROCS 并不需要将这几种情况计算在内。</p>
<p>可以用 GOMAXPROCS 的环境变量来显式地控制这个参数，或者也可以在运行时用 runtime.GOMAXPROCS 函数来修改它。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">go</span> fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

$ GOMAXPROCS<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">go</span> run hacker<span class="token operator">-</span>cliché<span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token number">111111111111111111110000000000000000000011111.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

$ GOMAXPROCS<span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">go</span> run hacker<span class="token operator">-</span>cliché<span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token number">010101010101010101011001100101011010010100110.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在第一次执行时，最多同时只能有一个 goroutine 被执行。初始情况下只有 main goroutine 被执行，所以会打印很多 1。过了一段时间后，GO 调度器会将其置为休眠，并唤醒另一个 goroutine，这时候就开始打印很多 0 了，在打印的时候，goroutine 是被调度到操作系统线程上的。在第二次执行时，我们使用了两个操作系统线程，所以两个 goroutine 可以一起被执行，以同样的频率交替打印 0 和 1。我们必须强调的是 goroutine 的调度是受很多因子影响的，而 runtime 也是在不断地发展演进的，所以这里的你实际得到的结果可能会因为版本的不同而与我们运行的结果有所不同。</p>
<h3 id="Goroutine没有ID号"><a href="#Goroutine没有ID号" class="headerlink" title="Goroutine没有ID号"></a>Goroutine没有ID号</h3><p>在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份（ID），并且这个身份信息可以以一个普通值的形式被很容易地获取到，典型的可以是一个 int 或者指针值。这种情况下我们做一个抽象化的 thread-local storage（线程本地存储，多线程编程中不希望其它线程访问的内容）就很容易，只需要以线程的 ID 作为 key 的一个 map 就可以解决问题，每一个线程以其 id 就能从中获取到值，且和其它线程互不冲突。</p>
<p>goroutine 没有可以被程序员获取到的身份（ID）的概念。这一点是设计上故意而为之，由于 thread-local storage 总是会被滥用。比如说，一个 Web Server 是用一种支持 tls 的语言实现的，而非常普遍的是很多函数会去寻找 HTTP 请求的信息，这代表它们就是去其存储层（这个存储层有可能是 tls）查找的。这就像是那些过分依赖全局变量的程序一样，会导致一种非健康的“距离外行为”，在这种行为下，一个函数的行为可能并不仅由自己的参数所决定，而是由其所运行在的线程所决定。因此，如果线程本身的身份会改变 —— 比如一些 Worker 线程之类的——那么函数的行为就会变得神秘莫测。</p>
<p>Go 鼓励更为简单的模式，这种模式下参数（译注：外部显式参数和内部显式参数。tls 中的内容算是”外部”隐式参数）对函数的影响都是显式的。这样不仅使程序变得更易读，而且会让我们自由地向一些给定的函数分配子任务时不用担心其身份信息影响行为。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/11/RPC-Protobuf%E6%A1%86%E6%9E%B6/" rel="prev" title="RPC ProtoBuf框架">
      <i class="fa fa-chevron-left"></i> RPC ProtoBuf框架
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/25/RPC-GRPC%E6%A1%86%E6%9E%B6/" rel="next" title="RPC gRPC框架">
      RPC gRPC框架 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Goroutine%E5%92%8CChannels"><span class="nav-number">1.</span> <span class="nav-text">Goroutine和Channels</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Goroutine"><span class="nav-number">1.1.</span> <span class="nav-text">Goroutine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime"><span class="nav-number">1.2.</span> <span class="nav-text">Runtime</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channels"><span class="nav-number">1.3.</span> <span class="nav-text">Channels</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channels%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.1.</span> <span class="nav-text">Channels的基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channels%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">Channels的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%BC%93%E5%AD%98%E7%9A%84Channels"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">无缓存的Channels</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E7%BC%93%E5%AD%98%E7%9A%84Channels"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">可缓存的Channels</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%B9%B6%E5%8F%91"><span class="nav-number">2.</span> <span class="nav-text">基于共享变量的并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Channels%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text">Channels信号量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sync-Mutex%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">2.2.</span> <span class="nav-text">sync.Mutex互斥锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sync-RWMutex%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">sync.RWMutex读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5"><span class="nav-number">2.4.</span> <span class="nav-text">内存同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sync-Once%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.5.</span> <span class="nav-text">sync.Once惰性初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E6%A3%80%E6%B5%8B"><span class="nav-number">2.6.</span> <span class="nav-text">竞争条件检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Goroutines%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.7.</span> <span class="nav-text">Goroutines和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%A0%88"><span class="nav-number">2.7.1.</span> <span class="nav-text">动态栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Goroutine%E8%B0%83%E5%BA%A6"><span class="nav-number">2.7.2.</span> <span class="nav-text">Goroutine调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GOMAXPROCS"><span class="nav-number">2.7.3.</span> <span class="nav-text">GOMAXPROCS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Goroutine%E6%B2%A1%E6%9C%89ID%E5%8F%B7"><span class="nav-number">2.7.4.</span> <span class="nav-text">Goroutine没有ID号</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang Zihao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">266</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Zihao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
