<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Redis 是 Remote Dictionary Server（Redis）的缩写，是一个由 Salvatore Sanfilippo 编写的 Key-Value 存储系统，是一个使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型的 Key-Value 数据库，并提供多种语言的 API。 本文归纳了 Redis List、HASH、ZSET、PUB&#x2F;SUB">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 命令手册">
<meta property="og:url" content="http://example.com/2021/05/20/Redis-%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/index.html">
<meta property="og:site_name" content="Lanchester Blog">
<meta property="og:description" content="Redis 是 Remote Dictionary Server（Redis）的缩写，是一个由 Salvatore Sanfilippo 编写的 Key-Value 存储系统，是一个使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型的 Key-Value 数据库，并提供多种语言的 API。 本文归纳了 Redis List、HASH、ZSET、PUB&#x2F;SUB">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/Redis/RedisStream.png">
<meta property="article:published_time" content="2021-05-20T02:10:00.000Z">
<meta property="article:modified_time" content="2023-02-02T06:57:36.871Z">
<meta property="article:author" content="Wang Zihao">
<meta property="article:tag" content="Command">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Redis/RedisStream.png">

<link rel="canonical" href="http://example.com/2021/05/20/Redis-%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Redis 命令手册 | Lanchester Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lanchester Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Leave a leaf</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/20/Redis-%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Zihao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lanchester Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis 命令手册
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-20 10:10:00" itemprop="dateCreated datePublished" datetime="2021-05-20T10:10:00+08:00">2021-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-02 14:57:36" itemprop="dateModified" datetime="2023-02-02T14:57:36+08:00">2023-02-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Redis 是 Remote Dictionary Server（Redis）的缩写，是一个由 Salvatore Sanfilippo 编写的 Key-Value 存储系统，是一个使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型的 Key-Value 数据库，并提供多种语言的 API。</p>
<p>本文归纳了 Redis List、HASH、ZSET、PUB/SUB 相关的命令。</p>
<blockquote>
<p>官方文档 <a target="_blank" rel="noopener" href="https://redis.io/commands">Command reference</a></p>
</blockquote>
<span id="more"></span>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p><strong>关键字符解释</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>全拼</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>Multiple</td>
<td>多重的</td>
</tr>
<tr>
<td>EX</td>
<td>Set the specified expire time, in seconds.</td>
<td>设置秒级过期时间</td>
</tr>
<tr>
<td>PX</td>
<td>Set the specified expire time, in milliseconds.</td>
<td>设置毫秒级过期时间</td>
</tr>
<tr>
<td>NX</td>
<td>Only set the key if it does not already exist.</td>
<td>不存在时 SET</td>
</tr>
<tr>
<td>XX</td>
<td>Only set the key if it already exist.</td>
<td>存在时 SET</td>
</tr>
<tr>
<td>INCR</td>
<td>Increment</td>
<td>增加</td>
</tr>
<tr>
<td>DECR</td>
<td>Decrement</td>
<td>减少</td>
</tr>
</tbody>
</table>
</div>
<p><strong>命令列表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>用法</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET / MGET</td>
<td>GET key / MGET key [key …]</td>
<td>返回给定 key 的值</td>
<td>不存在返回 nil</td>
</tr>
<tr>
<td>SET / MSET</td>
<td>SET key value / MSET key value [key value …]</td>
<td>设置给定 kv，存在则覆盖</td>
<td>SET key value [EX seconds] [PX milliseconds] [NX\</td>
<td>XX]</td>
</tr>
<tr>
<td>APPEND</td>
<td>APPEND key value</td>
<td>如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾</td>
<td>如 key 不存在，则直接将 key 设置为 value</td>
</tr>
<tr>
<td>SETEX / PSETEX</td>
<td>SETEX / PSETEX key time value</td>
<td>设置 秒/毫秒 级过期时间</td>
<td></td>
</tr>
<tr>
<td>SETNX / MSETNX</td>
<td>STENX key value / MSETNX key value</td>
<td>不存在指定 key 时，设置 value</td>
<td></td>
</tr>
<tr>
<td>GETSET</td>
<td>GETSET key value</td>
<td>返回给定 key 的旧值。 当 key 没有旧值时，即 key 不存在时，返回 nil</td>
<td></td>
</tr>
<tr>
<td>GETRANGE</td>
<td>GETRANGE key offset end</td>
<td>返回 key 中字符串值的子字符</td>
<td></td>
</tr>
<tr>
<td>SETRANGE</td>
<td>SETRANGE key offset end</td>
<td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</td>
<td></td>
</tr>
<tr>
<td>GETBIT</td>
<td>GETBIT key offset</td>
<td>对 key 所储存的字符串值，获取指定偏移量上的位(bit)</td>
<td></td>
</tr>
<tr>
<td>SETBIT</td>
<td>SETBIT key offset value</td>
<td>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)</td>
<td></td>
</tr>
<tr>
<td>INCR / DECR</td>
<td>INCR key / DECR key</td>
<td>将 key 中储存的数字值 加/减 一</td>
<td>如 key 不存在，则先初始化为 0，再进行计算操作</td>
</tr>
<tr>
<td>INCRBY / DECRBY</td>
<td>INCRBY key amount / DECR key amount</td>
<td>将 key 所储存的值 加/减 给定的值 amount</td>
<td></td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>INCRBYFLOAT key increment</td>
<td>将 key 所储存的值加上给定的浮点增量值（increment）</td>
<td></td>
</tr>
<tr>
<td>STRLEN</td>
<td>STRLEN key</td>
<td>返回 key 所储存的字符串值的长度</td>
</tr>
</tbody>
</table>
</div>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p><strong>关键字符解释</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>全拼</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>L</td>
<td>Left</td>
<td>列表头部</td>
</tr>
<tr>
<td>R</td>
<td>Right</td>
<td>列表尾部</td>
</tr>
<tr>
<td>B</td>
<td>Block</td>
<td>阻塞</td>
</tr>
<tr>
<td>REM</td>
<td>REMove</td>
<td>移除</td>
</tr>
</tbody>
</table>
</div>
<p><strong>命令列表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>用法</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>L PUSH/R PUSH</td>
<td>X key element [element …]</td>
<td>按照对应方向向列表 key 插入一个或多个值。</td>
<td>如果列表不存在，一个空列表会被创建并执行 X 操作。</td>
</tr>
<tr>
<td>L PUSH X/R PUSH X</td>
<td>X key element [element …]</td>
<td>按照对应方向向存在的列表 key 插入一个或多个值。</td>
<td>如果列表不存在，操作无效。</td>
</tr>
<tr>
<td>L POP/R POP</td>
<td>X key</td>
<td>按照对应方向对列表 key 移除并返回一个元素。</td>
<td>移除列表的最后一个元素时，也将空列表一并移除（即不能通过 LPUSHX 等命令添加元素）。</td>
</tr>
<tr>
<td>R POP L PUSH</td>
<td>RPOPLPUSH source destination</td>
<td>命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：将列表 source 中的最后一个元素（尾元素）弹出，并返回给客户端。将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。</td>
<td></td>
</tr>
<tr>
<td>B L POP/B R POP/B R POP L PUSH</td>
<td>X args timeout</td>
<td>以阻塞的方式调用命令，timeout(s) 为超时时间。</td>
<td>Timeout 为 0 代表无限期阻塞</td>
</tr>
<tr>
<td>L INDEX</td>
<td>LINDEX key index</td>
<td>通过索引获取列表中的元素。</td>
<td>索引从 0 开始</td>
</tr>
<tr>
<td>L RANGE</td>
<td>LRANGE key start end</td>
<td>返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。</td>
<td></td>
</tr>
<tr>
<td>L INSERT</td>
<td>LINSERT key  BEFORE\</td>
<td>AFTER exist_value insert_element</td>
<td>在列表的元素前或者后插入元素。</td>
<td></td>
</tr>
<tr>
<td>L SET</td>
<td>LSET key index value</td>
<td>通过索引设置列表元素的值。</td>
<td></td>
</tr>
<tr>
<td>L TRIM</td>
<td>LTRIM key start end</td>
<td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
<td></td>
</tr>
<tr>
<td>L REM</td>
<td>LREM key count value</td>
<td>移除 count 个与 value 值相同的列表元素。</td>
<td>count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。 <br />count &lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。<br />count = 0 : 移除表中所有与 VALUE 相等的值。</td>
</tr>
<tr>
<td>L LEN</td>
<td>LLEN key</td>
<td>返回列表 key 的长度。</td>
<td>如果 key 不存在，则 key 被解释为一个空列表，返回 0。</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p><strong>关键字符解释</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>全拼</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>Multiple</td>
<td>多重的</td>
</tr>
<tr>
<td>NX</td>
<td>Not already eXist</td>
<td>不存在时</td>
</tr>
<tr>
<td>INCR</td>
<td>INCRement</td>
<td>增加</td>
</tr>
</tbody>
</table>
</div>
<p><strong>命令列表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>用法</strong></th>
<th><strong>描述</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>H GET</td>
<td>HGET key field</td>
<td>获取哈希表中指定字段的值</td>
<td>如不存在则返回 nil</td>
</tr>
<tr>
<td>H M GET</td>
<td>HMGET key field [field…]</td>
<td>获取哈希表中所有给定字段的值</td>
<td>如某字段不存在，则返回 nil</td>
</tr>
<tr>
<td>H GET ALL</td>
<td>HGETALL key</td>
<td>获取哈希表中所有字段和值</td>
<td>若 key 不存在，返回空列表。</td>
</tr>
<tr>
<td>H KEYS</td>
<td>HKEYS key</td>
<td>获取所有哈希表中的字段</td>
<td></td>
</tr>
<tr>
<td>H VALS</td>
<td>HVAL key</td>
<td>获取哈希表中所有值</td>
<td></td>
</tr>
<tr>
<td>H SET</td>
<td>HSET key field value</td>
<td>将哈希表 key 中的字段 field 的值设为 value</td>
<td>不存在则创建，存在则覆盖。</td>
</tr>
<tr>
<td>H M SET</td>
<td>HMSET key field value [field value …]</td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中</td>
<td>不存在则创建，存在则覆盖。</td>
</tr>
<tr>
<td>H SET NX</td>
<td>HSETNX key field value</td>
<td>只有在字段 field 不存在时，设置哈希表字段的值</td>
<td></td>
</tr>
<tr>
<td>H DEL</td>
<td>HDEL key field [field…]</td>
<td>删除一个或多个哈希表字段</td>
<td></td>
</tr>
<tr>
<td>H EXISTS</td>
<td>HEXISTS key field</td>
<td>查看哈希表 key 中，指定的字段是否存在</td>
<td></td>
</tr>
<tr>
<td>H LEN</td>
<td>HLEN key</td>
<td>获取哈希表中字段的数量</td>
<td></td>
</tr>
<tr>
<td>H INCRBY</td>
<td>HINCRBY key field incr_by_number</td>
<td>为哈希表 key 中的指定字段的整数值加上增量 increment</td>
<td>本操作的值被限制在 64 位(bit)有符号数字表示之内。</td>
</tr>
<tr>
<td>H INCRBY FLOAT</td>
<td>HINCRBYFLOAT key field incr_by_number</td>
<td>为哈希表 key 中的指定字段的浮点数值加上增量 increment</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h1><p><strong>关键字符解释</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>全拼</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>REV</td>
<td>REVerse</td>
<td>逆序</td>
</tr>
<tr>
<td>REM</td>
<td>REMove</td>
<td>移除</td>
</tr>
<tr>
<td>LEX</td>
<td>LEXicographical order</td>
<td>字典序</td>
</tr>
</tbody>
</table>
</div>
<p><strong>命令列表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>用法</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Z ADD</td>
<td>ZADD key score value [score value …]</td>
<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
<td></td>
</tr>
<tr>
<td>Z SCORE</td>
<td>ZSCORE key member</td>
<td>返回有序集中，成员的分数值。</td>
<td>如果成员元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</td>
</tr>
<tr>
<td>Z CARD</td>
<td>ZCARD key</td>
<td>计算集合中元素的数量</td>
<td></td>
</tr>
<tr>
<td>Z COUNT</td>
<td>ZCOUNT key min max</td>
<td>计算有序集合中分数区间(min, max]的成员数量。</td>
<td>-inf 表示负无穷 float，+inf 表示正无穷 float</td>
</tr>
<tr>
<td>Z LEX COUNT</td>
<td>ZLEXCOUNT key min max</td>
<td>计算有序集合中指定字典区间内成员数量。</td>
<td>- 表示 string 最小成员，+ 表示 string 最大成员，[string 表示 string range item</td>
</tr>
<tr>
<td>Z RANGE/Z REV RANGE</td>
<td>ZRANGE/ZREVRANGE key start stop [WITHSCORES]</td>
<td>返回有序集中，指定区间内的成员。成员的位置按分数值递增(从小到大)来排序。具有相同分数值的成员按字典序(lexicographical order)来排列。ZREVRANGE 返回的是逆序。</td>
<td>以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</td>
</tr>
<tr>
<td>Z RANGE BY SCORE/Z REV RANGE BY SCORE</td>
<td>X key (min max/ max min) [WITHSCORES] [LIMIT offset count]</td>
<td>返回有序集中指定分数区间内的所有的成员。</td>
<td></td>
</tr>
<tr>
<td>Z RANGE BY LEX</td>
<td>ZRANGEBYLEX key min max [LIMIT offset count]</td>
<td>通过字典区间返回有序集合的成员。</td>
<td></td>
</tr>
<tr>
<td>Z RANK/Z REV RANK</td>
<td>ZRANK key member</td>
<td>返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。ZREVRANK 返回的是逆序排名。</td>
<td>与 index 相同，rank 也是从 0 开始计数的。</td>
</tr>
<tr>
<td>Z REM</td>
<td>ZREM key member</td>
<td>移除有序集中的一个或多个成员，不存在的成员将被忽略。</td>
<td></td>
</tr>
<tr>
<td>Z REM RANGE BY(RANK \</td>
<td>SCORE \</td>
<td>LEX)</td>
<td>X key start stop</td>
<td>移除有序集中，指定排名(rank)或分数(score)或字典(lexicographical)区间内的所有成员。</td>
<td>返回被移除成员的数量。</td>
</tr>
<tr>
<td>Z SCAN</td>
<td>ZSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>用于迭代有序集合中的元素（包括元素成员和元素分值）</td>
<td></td>
</tr>
<tr>
<td>Z INCRBY</td>
<td>ZINCRBY key increment member</td>
<td>对有序集合中指定成员的分数加上增量 increment（增量可为负数）。</td>
<td>当 key 不存在，或分数不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。</td>
</tr>
<tr>
<td>Z UNION STORE</td>
<td>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM\</td>
<td>MIN\</td>
<td>MAX]</td>
<td>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。</td>
<td>默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和 。</td>
</tr>
<tr>
<td>Z INTER STORE</td>
<td>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM\</td>
<td>MIN\</td>
<td>MAX]</td>
<td>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。</td>
<td>默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和。</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Pub-amp-Sub"><a href="#Pub-amp-Sub" class="headerlink" title="Pub &amp; Sub"></a>Pub &amp; Sub</h1><p><strong>关键字符解释</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>全拼</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>Pattern</td>
<td>模式（匹配模式）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>命令列表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">用法</th>
<th style="text-align:left">描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SUBSCRIBE</td>
<td style="text-align:left">SUBSCRIBE channel [channel …]</td>
<td style="text-align:left">订阅给定的一个或多个频道的信息</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">PSUBSCRIBE</td>
<td style="text-align:left">PSUBSCRIBE pattern [pattern …]</td>
<td style="text-align:left">订阅一个或多个符合给定模式的频道</td>
<td>* 作为匹配符</td>
</tr>
<tr>
<td style="text-align:left">UNSUBSCRIBE</td>
<td style="text-align:left">UNSUBSCRIBE [channel [channel …]]</td>
<td style="text-align:left">指退订给定的频道</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">PUNSUBSCRIBE</td>
<td style="text-align:left">PUNSUBSCRIBE [pattern [pattern …]]</td>
<td style="text-align:left">退订所有给定模式的频道</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">PUBLISH</td>
<td style="text-align:left">PUBLISH channel message</td>
<td style="text-align:left">将信息发送到指定的频道</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">PUBSUB</td>
<td style="text-align:left">PUBSUB subcommand [argument [argument …]]</td>
<td style="text-align:left">查看订阅与发布系统状态</td>
<td>subcommand：<br />CHANNELS [pattern] 列出当前的活跃频道。<br />NUMSUB [channel-1 … channel-N] 返回给定频道的订阅者数量。<br />NUMPAT 返回订阅模式的数量。</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构 Stream 是一个新的强大的支持多播的可持久化的消息队列，主要借鉴了 Kafka 的设计。</p>
<p><img src="/images/Redis/RedisStream.png" alt=""></p>
<p>Redis Stream 的结构如上图所示，它有一个消息链表，序列化储存所有加入的消息，每个消息都有一个唯一的 ID 并且会被持久化。</p>
<p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 XADD 指令追加消息时自动创建。</p>
<p>每个 Stream 都可以挂多个消费组（Consumer Group），每个消费组会有个游标 last_delivered_id 在 Stream 数组之上往前移动，表示当前消费组已经消费到哪条消息了。每个消费组都有一个 Stream 内唯一的名称，消费组不会自动创建，它需要单独的指令 XGROUP CREATE 进行创建，需要指定从 Stream 的某个消息 ID 开始消费，这个 ID 用来初始化 last_delivered_id 变量。</p>
<p>每个消费组的状态都是独立的，相互不受影响。也就是说同一份 Stream 内部的消息会被每个消费组都消费到。</p>
<p>同一个消费组可以挂接多个消费者（Consumer），这些消费者之间是竞争关系，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。每个消费者者有一个组内唯一名称。</p>
<p>消费者内部会有个状态变量 pending_ids，它记录了当前已经被客户端读取的消息，但是还没有 ack（类似 XACK）。如果客户端没有 ack，这个变量里面的消息ID会越来越多，一旦某个消息被 ack，它就开始减少。这个 pending_ids 变量在 Redis 官方被称之为 PEL，也就是 Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</p>
<p>如果该消息已经发送给该消费者，并且它只是再次重新获取相同的消息，那么<em>最后送达时间</em>会被更新为当前时间，并且<em>送达次数</em>会加1。你可以使用<code>XPENDING</code>命令访问这些消息属性。</p>
<h2 id="消息ID和内容"><a href="#消息ID和内容" class="headerlink" title="消息ID和内容"></a>消息ID和内容</h2><p>消息 ID 的形式是 TimestampInMillis-Sequence，例如 1527846880572-5，它表示当前的消息在毫米时间戳 1527846880572 时产生，并且是该毫秒内产生的第 5 条消息。消息 ID 可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是整数-整数，而且必须是后面加入的消息的 ID 要大于前面的消息 ID 。</p>
<p>消息内容就是键值对，形如 hash 结构的键值对。</p>
<h2 id="消息队列相关命令"><a href="#消息队列相关命令" class="headerlink" title="消息队列相关命令"></a>消息队列相关命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>用法</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>X ADD</td>
<td>XADD key ID field value [field value …] [MAXLEN\</td>
<td>MINID [=\</td>
<td>~] threshold [LIMIT count]] *\</td>
<td>ID</td>
<td>添加消息到末尾，保证有序。</td>
<td>* 可以自动生成唯一ID。<br />~ 代表大约（大于等于）LIMIT count。</td>
</tr>
<tr>
<td>X TRIM</td>
<td>XTRIM key MAXLEN\</td>
<td>MINID [=\</td>
<td>~] threshold [LIMIT count]</td>
<td>对流进行修剪，限制长度，必要时丢弃 ID 旧的数据。</td>
<td>threshold [LIMIT count] 即限制队列的长度。</td>
</tr>
<tr>
<td>X DEL</td>
<td>XDEL key ID [ID …]</td>
<td>删除消息</td>
<td></td>
</tr>
<tr>
<td>X LEN</td>
<td>XLEN key</td>
<td>获取流包含的元素数量，即消息长度</td>
<td></td>
</tr>
<tr>
<td>X RANGE/X REV RANGE</td>
<td>XRANGE key start end [COUNT count]</td>
<td>返回流中满足给定ID范围的条目。范围由最小和最大ID指定。所有ID在指定的两个ID之间或与其中一个ID相等（闭合区间）的条目将会被返回。该命令会自动过滤已经删除的消息。</td>
<td>start, end 中 -,+ 可代表流中最小、最大 ID。当然，start 和 end 为同一个 ID 可视作单条查询、</td>
</tr>
<tr>
<td>X READ</td>
<td>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key …] ID [ID …]</td>
<td>以阻塞或非阻塞方式获取消息列表（对于每个 Stream 只获取 count 个大于给定 ID 的消息）。count 默认为 1。</td>
<td>示例：XREAD STREAMS key $</td>
</tr>
<tr>
<td>X ACK</td>
<td>XACK key group ID [ID …]</td>
<td>将消息标记为”已处理”</td>
<td>该命令返回成功确认的消息数。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="消费者组相关命令"><a href="#消费者组相关命令" class="headerlink" title="消费者组相关命令"></a>消费者组相关命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>用法</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>X GROUP CREATE</td>
<td>XGROUP CREATE key groupname ID\</td>
<td>$</td>
<td>创建与流关联的新消费者组。如果指定的消费者组已经存在，则该命令将返回-BUSYGROUP错误。 否则将执行该操作并返回OK。你可以为给定的流关联无限多的消费者组，没有硬性限制。</td>
<td>最后一个参数是指定消费者的最后交付 ID（下次读取 ID 大于最后交付 ID 的第一个消息），$ 是指读取后到达流的新数据，0 是指从流中第一条消息开始读取。当然也可以直接设置 ID 作为参数。</td>
</tr>
<tr>
<td>X GROUP DESTORY</td>
<td>XGROUP DESTROY key groupname</td>
<td>删除消费者组。即使存在活动的消费者和待处理消息，消费者组也将被销毁，因此请确保仅在真正需要时才调用此命令。</td>
<td>每当某个命令提到新的消费者名称时，就会自动创建消费者组中的消费者。 但有时候删除旧的消费者可能会有用，因为他们已经不再使用。 以上格式的命令返回消费者在被删除之前所拥有的待处理消息数量。</td>
</tr>
<tr>
<td>X GROUP DEL CONSUMER</td>
<td>XGROUP DELCONSUMER key groupname consumer</td>
<td>删除指定消费者</td>
<td></td>
</tr>
<tr>
<td>X GROUP SETID</td>
<td>XGROUP SETID key groupname ID\</td>
<td>$</td>
<td>为消费者组设置新的最后递送消息 ID</td>
<td></td>
</tr>
<tr>
<td>X INFO STREAM</td>
<td>XINFO STREAM key</td>
<td>返回有关存储在特定键的流的一般信息。</td>
<td></td>
</tr>
<tr>
<td>X INFO GROUPS</td>
<td>XINFO GROUPS key</td>
<td>获取流的消费者组的信息</td>
<td></td>
</tr>
<tr>
<td>X INFO CONSUMERS</td>
<td>XINFO CONSUMERS key groupname</td>
<td>取得指定消费者组中的消费者列表</td>
<td></td>
</tr>
<tr>
<td>X PENDING</td>
<td>XPENDING key group [[IDLE min-idle-time] start end count [consumer]]</td>
<td>显示待处理消息的相关信息</td>
<td></td>
</tr>
<tr>
<td>X READ GROUP</td>
<td>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key …] ID [ID …]</td>
<td>读取消费者组中大于指定 ID 的消息，并将 id 放入 pending_ids 中，等待 XACK 确认。</td>
<td>可以通过给XREADGROUP初始 ID 为 0 并执行相同的循环来访问我们的消息历史。 一旦提供的 ID 为 0 并且回复是一组空的消息，我们就知道我们已经处理并确认完了所有的待处理消息。使用&gt;作为ID，以便获取新消息并重新加入正在处理新消息的消费者。</td>
</tr>
<tr>
<td>X CLAIM</td>
<td>XCLAIM key group consumer min-idle-time ID [ID …] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [FORCE] [JUSTID]</td>
<td>在流的消费者组上下文中，改变待处理消息的所有权，并等待 XACK 确认。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="需要注意的特性"><a href="#需要注意的特性" class="headerlink" title="需要注意的特性"></a>需要注意的特性</h2><h3 id="从永久性失败中恢复的特性"><a href="#从永久性失败中恢复的特性" class="headerlink" title="从永久性失败中恢复的特性"></a>从永久性失败中恢复的特性</h3><p>Redis 消息队列解决方案中，编写多个消费者参与同一个消费者组，每个消费者获取消息的一个子集进行处理，并且在故障恢复时重新读取各自的待处理消息。然而在现实世界中，消费者有可能永久地失败并且永远无法恢复，因此消费者的待处理消息会永远无法处理掉。</p>
<p>Redis 的消费者组提供了一个专门针对这种场景的特性，使用 <strong>XPENDING</strong> 和 <strong>XCLAIM</strong> 命令用以认领给定消费者的待处理消息。这个特性是非常明确的，消费者在检查待处理消息列表后，认领待处理的消息，否则服务器将把待处理的消息永久分配给旧消费者。这样不同的应用程序就可以选择是否使用这样的特性，以及使用它的方式。</p>
<p><strong>1. 提供可观察性</strong></p>
<p>第一步是使用 <strong>XPENDING</strong> 命令，提供消费者组中待处理条目的可观察性。</p>
<pre class="line-numbers language-none"><code class="language-none">&gt; XPENDING mystream mygroup
1) (integer) 2  # 给定消费者组的待处理消息总数
2) 1526569498055-0 # 所有待处理消息中的最小ID
3) 1526569506935-0 # 所有待处理消息中的最大ID
4) 1) 1) &quot;Bob&quot; # 消费者列表和每个消费者的待处理消息数量
      2) &quot;2&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们有了每一条消息的详细信息：消息ID，消费者名称，<em>空闲时间</em>（单位是毫秒，意思是：自上次将消息传递给某个消费者以来经过了多少毫秒），以及每一条给定的消息被传递了多少次。</p>
<p><strong>2. 认领待处理消息</strong></p>
<p>第二步是使用 <strong>XCLAIM</strong> 命令，用于复制消费者组的更改。</p>
<pre class="line-numbers language-none"><code class="language-none">XCLAIM &lt;key&gt; &lt;group&gt; &lt;consumer&gt; &lt;min-idle-time&gt; &lt;ID-1&gt; &lt;ID-2&gt; ... &lt;ID-N&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当我们认领指定 ID 的消息，仅当消息闲置至少 min-idle-time 且没有原始消费者或其他消费者进行推进（确认或认领它）时，并将所有权分配给消费者 consumer。</p>
<p>Redis 提供了最小空闲时间，只有在上述消息的空闲时间大于指定的空闲时间时，操作才会起作用。这很有用，因为有可能两个客户端会同时尝试认领一条消息：</p>
<pre class="line-numbers language-none"><code class="language-none">Client 1: XCLAIM mystream mygroup Alice 3600000 1526569498055-0
Clinet 2: XCLAIM mystream mygroup Lora 3600000 1526569498055-0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然而认领一条消息的副作用是会重置它的闲置时间！并将增加其传递次数的计数器，所以上面第二个客户端的认领会失败。通过这种方式，我们可以避免对消息进行简单的重新处理（即使是在一般情况下，你仍然不能获得准确的一次处理）。</p>
<p>下面是命令执行的结果：</p>
<pre class="line-numbers language-none"><code class="language-none">&gt; XCLAIM mystream mygroup Alice 3600000 1526569498055-0
1) 1) 1526569498055-0
   2) 1) &quot;message&quot;
      2) &quot;orange&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Alice 成功认领了该消息，现在可以处理并确认消息，尽管原来的消费者还没有恢复，也能往前推动。</p>
<p>从上面的例子很明显能看到，作为成功认领了指定消息的副作用，<strong>XCLAIM</strong> 命令也返回了消息数据本身。但这不是强制性的。可以使用 <strong>JUSTID</strong> 选项，以便仅返回成功认领的消息的 ID。如果你想减少客户端和服务器之间的带宽使用量的话，以及考虑命令的性能，这会很有用，并且你不会对消息感兴趣，因为稍后你的消费者的实现方式将不时地重新扫描历史待处理消息。</p>
<p>认领也可以通过一个独立的进程来实现：这个进程只负责检查待处理消息列表，并将空闲的消息分配给看似活跃的消费者。可以通过 Redis Stream 的可观察特性获得活跃的消费者。</p>
<p><strong>3. 其他故障处理</strong></p>
<p>在 <strong>XPENDING</strong> 的输出中，你所看到的计数器是每一条消息的交付次数。这样的计数器以两种方式递增：消息通过 <strong>XCLAIM</strong> 成功认领时，或者调用 <strong>XREADGROUP</strong> 访问历史待处理消息时。</p>
<p>当出现故障时，消息被多次传递是很正常的，但最终它们通常会得到处理。但有时候处理特定的消息会出现问题，因为消息会以触发处理代码中的 bug 的方式被损坏或修改。在这种情况下，消费者处理这条特殊的消息会一直失败。因为我们有传递尝试的计数器，所以我们可以使用这个计数器来检测由于某些原因根本无法处理的消息。所以一旦消息的传递计数器达到你给定的值，比较明智的做法是将这些消息放入另外一个 Stream，并给系统管理员发送一条通知。这基本上是 Redis Stream 实现的 dead letter 概念的方式。</p>
<h3 id="与-Kafka-分区机制的区别"><a href="#与-Kafka-分区机制的区别" class="headerlink" title="与 Kafka 分区机制的区别"></a>与 Kafka 分区机制的区别</h3><p>Kafka 将数据分成了多个 partition ，在不同的节点中保存。Redis 的 Stream 数据结构只是一个 key，其中的数据分区需要配合其他中间件实现。</p>
<h3 id="持久化，复制和消息安全性"><a href="#持久化，复制和消息安全性" class="headerlink" title="持久化，复制和消息安全性"></a>持久化，复制和消息安全性</h3><p>与任何其他 Redis 数据结构一样，Stream会异步复制到从节点，并持久化到 AOF 和 RDB 文件中。但可能不那么明显的是，消费者组的完整状态也会传输到 AOF，RDB 和从节点，因此如果消息在主节点是待处理的状态，在从节点也会是相同的信息。同样，节点重启后，AOF 文件会恢复消费者组的状态。</p>
<p>但是请注意，Redis Stream 和消费者组使用 Redis 默认复制来进行持久化和复制，所以：</p>
<ul>
<li>如果消息的持久性在您的应用程序中很重要，则 AOF 必须与强大的 fsync 策略一起使用。</li>
<li>默认情况下，异步复制不能保证复制 XADD 命令或者消费者组的状态更改：在故障转移后，可能会丢失某些内容，具体取决于从节点从主节点接收数据的能力。</li>
<li>WAIT 命令可以用于强制将更改传输到一组从节点上。但请注意，虽然这使得数据不太可能丢失，但由 Sentinel 或 Redis 集群运行的 Redis 故障转移过程仅执行尽力检查以故障转移到最新的从节点，并且在某些特定故障下可能会选举出缺少一些数据的从节点。 因此，在使用 Redis Stream 和消费者组设计应用程序时，确保了解你的应用程序在故障期间应具有的语义属性，并进行相应地配置，评估它是否足够安全地用于您的用例。</li>
</ul>
<h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><h2 id="Redis-键-key-命令"><a href="#Redis-键-key-命令" class="headerlink" title="Redis 键(key) 命令"></a>Redis 键(key) 命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3543.html">Redis Type 命令</a></td>
<td style="text-align:left">返回 key 所储存的值的类型。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3533.html">Redis PEXPIREAT 命令</a></td>
<td style="text-align:left">设置 key 的过期时间亿以毫秒计。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3534.html">Redis PEXPIREAT 命令</a></td>
<td style="text-align:left">设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3541.html">Redis Rename 命令</a></td>
<td style="text-align:left">修改 key 的名称</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3537.html">Redis PERSIST 命令</a></td>
<td style="text-align:left">移除 key 的过期时间，key 将持久保持。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3536.html">Redis Move 命令</a></td>
<td style="text-align:left">将当前数据库的 key 移动到给定的数据库 db 当中。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3540.html">Redis RANDOMKEY 命令</a></td>
<td style="text-align:left">从当前数据库中随机返回一个 key 。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3529.html">Redis Dump 命令</a></td>
<td style="text-align:left">序列化给定 key ，并返回被序列化的值。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3539.html">Redis TTL 命令</a></td>
<td style="text-align:left">以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3531.html">Redis Expire 命令</a></td>
<td style="text-align:left">seconds 为给定 key 设置过期时间。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3528.html">Redis DEL 命令</a></td>
<td style="text-align:left">该命令用于在 key 存在是删除 key。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3538.html">Redis Pttl 命令</a></td>
<td style="text-align:left">以毫秒为单位返回 key 的剩余的过期时间。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3542.html">Redis Renamenx 命令</a></td>
<td style="text-align:left">仅当 newkey 不存在时，将 key 改名为 newkey 。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3530.html">Redis EXISTS 命令</a></td>
<td style="text-align:left">检查给定 key 是否存在。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3532.html">Redis Expireat 命令</a></td>
<td style="text-align:left">EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3535.html">Redis Keys 命令</a></td>
<td style="text-align:left">查找所有符合给定模式( pattern)的 key 。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Redis-集合-Set-命令"><a href="#Redis-集合-Set-命令" class="headerlink" title="Redis 集合(Set) 命令"></a>Redis 集合(Set) 命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3606.html">Redis Sunion 命令</a></td>
<td style="text-align:left">返回所有给定集合的并集</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3595.html">Redis Scard 命令</a></td>
<td style="text-align:left">获取集合的成员数</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3604.html">Redis Srandmember 命令</a></td>
<td style="text-align:left">返回集合中一个或多个随机数</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3601.html">Redis Smembers 命令</a></td>
<td style="text-align:left">返回集合中的所有成员</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3598.html">Redis Sinter 命令</a></td>
<td style="text-align:left">返回给定所有集合的交集</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3605.html">Redis Srem 命令</a></td>
<td style="text-align:left">移除集合中一个或多个成员</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3602.html">Redis Smove 命令</a></td>
<td style="text-align:left">将 member 元素从 source 集合移动到 destination 集合</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3594.html">Redis Sadd 命令</a></td>
<td style="text-align:left">向集合添加一个或多个成员</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3600.html">Redis Sismember 命令</a></td>
<td style="text-align:left">判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3597.html">Redis Sdiffstore 命令</a></td>
<td style="text-align:left">返回给定所有集合的差集并存储在 destination 中</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3596.html">Redis Sdiff 命令</a></td>
<td style="text-align:left">返回给定所有集合的差集</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3608.html">Redis Sscan 命令</a></td>
<td style="text-align:left">迭代集合中的元素</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3599.html">Redis Sinterstore 命令</a></td>
<td style="text-align:left">返回给定所有集合的交集并存储在 destination 中</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3607.html">Redis Sunionstore 命令</a></td>
<td style="text-align:left">所有给定集合的并集存储在 destination 集合中</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3603.html">Redis Spop 命令</a></td>
<td style="text-align:left">移除并返回集合中的一个随机元素</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Redis-连接-命令"><a href="#Redis-连接-命令" class="headerlink" title="Redis 连接 命令"></a>Redis 连接 命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3650.html">Redis Echo 命令</a></td>
<td style="text-align:left">打印字符串</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3653.html">Redis Select 命令</a></td>
<td style="text-align:left">切换到指定的数据库</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3651.html">Redis Ping 命令</a></td>
<td style="text-align:left">查看服务是否运行</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3652.html">Redis Quit 命令</a></td>
<td style="text-align:left">关闭当前连接</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3649.html">Redis Auth 命令</a></td>
<td style="text-align:left">验证密码是否正确</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Redis-服务器-命令"><a href="#Redis-服务器-命令" class="headerlink" title="Redis 服务器 命令"></a>Redis 服务器 命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3659.html">Redis Client Pause 命令</a></td>
<td style="text-align:left">在指定时间内终止运行来自客户端的命令</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3672.html">Redis Debug Object 命令</a></td>
<td style="text-align:left">获取 key 的调试信息</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3675.html">Redis Flushdb 命令</a></td>
<td style="text-align:left">删除当前数据库的所有key</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3680.html">Redis Save 命令</a></td>
<td style="text-align:left">异步保存数据到硬盘</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3683.html">Redis Showlog 命令</a></td>
<td style="text-align:left">管理 redis 的慢日志</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3677.html">Redis Lastsave 命令</a></td>
<td style="text-align:left">返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3667.html">Redis Config Get 命令</a></td>
<td style="text-align:left">获取指定配置参数的值</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3662.html">Redis Command 命令</a></td>
<td style="text-align:left">获取 Redis 命令详情数组</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3682.html">Redis Slaveof 命令</a></td>
<td style="text-align:left">将当前服务器转变为指定服务器的从属服务器(slave server)</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3673.html">Redis Debug Segfault 命令</a></td>
<td style="text-align:left">让 Redis 服务崩溃</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3674.html">Redis Flushall 命令</a></td>
<td style="text-align:left">删除所有数据库的所有key</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3671.html">Redis Dbsize 命令</a></td>
<td style="text-align:left">返回当前数据库的 key 的数量</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3654.html">Redis Bgrewriteaof 命令</a></td>
<td style="text-align:left">异步执行一个 AOF（AppendOnly File） 文件重写操作</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3661.html">Redis Cluster Slots 命令</a></td>
<td style="text-align:left">获取集群节点的映射数组</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3669.html">Redis Config Set 命令</a></td>
<td style="text-align:left">修改 redis 配置参数，无需重启</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3666.html">Redis Command Info 命令</a></td>
<td style="text-align:left">获取指定 Redis 命令描述的数组</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3681.html">Redis Shutdown 命令</a></td>
<td style="text-align:left">异步保存数据到硬盘，并关闭服务器</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3684.html">Redis Sync 命令</a></td>
<td style="text-align:left">用于复制功能(replication)的内部命令</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3656.html">Redis Client Kill 命令</a></td>
<td style="text-align:left">关闭客户端连接</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3679.html">Redis Role 命令</a></td>
<td style="text-align:left">返回主从实例所属的角色</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3678.html">Redis Monitor 命令</a></td>
<td style="text-align:left">实时打印出 Redis 服务器接收到的命令，调试用</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3664.html">Redis Command Getkeys 命令</a></td>
<td style="text-align:left">获取给定命令的所有键</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3658.html">Redis Client Getname 命令</a></td>
<td style="text-align:left">获取连接的名称</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3670.html">Redis Config Resetstat 命令</a></td>
<td style="text-align:left">重置 INFO 命令中的某些统计数据</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3663.html">Redis Command Count 命令</a></td>
<td style="text-align:left">获取 Redis 命令总数</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3665.html">Redis Time 命令</a></td>
<td style="text-align:left">返回当前服务器时间</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3676.html">Redis Info 命令</a></td>
<td style="text-align:left">获取 Redis 服务器的各种信息和统计数值</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3668.html">Redis Config rewrite 命令</a></td>
<td style="text-align:left">对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3657.html">Redis Client List 命令</a></td>
<td style="text-align:left">获取连接到服务器的客户端连接列表</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3660.html">Redis Client Setname 命令</a></td>
<td style="text-align:left">设置当前连接的名称</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3655.html">Redis Bgsave 命令</a></td>
<td style="text-align:left">在后台异步保存当前数据库的数据到磁盘</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Redis-脚本-命令"><a href="#Redis-脚本-命令" class="headerlink" title="Redis 脚本 命令"></a>Redis 脚本 命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3647.html">Redis Script kill 命令</a></td>
<td style="text-align:left">杀死当前正在运行的 Lua 脚本。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3648.html">Redis Script Load 命令</a></td>
<td style="text-align:left">将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3643.html">Redis Eval 命令</a></td>
<td style="text-align:left">执行 Lua 脚本。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3644.html">Redis Evalsha 命令</a></td>
<td style="text-align:left">执行 Lua 脚本。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3645.html">Redis Script Exists 命令</a></td>
<td style="text-align:left">查看指定的脚本是否已经被保存在缓存当中。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3646.html">Redis Script Flush 命令</a></td>
<td style="text-align:left">从脚本缓存中移除所有脚本。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Redis-事务-命令"><a href="#Redis-事务-命令" class="headerlink" title="Redis 事务 命令"></a>Redis 事务 命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3639.html">Redis Exec 命令</a></td>
<td style="text-align:left">执行所有事务块内的命令。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3642.html">Redis Watch 命令</a></td>
<td style="text-align:left">监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3638.html">Redis Discard 命令</a></td>
<td style="text-align:left">取消事务，放弃执行事务块内的所有命令。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3641.html">Redis Unwatch 命令</a></td>
<td style="text-align:left">取消 WATCH 命令对所有 key 的监视。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3640.html">Redis Multi 命令</a></td>
<td style="text-align:left">标记一个事务块的开始。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Redis-HyperLogLog-命令"><a href="#Redis-HyperLogLog-命令" class="headerlink" title="Redis HyperLogLog 命令"></a>Redis HyperLogLog 命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3631.html">Redis Pgmerge 命令</a></td>
<td style="text-align:left">将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3629.html">Redis Pfadd 命令</a></td>
<td style="text-align:left">添加指定元素到 HyperLogLog 中。</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3630.html">Redis Pfcount 命令</a></td>
<td style="text-align:left">返回给定 HyperLogLog 的基数估算值。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Redis-地理位置-geo-命令"><a href="#Redis-地理位置-geo-命令" class="headerlink" title="Redis 地理位置(geo) 命令"></a>Redis 地理位置(geo) 命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3687.html">Redis GEOHASH 命令</a></td>
<td style="text-align:left">返回一个或多个位置元素的 Geohash 表示</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3688.html">Redis GEOPOS 命令</a></td>
<td style="text-align:left">从key里返回所有给定位置元素的位置（经度和纬度）</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3686.html">Redis GEODIST 命令</a></td>
<td style="text-align:left">返回两个给定位置之间的距离</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3689.html">Redis GEORADIUS 命令</a></td>
<td style="text-align:left">以给定的经纬度为中心， 找出某一半径内的元素</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3685.html">Redis GEOADD 命令</a></td>
<td style="text-align:left">将指定的地理空间位置（纬度、经度、名称）添加到指定的key中</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://www.redis.net.cn/order/3690.html">Redis GEORADIUSBYMEMBER 命令</a></td>
<td style="text-align:left">找出位于指定范围内的元素，中心点是由给定的位置元素决定</td>
</tr>
</tbody>
</table>
</div>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Command/" rel="tag"># Command</a>
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/28/Math-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" rel="prev" title="Math 加密算法">
      <i class="fa fa-chevron-left"></i> Math 加密算法
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/21/Redis-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" rel="next" title="Redis 典型应用场景">
      Redis 典型应用场景 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#String"><span class="nav-number">1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#List"><span class="nav-number">2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hash"><span class="nav-number">3.</span> <span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Sorted-Set"><span class="nav-number">4.</span> <span class="nav-text">Sorted Set</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pub-amp-Sub"><span class="nav-number">5.</span> <span class="nav-text">Pub &amp; Sub</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Stream"><span class="nav-number">6.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AFID%E5%92%8C%E5%86%85%E5%AE%B9"><span class="nav-number">6.2.</span> <span class="nav-text">消息ID和内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">6.3.</span> <span class="nav-text">消息队列相关命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">6.4.</span> <span class="nav-text">消费者组相关命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">6.5.</span> <span class="nav-text">需要注意的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%B0%B8%E4%B9%85%E6%80%A7%E5%A4%B1%E8%B4%A5%E4%B8%AD%E6%81%A2%E5%A4%8D%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">6.5.1.</span> <span class="nav-text">从永久性失败中恢复的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E-Kafka-%E5%88%86%E5%8C%BA%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.5.2.</span> <span class="nav-text">与 Kafka 分区机制的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%8C%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B6%88%E6%81%AF%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">6.5.3.</span> <span class="nav-text">持久化，复制和消息安全性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="nav-number">7.</span> <span class="nav-text">其他命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E9%94%AE-key-%E5%91%BD%E4%BB%A4"><span class="nav-number">7.1.</span> <span class="nav-text">Redis 键(key) 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E9%9B%86%E5%90%88-Set-%E5%91%BD%E4%BB%A4"><span class="nav-number">7.2.</span> <span class="nav-text">Redis 集合(Set) 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E8%BF%9E%E6%8E%A5-%E5%91%BD%E4%BB%A4"><span class="nav-number">7.3.</span> <span class="nav-text">Redis 连接 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%91%BD%E4%BB%A4"><span class="nav-number">7.4.</span> <span class="nav-text">Redis 服务器 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E8%84%9A%E6%9C%AC-%E5%91%BD%E4%BB%A4"><span class="nav-number">7.5.</span> <span class="nav-text">Redis 脚本 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E4%BA%8B%E5%8A%A1-%E5%91%BD%E4%BB%A4"><span class="nav-number">7.6.</span> <span class="nav-text">Redis 事务 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-HyperLogLog-%E5%91%BD%E4%BB%A4"><span class="nav-number">7.7.</span> <span class="nav-text">Redis HyperLogLog 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE-geo-%E5%91%BD%E4%BB%A4"><span class="nav-number">7.8.</span> <span class="nav-text">Redis 地理位置(geo) 命令</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang Zihao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">143</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">286</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Zihao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
