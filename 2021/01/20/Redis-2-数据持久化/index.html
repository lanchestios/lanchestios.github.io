<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Redis 是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将 Redis 中的数据以数据或命令的形式从内存保存到本地磁盘。当下次 Redis 重启时，利用持久化文件进行数据恢复。Redis 提供了 RDB 和 AOF 两种持久化机制，前者将当前的数据保存到磁盘，后者则是将每次执行的写命令保存到磁盘（类似于 MySQL 的 Binlog）。本文将详细介绍 RDB 和">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 数据持久化">
<meta property="og:url" content="http://example.com/2021/01/20/Redis-2-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/index.html">
<meta property="og:site_name" content="Lanchester Blog">
<meta property="og:description" content="Redis 是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将 Redis 中的数据以数据或命令的形式从内存保存到本地磁盘。当下次 Redis 重启时，利用持久化文件进行数据恢复。Redis 提供了 RDB 和 AOF 两种持久化机制，前者将当前的数据保存到磁盘，后者则是将每次执行的写命令保存到磁盘（类似于 MySQL 的 Binlog）。本文将详细介绍 RDB 和">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/Redis/redis数据库结构.png">
<meta property="og:image" content="http://example.com/images/Redis/redis数据库结构2.png">
<meta property="og:image" content="http://example.com/images/Redis/RDB持久化过程.png">
<meta property="og:image" content="http://example.com/images/Redis/RDB持久化BGSAVE方式.png">
<meta property="og:image" content="http://example.com/images/Redis/Redis自动载入配置.png">
<meta property="og:image" content="http://example.com/images/Redis/RDB文件结构.png">
<meta property="og:image" content="http://example.com/images/Redis/RDB文件键值对.png">
<meta property="og:image" content="http://example.com/images/Redis/AOF持久化过程.png">
<meta property="og:image" content="http://example.com/images/Redis/AOF文件结构.png">
<meta property="og:image" content="http://example.com/images/Redis/AOF载入流程.png">
<meta property="og:image" content="http://example.com/images/Redis/AOF执行流程.png">
<meta property="og:image" content="http://example.com/images/Redis/AOF文件重写流程.png">
<meta property="og:image" content="http://example.com/images/Redis/RDB-AOF混合策略持久化.png">
<meta property="article:published_time" content="2021-01-20T13:33:49.000Z">
<meta property="article:modified_time" content="2023-05-22T09:38:45.647Z">
<meta property="article:author" content="Wang Zihao">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="RDB">
<meta property="article:tag" content="AOF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Redis/redis数据库结构.png">

<link rel="canonical" href="http://example.com/2021/01/20/Redis-2-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Redis 数据持久化 | Lanchester Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lanchester Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Leave a leaf</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/20/Redis-2-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Zihao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lanchester Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis 数据持久化
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-20 21:33:49" itemprop="dateCreated datePublished" datetime="2021-01-20T21:33:49+08:00">2021-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-22 17:38:45" itemprop="dateModified" datetime="2023-05-22T17:38:45+08:00">2023-05-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Redis 是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将 Redis 中的数据以数据或命令的形式从内存保存到本地磁盘。当下次 Redis 重启时，利用持久化文件进行数据恢复。Redis 提供了 RDB 和 AOF 两种持久化机制，前者将当前的数据保存到磁盘，后者则是将每次执行的写命令保存到磁盘（类似于 MySQL 的 Binlog）。本文将详细介绍 RDB 和 AOF 两种持久化方案，包括操作方法和持久化的实现原理。</p>
<span id="more"></span>
<h1 id="Redis数据库结构"><a href="#Redis数据库结构" class="headerlink" title="Redis数据库结构"></a>Redis数据库结构</h1><p>Redis 是一个基于键值对（K-V）存储的数据库服务器，一个单机的 Redis 服务器默认情况下有 16 个数据库（0-15 号），数据库的个数是可配置的。Redis 默认使用的是 0 号数据库，可以使用 SELECT 命令切换数据库。</p>
<p><img src="/images/Redis/redis数据库结构.png" alt=""></p>
<p>Redis 中的每个数据库都由一个 redis.h/redisDb 结构表示，它记录了单个 Redis 数据库的键空间、所有键的过期时间、处于阻塞状态和就绪状态的键、数据库编号等等。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 数据库键空间，保存着数据库中的所有键值对</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
    <span class="token comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span>
    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span>
    <span class="token comment">// 正处于阻塞状态的键</span>
    dict <span class="token operator">*</span>blocking_keys<span class="token punctuation">;</span>
    <span class="token comment">// 可以解除阻塞的键</span>
    dict <span class="token operator">*</span>ready_keys<span class="token punctuation">;</span>
    <span class="token comment">// 正在被 WATCH 命令监视的键</span>
    dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">evictionPoolEntry</span> <span class="token operator">*</span>eviction_pool<span class="token punctuation">;</span>
    <span class="token comment">// 数据库编号</span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token comment">// 数据库的键的平均 TTL，统计信息</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> avg_ttl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于 Redis 是一个键值对数据库（key-value pairs database）， 所以它的数据库本身也是一个字典，对应的结构正是 redisDb。其中，dict 指向的是一个记录键值对数据的字典，它的键是一个字符串对象，它的值则可以是字符串、列表、哈希表、集合和有序集合在内的任意一种 Redis 类型对象。 expires 指向的是一个用于记录键的过期时间的字典，它的键为 dict 中的数据库键，它的值为这个数据库键的过期时间戳，这个值以 long long 类型表示。</p>
<p><img src="/images/Redis/redis数据库结构2.png" alt=""></p>
<h2 id="对数据库键的增删改查"><a href="#对数据库键的增删改查" class="headerlink" title="对数据库键的增删改查"></a>对数据库键的增删改查</h2><p>与正常集合操作相同</p>
<h2 id="对过期键的删除策略"><a href="#对过期键的删除策略" class="headerlink" title="对过期键的删除策略"></a>对过期键的删除策略</h2><p>数据库键的过期时间都保存在过期字典中，当键过期后有三种不同的策略：</p>
<ol>
<li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），过期立即删除。</li>
<li>惰性删除：当从键空间中获取键时，根据取得的键是否过期，来判断是删除还是返回。</li>
<li>定期删除：每隔一段时间，程序就对数据库进行一次检査，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>
</ol>
<p><strong>三种策略优缺点对比</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>删除策略</th>
<th>内存</th>
<th>CPU</th>
</tr>
</thead>
<tbody>
<tr>
<td>定时删除</td>
<td>键及时删除、释放内存</td>
<td>占用CPU，影响服务器的响应时间和吞吐量</td>
</tr>
<tr>
<td>惰性删除</td>
<td>可能会导致键不释放，无限制的占用内存</td>
<td>几乎不占用CPU</td>
</tr>
<tr>
<td>定期删除</td>
<td>周期性删除过期键有效地减少了因为过期键而带来的内存浪费</td>
<td>周期性删除过期键，限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响</td>
</tr>
</tbody>
</table>
</div>
<p>定期删除策略可以说是前两种策略的折中，它的难点是确定删除操作执行的时长和频率：</p>
<ul>
<li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面</li>
<li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</li>
</ul>
<h2 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h2><h3 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h3><p>在执行 SAVE 命令或者 BGSAVE 命令创建一个新的 RDB 文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的 RDB 文件中。</p>
<h3 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h3><p>在启动 Redis 服务器时，如果服务器开启了 RDB 功能，那么服务器将对 RDB 文件进行载入：</p>
<ul>
<li>如果服务器以主服务器模式运行，那么在载入 RDB 文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略。</li>
<li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。</li>
</ul>
<h3 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h3><p>当服务器以 AOF 持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么 AOF 文件不会因为这个过期键而产生任何影响。</p>
<p>当过期键被惰性删除或者定期删除之后，程序会向 AOF 文件追加（append）一条 DEL 命令，来显式地记录该键已被删除。</p>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>在执行 AOF 重写的过程中，会检查数据库中的键，已过期的键不会被保存到重写后的 AOF 文件中。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p>
<ul>
<li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个 DEL 命令，告知从服务器删除这个过期键。</li>
<li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li>
<li>从服务器只有在接到主服务器发来的 DEL 命令之后，才会删除过期键。</li>
</ul>
<p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。如果这时有客户端向从服务器请求过期键，还可以正常返回。</p>
<h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>数据库通知是 Redis2.8 版本新增加的功能，这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。它们分别对应两种通知事件：键空间通知（key-space notification）以及键事件通知（key-event notification）。键空间通知关注的是”某个键执行了什么命令”，键事件通知关注的是”某个命令被什么键执行了”。服务器配置的 notify-keyspace-events 选项可以决定了服务器所发送通知的类型。</p>
<h1 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h1><p>RDB 持久化（也称作快照持久化）是指将内存中的数据生成快照保存到磁盘里面，保存的文件后缀是 .rdb。rdb 文件是一个经过压缩的二进制文件，当 Redis 重新启动时，可以读取 rdb 快照文件恢复数据。RDB 功能最核心的是 rdbSave 和 rdbLoad 两个函数， 前者用于生成 RDB 文件并保存到磁盘，而后者则用于将 RDB 文件中的数据重新载入到内存中：</p>
<p><img src="/images/Redis/RDB持久化过程.png" alt=""></p>
<p>RDB 文件是一个单文件的全量数据，很适合数据的容灾备份与恢复，通过 RDB 文件恢复数据库耗时较短，通常 1G 的快照文件载入内存只需 20s 左右。Redis 提供了手动触发保存、自动保存间隔两种 RDB 文件的生成方式，下面先介绍 RDB 的创建和载入过程。</p>
<h2 id="RDB的创建和载入"><a href="#RDB的创建和载入" class="headerlink" title="RDB的创建和载入"></a>RDB的创建和载入</h2><p>Redis 服务器默认是通过 RDB 方式完成持久化的，对应 redis.conf 文件的配置项如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># RDB文件的名称</span>
dbfilename dump.rdb
<span class="token comment"># 备份RDB和AOF文件存放路径</span>
<span class="token function">dir</span> /usr/local/var/db/redis/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="手动触发保存"><a href="#手动触发保存" class="headerlink" title="手动触发保存"></a>手动触发保存</h3><p>Redis 提供了两个用于生成 RDB 文件的命令，一个是 SAVE，另一个是 BGSAVE。而触发 Redis 进行 RDB 备份的方式有两种，一种是通过 SAVE 命令、BGSAVE 命令手动触发快照生成的方式，另一种是配置保存时间和写入次数，由 Redis 根据条件自动触发保存操作。</p>
<p><strong>SAVE 命令</strong></p>
<p>SAVE 是一个同步式的命令，它会阻塞 Redis 服务器进程，直到 RDB 文件创建完成为止。在服务器进程阻塞期间，服务器不能处理任何其他命令请求。</p>
<ul>
<li>客户端命令</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> SAVE
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>服务端日志</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">6266</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> 08:31:01.258 * DB saved on disk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>执行 SAVE 命令后，Redis 在服务端进程（PID 为 6266）执行了 SAVE 操作，这个操作发生期间会一直阻塞 Redis 客户端的请求处理。</p>
<p><strong>BGSAVE 命令</strong></p>
<p>BGSAVE 是一个异步式的命令，和 SAVE 命令直接阻塞服务器进程的做法不同，BGSAVE 命令会派生出一个子进程，由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理客户的命令。</p>
<ul>
<li>客户端命令</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> BGSAVE
Background saving started<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>服务端日志</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">6266</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> 08:31:22.914 * Background saving started by pid <span class="token number">6283</span>
<span class="token number">6283</span>:C <span class="token number">15</span> Sep <span class="token number">2019</span> 08:31:22.915 * DB saved on disk
<span class="token number">6266</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> 08:31:22.934 * Background saving terminated with success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>通过服务端输出的日志，可以发现 Redis 在服务端进程（PID 为 6266）会为 BGSAVE 命令单独创建（fork）一个子进程（PID 为 6283），并由子进程在后台完成 RDB 的保存过程，在操作完成之后通知父进程然后退出。在整个过程中，服务器进程只会消耗少量时间在创建子进程和处理子进程信号量上面，其余时间都是待命状态。</p>
<p>BGSAVE 是触发 RDB 持久化的主流方式，下面给出 BGSAVE 命令生成快照的流程：</p>
<p><img src="/images/Redis/RDB持久化BGSAVE方式.png" alt=""></p>
<ol>
<li>客户端发起 BGSAVE 命令，Redis 主进程判断当前是否存在正在执行备份的子进程，如果存在则直接返回</li>
<li>父进程 fork 一个子进程 （fork 的过程中会造成阻塞的情况），这个过程可以使用 info stats 命令查看 latest_fork_usec 选项，查看最近一次 fork 操作消耗的时间，单位是微秒</li>
<li>父进程 fork 完成之后，则会返回 Background saving started 的信息提示，此时 fork 阻塞解除</li>
<li>fork 创建的子进程开始根据父进程的内存数据生成临时的快照文件，然后替换原文件</li>
<li>子进程备份完毕后向父进程发送完成信息，父进程更新统计信息</li>
</ol>
<p><strong>SAVE 和 BGSAVE 的比较</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>SAVE</th>
<th>BGSAVE</th>
</tr>
</thead>
<tbody>
<tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>是否阻塞</td>
<td>全程阻塞</td>
<td>fork 时阻塞</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端</td>
<td>fork子进程消耗内存</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外内存</td>
<td>不阻塞客户端</td>
</tr>
</tbody>
</table>
</div>
<h3 id="自动触发保存"><a href="#自动触发保存" class="headerlink" title="自动触发保存"></a>自动触发保存</h3><p>因为 BGSAVE 命令可以在不阻塞服务器进程的情况下执行，所以 Redis 的配置文件 redis.conf 提供了一个 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE 命令。用户可以通过 save 选项设置多个保存条件，只要其中任意一个条件被满足，服务器就会执行 BGSAVE 命令。 Redis 配置文件 redis.conf 默认配置了以下 3 个保存条件：</p>
<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">save</span> <span class="token value attr-value">900 1</span>
<span class="token key attr-name">save</span> <span class="token value attr-value">300 10</span>
<span class="token key attr-name">save</span> <span class="token value attr-value">60 10000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>那么只要满足以下 3 个条件中的任意一个，BGSAVE 命令就会被自动执行：</p>
<ul>
<li>服务器在 900 秒之内，对数据库进行了至少 1 次修改。</li>
<li>服务器在 300 秒之内，对数据库进行了至少 10 次修改。</li>
<li>服务器在 60 秒之内，对数据库进行了至少 10000 次修改。</li>
</ul>
<p>比如通过命令 SET msg “hello” 插入一条键值对，等待 900 秒后 Reids 服务器进程自动触发保存，输出如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">6266</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> 08:46:22.981 * <span class="token number">1</span> changes <span class="token keyword">in</span> <span class="token number">900</span> seconds. Saving<span class="token punctuation">..</span>.
<span class="token number">6266</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> 08:46:22.986 * Background saving started by pid <span class="token number">6266</span>
<span class="token number">6476</span>:C <span class="token number">15</span> Sep <span class="token number">2019</span> 08:46:23.015 * DB saved on disk
<span class="token number">6266</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> 08:46:23.096 * Background saving terminated with success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Redis 服务器会周期性地操作 serverCron 函数，这个函数每隔 100 毫秒就会执行一次，它的一项任务就是检查 save 选项所设置的保存条件是否满足，如果满足的话，就自动执行 BGSAVE 命令。</p>
<h2 id="启动自动载入"><a href="#启动自动载入" class="headerlink" title="启动自动载入"></a>启动自动载入</h2><p>和使用 SAVE 和 BGSAVE 命令创建 RDB 文件不同，Redis 没有专门提供用于载入 RDB 文件的命令，RDB 文件的载入过程是在 Redis 服务器启动时自动完成的。启动时只要在指定目录检测到 RDB 文件的存在，Redis 就会通过 rdbLoad 函数自动载入 RDB 文件。</p>
<p>下面是 Redis 服务器启动时打印的日志，倒数第 2 条日志是在成功载入 RDB 文件后打印的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ redis-server /usr/local/etc/redis.conf
<span class="token number">6266</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> 08:30:41.832 <span class="token comment"># Server initialized</span>
<span class="token number">6266</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> 08:30:41.833 * DB loaded from disk: <span class="token number">0.001</span> seconds
<span class="token number">6266</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> 08:30:41.833 * Ready to accept connections<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于 AOF 文件属于增量的写入命令备份，RDB 文件属于全量的数据备份，所以更新频率比 RDB 文件的更新频率高。所以如果 Redis 服务器开启了 AOF 持久化功能，那么服务器会优先使用 AOF 文件来还原数据库状态；只有在 AOF 的持久化功能处于关闭状态时，服务器才会使用使用 RDB 文件还原数据库状态。</p>
<p><img src="/images/Redis/Redis自动载入配置.png" alt=""></p>
<h2 id="RDB的文件结构"><a href="#RDB的文件结构" class="headerlink" title="RDB的文件结构"></a>RDB的文件结构</h2><p>RDB 文件是经过压缩的二进制文件，下面介绍关于 RDB 文件内部构造的一些细节。</p>
<h3 id="存储路径"><a href="#存储路径" class="headerlink" title="存储路径"></a>存储路径</h3><p>SAVE 命令和 BGSAVE 命令都只会备份当前数据库，备份文件名默认为 dump.rdb，可通过配置文件修改备份文件名 dbfilename xxx.rdb。可以通过以下命令查看备份文件目录和 RDB 文件名称：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ redis-cli -h <span class="token number">127.0</span>.0.1 -p <span class="token number">6379</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> CONFIG GET <span class="token function">dir</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"dir"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"/usr/local/var/db/redis"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> CONFIG GET dbfilename
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"dbfilename"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"dump.rdb"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>RDB 文件的存储路径既可以在启动前配置，也可以通过命令动态设定。</p>
<ul>
<li>配置项：通过 dir 配置指定目录，dbfilename 指定文件名</li>
<li>动态指定：Redis 启动后也可以动态修改 RDB 存储路径，在磁盘损害或空间不足时非常有用，执行命令为：</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">CONFIG SET <span class="token function">dir</span> <span class="token variable">$newdir</span>
CONFIG SET dbfilename <span class="token variable">$newFileName</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>RDB 文件有固定的格式要求，它保存的是二进制数据，大体可以分为以下 5 部分：</p>
<ul>
<li><p>REDIS：文件头保存的是长为 5 个字节的 “REDIS” 字符，用于标识当前文件为 RDB 类型</p>
</li>
<li><p>db_version：一个 4 个字节长的整数字符串，用于记录 RDB 文件的版本号</p>
</li>
<li><p>aux：记录着 RDB 文件中元数据信息，包含 8 个附加</p>
<ul>
<li>redis-ver：Redis 实例的版本号</li>
<li>redis-bits：运行 Redis 实例的主机架构，64 位或 32 位</li>
<li>ctime：RDB 创建时的 Unix 时间戳</li>
<li>used_mem：存储快照时使用的内存大小</li>
<li>repl-stream-db：Redis 服务器的 db 的索引</li>
<li>repl-id：Redis 主实例的 ID（replication id）</li>
<li>repl-offset：Redis 主实例的偏称量（replication offset）</li>
<li>aof-preamble：是否在 AOF 文件头部放置 RDB 快照（即开启混合持久化）</li>
</ul>
</li>
<li><p>databases：部分包含着零个或者任意多个数据库，以及各个数据库的键值对数据</p>
</li>
<li><p>EOF：是 1 个字节的常量，用于标志 RDB 文件的正文内容结束</p>
</li>
<li><p>check_sum：一个 8 字节长的整数，保存着由前面 REDIS、db_version、databases、EOF 计算得到的校验和，用于检测 RDB 文件的完整性</p>
</li>
</ul>
<p><img src="/images/Redis/RDB文件结构.png" alt=""></p>
<p><strong>database</strong></p>
<p>一个 RDB 文件的 databases 部分包含着零个或者任意多个数据库（database），而每个非空的 database 都包含 SELECTDB、db_number 以及 key_value_pairs 三个部分：</p>
<ul>
<li>SELECTDB：长度为一个字节的常量，告诉用户程序接下来要读取的是一个 db_number</li>
<li>db_number：保存着一个数据库编号。当程序读到 db_number 时，服务器会立即调用 SELECT 命令切换到对应编号的数据库</li>
<li>key_value_pairs：保存了数据库中的所有键值对数据，包括带过期时间和不带过期时间两种类型的键值对</li>
</ul>
<p><strong>key_value_pairs</strong></p>
<p>RDB 的 key_value_pairs 部分保存了一个或者多个键值对，如果键值对有过期时间，过期时间会被保存在键值对的前面。下面是这两种键值对的内部结构：</p>
<p><img src="/images/Redis/RDB文件键值对.png" alt=""></p>
<ul>
<li><p>EXPIREMENT_MS：长度为一个字节的常量，告诉用户程序接下来要读取的是一个以毫秒为单位的过期时间</p>
</li>
<li><p>ms：一个长度为 8 个字节的整数，记录着键值对的过期时间，是一个以毫秒为单位的时间戳</p>
</li>
<li><p>TYPE：记录了 value 的类型，长度为 1 个字节。每个 TYPE 常量都代表了一种对象类型或者底层编码， 当服务器读入 RDB 文件中的键值对数据时， 程序会根据 TYPE 的值来决定如何读入和解释 value 的数据。它的值定义通常为以下常量之一：</p>
</li>
<li><ul>
<li>REDIS_RDB_TYPE_STRING：字符串<ul>
<li>REDIS_RDB_TYPE_LIST：列表类型</li>
<li>REDIS_RDB_TYPE_SET：集合类型</li>
<li>REDIS_RDB_TYPE_ZSET：有序集合</li>
<li>REDIS_RDB_TYPE_HASH：哈希类型</li>
<li>REDIS_RDB_TYPE_LIST_ZIPLIST：列表类型</li>
<li>REDIS_RDB_TYPE_SET_INT_SET：集合类型</li>
<li>REDIS_RDB_TYPE_ZSET_ZIPLIST：有序集合</li>
<li>REDIS_RDB_TYPE_HASH_ZIPLIST：哈希类型</li>
</ul>
</li>
</ul>
</li>
<li><p>key：一个字符串对象，编码格式和 REDIS_RDB_TYPE_STRING 类型的 value 一样</p>
</li>
<li><p>value：取决于 TYPE 的类型，对象类型可以是 string、list、set、zset 和 hash</p>
</li>
</ul>
<p>为了查看 RDB 文件内部的结构，执行以下命令往 Redis 服务器插入 3 条键值对数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> SADD fruits <span class="token string">"apple"</span> <span class="token string">"banana"</span> <span class="token string">"orange"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> LPUSH numbers <span class="token number">128</span> <span class="token number">256</span> <span class="token number">512</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> SET msg <span class="token string">"hello"</span>
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行 SAVE 操作，将 Redis 进程中的数据强制持久化到 dump.rdb 文件中</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> SAVE
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>通过 Linux 的 od 命令将二进制文件 dump.rdb 中的数据转换为 ASCII 格式输出，跟前面提到的存储格式大致是一样的：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ od -c dump.rdb
0000000    R   E   D   I   S   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">9</span> <span class="token number">372</span>  <span class="token punctuation">\</span>t   r   e   d   i   s
0000020    -   <span class="token function">v</span>   e   r 005   <span class="token number">5</span>   <span class="token builtin class-name">.</span>   <span class="token number">0</span>   <span class="token builtin class-name">.</span>   <span class="token number">5</span> <span class="token number">372</span>  <span class="token punctuation">\</span>n   r   e   d   i
0000040    s   -   b   i   t   s <span class="token number">300</span>   @ <span class="token number">372</span> 005   c   t   i   m   e <span class="token number">200</span>
0000060  <span class="token number">200</span> <span class="token number">200</span> <span class="token number">231</span>   <span class="token punctuation">]</span> <span class="token number">372</span>  <span class="token punctuation">\</span>b   u   s   e   d   -   m   e   m <span class="token number">302</span> <span class="token number">200</span>
0000100   <span class="token punctuation">\</span>v 020  <span class="token punctuation">\</span><span class="token number">0</span> <span class="token number">372</span>  <span class="token punctuation">\</span>f   a   o   f   -   p   r   e   a   m   b   l
0000120    e <span class="token number">300</span>  <span class="token punctuation">\</span><span class="token number">0</span> <span class="token number">376</span>  <span class="token punctuation">\</span><span class="token number">0</span> <span class="token number">373</span> 003  <span class="token punctuation">\</span><span class="token number">0</span>  <span class="token punctuation">\</span><span class="token number">0</span> 003   m   s   g 005   h   e
0000140    l   l   o 016  <span class="token punctuation">\</span>a   n   u   m   b   e   r   s 001 027 027  <span class="token punctuation">\</span><span class="token number">0</span>
0000160   <span class="token punctuation">\</span><span class="token number">0</span>  <span class="token punctuation">\</span><span class="token number">0</span> 022  <span class="token punctuation">\</span><span class="token number">0</span>  <span class="token punctuation">\</span><span class="token number">0</span>  <span class="token punctuation">\</span><span class="token number">0</span> 003  <span class="token punctuation">\</span><span class="token number">0</span>  <span class="token punctuation">\</span><span class="token number">0</span> <span class="token number">300</span>  <span class="token punctuation">\</span><span class="token number">0</span> 002 004 <span class="token number">300</span>  <span class="token punctuation">\</span><span class="token number">0</span> 001
0000200  004 <span class="token number">300</span> <span class="token number">200</span>  <span class="token punctuation">\</span><span class="token number">0</span> <span class="token number">377</span> 002 006   f   r   u   i   t   s 003 006   o
0000220    r   a   n   g   e 005   a   p   p   l   e 006   b   a   n   a
0000240    n   a <span class="token number">377</span> <span class="token number">214</span>      **   <span class="token number">3</span> <span class="token number">366</span>   <span class="token operator">&lt;</span>   r   X
0000253<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="RDB常用的配置项"><a href="#RDB常用的配置项" class="headerlink" title="RDB常用的配置项"></a>RDB常用的配置项</h3><p>下面是 redis.conf 文件中和 RDB 文件相关的常用配置项（以及默认值）：</p>
<ul>
<li>save m n：bgsave 自动触发的条件；如果没有 save m n 配置，相当于自动的 RDB 持久化关闭，不过此时仍可以通过其他方式触发。</li>
<li>stop-writes-on-bgsave-error yes：当 bgsave 出现错误时，Redis 是否停止执行写命令。如果设置为 yes，则当硬盘出现问题时，可以及时发现，避免数据的大量丢失；如果设置为 no，则 Redis 忽略 bgsave 的错误继续执行写命令，当对 Redis 服务器的系统（尤其是硬盘）使用了监控时，该选项考虑设置为 no。</li>
<li>rdbcompression yes：是否开启 RDB 文件压缩。</li>
<li>rdbchecksum yes：是否开启 RDB 文件的校验，在写入文件和读取文件时都起作用。关闭 checksum 在写入文件和启动文件时大约能带来 10% 的性能提升，但是数据损坏时无法发现。</li>
<li>dbfilename dump.rdb：设置 RDB 的文件名。</li>
<li>dir ./：设置 RDB 文件和 AOF 文件所在目录。</li>
</ul>
<h1 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h1><p>RDB 持久化是定期把内存中的数据全量写入到文件中，除此之外，RDB 还提供了基于 AOF（Append Only File）的持久化功能。AOF 会把 Redis 服务器每次执行的写命令记录到一个日志文件中，当服务器重启时再次执行 AOF 文件中的命令来恢复数据。</p>
<p><img src="/images/Redis/AOF持久化过程.png" alt=""></p>
<p>AOF 的主要作用是解决了数据持久化的实时性，目前已经成为了 Redis 持久化的主流方式。 注意：Redis 是先执行命令，后写日志的。</p>
<h2 id="AOF的创建和载入"><a href="#AOF的创建和载入" class="headerlink" title="AOF的创建和载入"></a>AOF的创建和载入</h2><p>默认情况下 AOF 功能是关闭的，Redis 只会通过 RDB 完成数据持久化的。开启 AOF 功能需要 redis.conf 文件中将 appendonly 配置项修改为 yes，这样在开启 AOF 持久化功能的同时，将基于 RDB 的快照持久化置于低优先级。修改 redis.conf 如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 此选项为AOF功能的开关，默认为no，通过yes来开启aof功能</span>
appendonly <span class="token function">yes</span>
<span class="token comment"># 指定AOF文件名称</span>
appendfilename appendonly.aof
<span class="token comment"># 备份RDB和AOF文件存放路径</span>
<span class="token function">dir</span> /usr/local/var/db/redis/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="AOF的创建"><a href="#AOF的创建" class="headerlink" title="AOF的创建"></a>AOF的创建</h3><p>重启 Redis 服务器进程以后，dir 目录下会生成一个 appendonly.aof 文件，由于此时服务器未执行任何写指令，因此 AOF 文件是空的。执行以下命令写入几条测试数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> SADD fruits <span class="token string">"apple"</span> <span class="token string">"banana"</span> <span class="token string">"orange"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> LPUSH numbers <span class="token number">128</span> <span class="token number">256</span> <span class="token number">512</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> SET msg <span class="token string">"hello"</span>
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>AOF 文件是纯文本格式的，上述写命令按顺序被写入了 appendonly.aof 文件（省掉换行符 ‘\r\n’）：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/local/var/db/redis$ <span class="token function">cat</span> appendonly.aof
*2 <span class="token variable">$6</span> SELECT <span class="token variable">$1</span> <span class="token number">0</span>
*5 <span class="token variable">$4</span> SADD <span class="token variable">$6</span> fruits <span class="token variable">$5</span> apple <span class="token variable">$6</span> banana <span class="token variable">$6</span> orange
*5 <span class="token variable">$5</span> LPUSH <span class="token variable">$7</span> numbers <span class="token variable">$3</span> <span class="token number">128</span> <span class="token variable">$3</span> <span class="token number">256</span> <span class="token variable">$3</span> <span class="token number">512</span>
*3 <span class="token variable">$3</span> SET <span class="token variable">$3</span> msg <span class="token variable">$5</span> hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>RDB 持久化的方式是将 apple、banana、orange 的键值对数据保存为 RDB 的二进制文件，而 AOF 是通过把 Redis 服务器执行的 SADD、LPUSH、SET 等命令保存到 AOF 的文本文件中。下图是 AOF 文件内部的构造图：</p>
<p><img src="/images/Redis/AOF文件结构.png" alt=""></p>
<h3 id="AOF的载入"><a href="#AOF的载入" class="headerlink" title="AOF的载入"></a>AOF的载入</h3><p>再次重启 Redis 服务器进程，观察启动日志会发现 Redis 会通过 AOF 文件加载数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">52580</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> <span class="token number">16</span>:09:47.015 <span class="token comment"># Server initialized</span>
<span class="token number">52580</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> <span class="token number">16</span>:09:47.015 * DB loaded from append only file: <span class="token number">0.001</span> seconds
<span class="token number">52580</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> <span class="token number">16</span>:09:47.015 * Ready to accept connections<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>下图是 AOF 载入的流程</p>
<p><img src="/images/Redis/AOF载入流程.png" alt=""></p>
<p>通过命令读取 AOF 文件还原的键值对数据：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> SMEMBERS fruits
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"apple"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"orange"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"banana"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> LRANGE numbers <span class="token number">0</span> -1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"512"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"256"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"128"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> GET msg
<span class="token string">"hello"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="AOF的执行流程"><a href="#AOF的执行流程" class="headerlink" title="AOF的执行流程"></a>AOF的执行流程</h2><p>AOF 不需要设置任何触发条件，对 Redis 服务器的所有写命令都会自动记录到 AOF 文件中，下面介绍 AOF 持久化的执行流程。</p>
<p><img src="/images/Redis/AOF执行流程.png" alt=""></p>
<p>AOF 文件的写入流程可以分为以下 3 个步骤：</p>
<ol>
<li>命令追加（append）：将 Redis 执行的写命令追加到 AOF 的缓冲区 aof_buf</li>
<li>文件写入（write）和文件同步（fsync）：AOF 根据对应的策略将 aof_buf 的数据同步到硬盘</li>
<li>文件重写（rewrite）：定期对 AOF 进行重写，从而实现对写命令的压缩。</li>
</ol>
<h3 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h3><p>Redis 使用单线程处理客户端命令，为了避免每次有写命令就直接写入磁盘，导致磁盘 IO 成为 Redis 的性能瓶颈，Redis 会先把执行的写命令追加（append）到一个 aof_buf 缓冲区，而不是直接写入文件。</p>
<p>命令追加的格式是 Redis 命令请求的协议格式，它是一种纯文本格式，具有兼容性好、可读性强、容易处理、操作简单避免二次开销等优点。在 AOF 文件中，除了用于指定数据库的 select 命令（比如：select 0 为选中 0 号数据库）是由 Redis 添加的，其他都是客户端发送来的写命令。</p>
<h3 id="文件写入和文件同步"><a href="#文件写入和文件同步" class="headerlink" title="文件写入和文件同步"></a>文件写入和文件同步</h3><p>Redis 提供了多种 AOF 缓存区的文件同步策略，相关策略涉及到操作系统的 write() 函数和 fsync() 函数，说明如下：</p>
<p><strong>1. write()</strong></p>
<p>为了提高文件的写入效率，当用户调用 write 函数将数据写入文件时，操作系统会先把数据写入到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</p>
<p><strong>2. fsync()</strong></p>
<p>虽然操作系统底层对 write() 函数进行了优化 ，但也带来了安全问题。如果宕机内存缓冲区中的数据会丢失，因此系统同时提供了同步函数 fsync() ，强制操作系统立刻将缓冲区中的数据写入到磁盘中，从而保证了数据持久化。</p>
<p>Redis 提供了 appendfsync 配置项来控制 AOF 缓存区的文件同步策略，appendfsync 可配置以下三种策略：</p>
<ul>
<li><strong>appendfsync always</strong>：每执行一次命令保存一次</li>
</ul>
<p>命令写入 aof_buf 缓冲区后立即调用系统 fsync 函数同步到 AOF 文件，fsync 操作完成后线程返回，整个过程是阻塞的。这种情况下，每次有写命令都要同步到 AOF 文件，硬盘 IO 成为性能瓶颈，Redis 只能支持大约几百 TPS 写入，严重降低了 Redis 的性能。</p>
<ul>
<li><strong>appendfsync no</strong>：不保存</li>
</ul>
<p>命令写入 aof_buf 缓冲区后调用系统 write 操作，不对 AOF 文件做 fsync 同步；同步由操作系统负责，通常同步周期为 30 秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。</p>
<ul>
<li><strong>appendfsync everysec</strong>：每秒钟保存一次</li>
</ul>
<p>命令写入 aof_buf 缓冲区后调用系统 write 操作，write 完成后线程立刻返回，fsync 同步文件操作由单独的进程每秒调用一次。everysec 是前述两种策略的折中，是性能和数据安全性的平衡，因此也是 Redis 的默认配置，也是比较推崇的配置选项。</p>
<p><strong>appendfsync 三种策略对比</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件同步策略</th>
<th>write阻塞</th>
<th>fsync阻塞</th>
<th>宕机时的数据丢失量</th>
</tr>
</thead>
<tbody>
<tr>
<td>always</td>
<td>阻塞</td>
<td>阻塞</td>
<td>最多只丢失一个命令的数据</td>
</tr>
<tr>
<td>no</td>
<td>阻塞</td>
<td>不阻塞</td>
<td>操作系统最后一次对 AOF 文件 fsync 后的数据</td>
</tr>
<tr>
<td>everysec</td>
<td>阻塞</td>
<td>不阻塞</td>
<td>一般不超过 1 秒钟的数据</td>
</tr>
</tbody>
</table>
</div>
<h3 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h3><p>随着命令不断写入 AOF，文件会越来越大，导致文件占用空间变大，数据恢复时间变长。为了解决这个问题，Redis 引入了重写机制来对 AOF 文件中的写命令进行合并，进一步压缩文件体积。</p>
<p>AOF 文件重写指的是把 Redis 进程内的数据转化为写命令，同步到新的 AOF 文件中，然后使用新的 AOF 文件覆盖旧的 AOF 文件，这个过程不对旧的 AOF 文件的进行任何读写操作。</p>
<h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><p>AOF 重写过程提供了手动触发和自动触发两种机制：</p>
<ul>
<li>手动触发：直接调用 bgrewriteaof 命令，该命令的执行与 bgsave 有些类似，都是 fork 子进程进行具体的工作，且都只有在 fork 时会阻塞</li>
<li>自动触发：根据 auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 配置项，以及 aof_current_size 和 aof_base_size 的状态确定触发时机</li>
<li>auto-aof-rewrite-min-size：执行 AOF 重写时，文件的最小体积，默认值为 64MB</li>
<li>auto-aof-rewrite-percentage：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值</li>
</ul>
<h4 id="重写流程"><a href="#重写流程" class="headerlink" title="重写流程"></a>重写流程</h4><p>下面以手动触发 AOF 重写为例，当 bgrewriteaof 命令被执行时，AOF 文件重写的流程如下：</p>
<p><img src="/images/Redis/AOF文件重写流程.png" alt=""></p>
<ol>
<li>客户端通过 bgrewriteaof 命令对 Redis 主进程发起 AOF 重写请求</li>
<li>当前不存在正在执行 bgsave/bgrewriteaof 的子进程时，Redis 主进程通过 fork 操作创建子进程，这个过程主进程是阻塞的。如果发现 bgrewriteaof 子进程直接返回；如果发现 bgsave 子进程则等 bgsave 执行完成后再执行 fork 操作</li>
<li>主进程的 fork 操作完成后，继续处理其他命令，把新的写命令同时追加到 aof_buf 和 aof_rewrite_buf 缓冲区中</li>
<li>在文件重写完成之前，主进程会继续把写命令追加到 aof_buf 缓冲区，根据 appendfsync 策略同步到旧的 AOF 文件，这样可以避免 AOF 重写失败造成数据丢失，保证原有的 AOF 文件的正确性</li>
<li>由于 fork 操作运用写时复制技术，子进程只能共享 fork 操作时的内存数据，主进程会把新命令追加到一个 aof_rewrite_buf 缓冲区中，避免 AOF 重写时丢失这部分数据</li>
<li>子进程读取 Redis 进程中的数据快照，生成写入命令并按照命令合并规则批量写入到新的 AOF 文件</li>
<li>子进程写完新的 AOF 文件后，向主进程发信号，主进程更新统计信息，具体可以通过 info persistence 查看</li>
<li>主进程接受到子进程的信号以后，将 aof_rewrite_buf 缓冲区中的写命令追加到新的 AOF 文件</li>
<li>主进程使用新的 AOF 文件替换旧的 AOF 文件，AOF 重写过程完成</li>
</ol>
<h4 id="压缩机制"><a href="#压缩机制" class="headerlink" title="压缩机制"></a>压缩机制</h4><p>文件重写之所以能够压缩 AOF 文件的大小，原因在于以下几方面：</p>
<ul>
<li>过期的数据不再写入 AOF 文件</li>
<li>无效的命令不再写入 AOF 文件。比如：重复为数据设值（set mykey v1, set mykey v2）、删除键值对数据（sadd myset v1, del myset）等等</li>
<li>多条命令可以合并为单个。比如：sadd myset v1, sadd myset v2, sadd myset v3 可以合并为 sadd myset v1 v2 v3。不过为了防止单条命令过大造成客户端缓冲区溢出，对于 list、set、hash、zset 类型的 key，并不一定只使用单条命令，而是以某个 Redis 定义的一个常量为界，将命令拆分为多条</li>
</ul>
<h2 id="AOF常用的配置项"><a href="#AOF常用的配置项" class="headerlink" title="AOF常用的配置项"></a>AOF常用的配置项</h2><p>下面是 redis.conf 文件中和 AOF 文件相关的常用配置项（以及默认值）：</p>
<ul>
<li>appendonly no：是否开启 AOF 持久化功能</li>
<li>appendfilename “appendonly.aof”：AOF 文件的名称</li>
<li>dir ./：RDB 文件和 AOF 文件所在目录</li>
<li>appendfsync everysec：fsync 持久化策略</li>
<li>no-appendfsync-on-rewrite no：重写 AOF 文件期间是否禁止 fsync 操作。如果开启该选项，可以减轻文件重写时 CPU 和磁盘的负载（尤其是磁盘），但是可能会丢失 AOF 重写期间的数据，需要在负载和安全性之间进行平衡</li>
<li>auto-aof-rewrite-percentage 100：AOF 文件重写触发条件之一</li>
<li>auto-aof-rewrite-min-size 64mb：AOF 文件重写触发条件之一</li>
<li>aof-load-truncated yes：如果 AOF 文件结尾损坏，Redis 服务器在启动时是否仍载入 AOF 文件</li>
</ul>
<h1 id="数据恢复机制"><a href="#数据恢复机制" class="headerlink" title="数据恢复机制"></a>数据恢复机制</h1><p>当 AOF 持久化功能开启时，Redis 服务器启动时优先执行 AOF 文件的命令恢复数据，只有当 AOF 功能关闭时，才会优先载入 RDB 快照的文件数据。</p>
<h2 id="RDB-AOF单策略持久化"><a href="#RDB-AOF单策略持久化" class="headerlink" title="RDB/AOF单策略持久化"></a>RDB/AOF单策略持久化</h2><ul>
<li>当 AOF 功能关闭，且 RDB 持久化开启时，Redis 服务器启动日志：</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">6266</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> 08:30:41.832 <span class="token comment"># Server initialized</span>
<span class="token number">6266</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> 08:30:41.833 * DB loaded from disk: <span class="token number">0.001</span> seconds
<span class="token number">6266</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> 08:30:41.833 * Ready to accept connections<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>当 AOF 功能开启，且 AOF 文件存在时，Redis 服务器启动日志：</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">9447</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> <span class="token number">23</span>:01:46.601 <span class="token comment"># Server initialized</span>
<span class="token number">9447</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> <span class="token number">23</span>:01:46.602 * DB loaded from append only file: <span class="token number">0.001</span> seconds
<span class="token number">9447</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> <span class="token number">23</span>:01:46.602 * Ready to accept connections<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>当 AOF 功能开启，且 AOF 文件不存在时，即使 RDB 文件存在也不会加载，Redis 服务器启动日志：</li>
</ul>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">9326</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> <span class="token number">22</span>:49:24.203 <span class="token comment"># Server initialized</span>
<span class="token number">9326</span>:M <span class="token number">15</span> Sep <span class="token number">2019</span> <span class="token number">22</span>:49:24.203 * Ready to accept connections<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="RDB-AOF混合策略持久化"><a href="#RDB-AOF混合策略持久化" class="headerlink" title="RDB-AOF混合策略持久化"></a>RDB-AOF混合策略持久化</h2><p>在重启 Redis 服务器时，一般很少使用 RDB 快照文件来恢复内存状态，因为会丢失大量数据。更多的是使用 AOF 文件进行命令重放，但是执行 AOF 命令性能相对 RDB 来说要慢很多。这样在 Redis 数据很大的情况下，启动需要消耗大量的时间。</p>
<p>鉴于 RDB 快照可能会造成数据丢失，AOF 指令恢复数据慢，Redis 4.0 版本提供了一套基于 AOF-RDB 的混合持久化机制，保留了两种持久化机制的优点。这样重写的 AOF 文件由两部份组成，一部分是 RDB 格式的头部数据，另一部分是 AOF 格式的尾部指令。</p>
<p>Redis 4.0 版本的混合持久化功能默认是关闭的，通过配置 aof-use-rdb-preamble 为 yes 开启此功能：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 开启AOF-RDB混合持久化机制</span>
aof-use-rdb-preamble <span class="token function">yes</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>查看 Redis 服务器是否开启混合持久化功能：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>></span> CONFIG GET aof-use-rdb-preamble
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"aof-use-rdb-preamble"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"yes"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如图所示，将 RDB 数据文件的内容和增量的 AOF 命令文件存在一起。这里的 AOF 命令不再是全量的命令，而是自持久化开始到持久化结束的这段时间服务器进程执行的增量 AOF 命令，通常这部分 AOF 命令很小。</p>
<p><img src="/images/Redis/RDB-AOF混合策略持久化.png" alt=""></p>
<p>在 Redis 服务器重启的时候，可以预先加载 AOF 文件头部全量的 RDB 数据，然后再重放 AOF 文件尾部增量的 AOF 命令，从而大大减少了重启过程中数据还原的时间。</p>
<h2 id="持久化策略选择"><a href="#持久化策略选择" class="headerlink" title="持久化策略选择"></a>持久化策略选择</h2><h3 id="RDB和-AOF性能开销"><a href="#RDB和-AOF性能开销" class="headerlink" title="RDB和 AOF性能开销"></a>RDB和 AOF性能开销</h3><p>在介绍持久化策略之前，首先要明白无论是 RDB 还是 AOF 方式，开启持久化都是会造成性能开销的。</p>
<ul>
<li>RDB 持久化：<ul>
<li>BGSAVE 命令在进行 fork 操作时，Redis 服务器主进程会发生阻塞</li>
<li>Redis 子进程向磁盘写入数据也会带来 IO 压力</li>
</ul>
</li>
<li>AOF 持久化：<ul>
<li>向磁盘写入数据的频率大大提高，IO 压力更大，甚至可能造成 AOF 追加阻塞问题</li>
<li>AOF 文件重写与 RDB 的 BGSAVE 过程类似，存在父进程 fork 时的阻塞和子进程的 IO 压力问题</li>
</ul>
</li>
</ul>
<p>相对来说，由于 AOF 向磁盘中写入数据的频率更高，因此对 Redis 服务器主进程性能的影响会更大。</p>
<h3 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h3><p>在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略。</p>
<ol>
<li>完全不使用任何持久化功能</li>
<li>使用 RDB 或 AOF 其中一种</li>
<li>同时开启 RDB 和 AOF 持久化</li>
</ol>
<p>对于分布式环境，持久化的选择必须与 Redis 的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主节点（Master Node）和从节点（Slave Node）可以独立选择持久化方案。</p>
<p>下面分场景来讨论持久化策略的选择，下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。</p>
<h4 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h4><p>如果 Redis 中的数据完全丢弃也没有关系（如 Redis 完全用作 DB 层数据的缓存），那么无论是单机，还是主从架构，都可以不进行任何持久化。</p>
<h4 id="单机环境"><a href="#单机环境" class="headerlink" title="单机环境"></a>单机环境</h4><p>在单机环境下，如果可以接受十几分钟或更多的数据丢失，RDB 方案对 Redis 的性能更加有利；如果只能接受秒级别的数据丢失，选择 AOF 方案更合适。</p>
<h4 id="主从部署"><a href="#主从部署" class="headerlink" title="主从部署"></a>主从部署</h4><p>在多数情况下，Redis 都会配置主从部署机制。从节点（slave）既可以实现数据的热备，也可以进行读写分担 Redis 读请求，以及在主节点（master）宕机后的顶替作用。</p>
<p>在这种情况下，一种可行的做法如下：</p>
<ul>
<li>master：完全关闭持久化（包括 RDB 和 AOF 功能），这样可以让主节点的性能达到最好</li>
<li>slave：关闭 RDB 功能，开启 AOF 功能（如果对数据安全要求不高，开启 RDB 关闭 AOF 也可以）。定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）。然后关闭 AOF 的自动重写功能，然后添加定时任务，在每天 Redis 服务器闲时（如凌晨 12 点）调用 bgrewriteaof 手动重写。</li>
</ul>
<p>为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：</p>
<ul>
<li>master 和 slave 同时停止：如果 master 节点和 slave 节点位于同一个机房，则一次停电事故就可能导致 master 和 slave 机器同时关机，Redis 服务器进程停止。如果没有持久化，则面临的是数据的完全丢失。</li>
<li>master 重启：如果 master 节点因为故障宕机，并且系统中有自动拉起机制（即检测到服务停止后重启该服务）将 master 节点自动重启。</li>
<li>由于没有持久化文件，那么 master 重启后数据是空的，slave 同步数据也变成了空的</li>
<li>如果 master 和 slave 节点都没有开启持久化，同样会引发数据的完全丢失</li>
</ul>
<h4 id="异地备灾"><a href="#异地备灾" class="headerlink" title="异地备灾"></a>异地备灾</h4><p>前面的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。</p>
<ul>
<li>单机环境：可以定时将 RDB 文件或重写后的 AOF 文件，通过 scp 命令拷贝到远程机器，如阿里云、AWS 等</li>
<li>主从部署，可以定时在 master 节点上执行 BGSAVE 操作，然后将 RDB 文件拷贝到远程机器，或者在 slave 节点上执行 bgrewriteaof 命令重写 AOF 文件后，将 AOF 文件拷贝到远程机器上。</li>
</ul>
<p>由于 RDB 文件文件小、恢复速度快，灾难恢复一般采用 RDB 方式；异地备份的频率根据数据安全性的需要及其它条件来确定，但最好不要低于一天一次。</p>
<h1 id="RDB和AOF整体对比"><a href="#RDB和AOF整体对比" class="headerlink" title="RDB和AOF整体对比"></a>RDB和AOF整体对比</h1><div class="table-container">
<table>
<thead>
<tr>
<th>持久化机制</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>磁盘文件体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>数据还原速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>易丢失数据</td>
<td>根据策略决定</td>
</tr>
<tr>
<td>操作轻重级别</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody>
</table>
</div>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
              <a href="/tags/RDB/" rel="tag"># RDB</a>
              <a href="/tags/AOF/" rel="tag"># AOF</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/19/Redis-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/" rel="prev" title="Redis 数据结构与对象系统">
      <i class="fa fa-chevron-left"></i> Redis 数据结构与对象系统
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/23/Redis-3-%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" rel="next" title="Redis 多机数据库的实现">
      Redis 多机数据库的实现 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">Redis数据库结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="nav-number">1.1.</span> <span class="nav-text">对数据库键的增删改查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">1.2.</span> <span class="nav-text">对过期键的删除策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF%E3%80%81RDB%E5%92%8C%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%E5%AF%B9%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">AOF、RDB和复制功能对过期键的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90RDB%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.1.</span> <span class="nav-text">生成RDB文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BD%E5%85%A5RDB%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.2.</span> <span class="nav-text">载入RDB文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="nav-number">1.3.3.</span> <span class="nav-text">AOF文件写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E9%87%8D%E5%86%99"><span class="nav-number">1.3.4.</span> <span class="nav-text">AOF重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">1.3.5.</span> <span class="nav-text">主从复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%9A%E7%9F%A5"><span class="nav-number">1.4.</span> <span class="nav-text">数据库通知</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">RDB持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BD%BD%E5%85%A5"><span class="nav-number">2.1.</span> <span class="nav-text">RDB的创建和载入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91%E4%BF%9D%E5%AD%98"><span class="nav-number">2.1.1.</span> <span class="nav-text">手动触发保存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91%E4%BF%9D%E5%AD%98"><span class="nav-number">2.1.2.</span> <span class="nav-text">自动触发保存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%87%AA%E5%8A%A8%E8%BD%BD%E5%85%A5"><span class="nav-number">2.2.</span> <span class="nav-text">启动自动载入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">RDB的文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84"><span class="nav-number">2.3.1.</span> <span class="nav-text">存储路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.3.2.</span> <span class="nav-text">文件格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="nav-number">2.3.3.</span> <span class="nav-text">RDB常用的配置项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">AOF持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BD%BD%E5%85%A5"><span class="nav-number">3.1.</span> <span class="nav-text">AOF的创建和载入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">3.1.1.</span> <span class="nav-text">AOF的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E7%9A%84%E8%BD%BD%E5%85%A5"><span class="nav-number">3.1.2.</span> <span class="nav-text">AOF的载入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">AOF的执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%BF%BD%E5%8A%A0"><span class="nav-number">3.2.1.</span> <span class="nav-text">命令追加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E5%92%8C%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5"><span class="nav-number">3.2.2.</span> <span class="nav-text">文件写入和文件同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E9%87%8D%E5%86%99"><span class="nav-number">3.2.3.</span> <span class="nav-text">文件重写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">触发机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">重写流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E6%9C%BA%E5%88%B6"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">压缩机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="nav-number">3.3.</span> <span class="nav-text">AOF常用的配置项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">数据恢复机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB-AOF%E5%8D%95%E7%AD%96%E7%95%A5%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">4.1.</span> <span class="nav-text">RDB&#x2F;AOF单策略持久化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB-AOF%E6%B7%B7%E5%90%88%E7%AD%96%E7%95%A5%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">4.2.</span> <span class="nav-text">RDB-AOF混合策略持久化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5%E9%80%89%E6%8B%A9"><span class="nav-number">4.3.</span> <span class="nav-text">持久化策略选择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB%E5%92%8C-AOF%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80"><span class="nav-number">4.3.1.</span> <span class="nav-text">RDB和 AOF性能开销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">4.3.2.</span> <span class="nav-text">持久化策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">数据库缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">单机环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E9%83%A8%E7%BD%B2"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">主从部署</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%9C%B0%E5%A4%87%E7%81%BE"><span class="nav-number">4.3.2.4.</span> <span class="nav-text">异地备灾</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDB%E5%92%8CAOF%E6%95%B4%E4%BD%93%E5%AF%B9%E6%AF%94"><span class="nav-number">5.</span> <span class="nav-text">RDB和AOF整体对比</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang Zihao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">147</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">289</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Zihao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
