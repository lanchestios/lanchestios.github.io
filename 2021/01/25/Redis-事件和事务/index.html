<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Redis 采用事件驱动机制来处理大量的网络 IO。它并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。Redis 基于事件驱动，来实现相应的事务机制。本文做了对应的源码解析并分析了不同场景下事务 ACID 的性质。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 事件和事务">
<meta property="og:url" content="http://example.com/2021/01/25/Redis-%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E5%8A%A1/index.html">
<meta property="og:site_name" content="Lanchester Blog">
<meta property="og:description" content="Redis 采用事件驱动机制来处理大量的网络 IO。它并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。Redis 基于事件驱动，来实现相应的事务机制。本文做了对应的源码解析并分析了不同场景下事务 ACID 的性质。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/Redis/IO底层实现和IO框架和上层应用的关系.png">
<meta property="og:image" content="http://example.com/images/Redis/文件事件处理器.png">
<meta property="og:image" content="http://example.com/images/Redis/客户端服务端通信过程.png">
<meta property="og:image" content="http://example.com/images/Redis/时间事件.png">
<meta property="og:image" content="http://example.com/images/Redis/事件管理器.png">
<meta property="og:image" content="http://example.com/images/Redis/开启事务后服务端判断命令去向.png">
<meta property="og:image" content="http://example.com/images/Redis/事务状态.png">
<meta property="og:image" content="http://example.com/images/Redis/WATCH命令数据结构.png">
<meta property="article:published_time" content="2021-01-25T08:45:00.000Z">
<meta property="article:modified_time" content="2023-01-28T07:29:15.296Z">
<meta property="article:author" content="Wang Zihao">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="Event">
<meta property="article:tag" content="Transaction">
<meta property="article:tag" content="ACID">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Redis/IO底层实现和IO框架和上层应用的关系.png">

<link rel="canonical" href="http://example.com/2021/01/25/Redis-%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E5%8A%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Redis 事件和事务 | Lanchester Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lanchester Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Leave a leaf</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/25/Redis-%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Zihao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lanchester Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis 事件和事务
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-25 16:45:00" itemprop="dateCreated datePublished" datetime="2021-01-25T16:45:00+08:00">2021-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-28 15:29:15" itemprop="dateModified" datetime="2023-01-28T15:29:15+08:00">2023-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Redis 采用事件驱动机制来处理大量的网络 IO。它并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。Redis 基于事件驱动，来实现相应的事务机制。本文做了对应的源码解析并分析了不同场景下事务 ACID 的性质。</p>
<span id="more"></span>
<h1 id="Redis事件调度"><a href="#Redis事件调度" class="headerlink" title="Redis事件调度"></a>Redis事件调度</h1><p>Redis中的事件驱动库只关注网络IO，以及定时器。该事件库处理下面两类事件：</p>
<ul>
<li>文件事件(file event)：用于处理 Redis 服务器和客户端之间的网络 IO。</li>
<li>时间事件(time eveat)：Redis 服务器中的一些操作（比如 serverCron 函数）需要在给定的时间点执行，而时间事件就是处理这类定时操作的抽象。</li>
</ul>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，也就是文件事件处理器。文件事件处理器采用了单线程方式运行，原因如下：</p>
<ol>
<li>Redis 是基于内存的，内存的读写速度非常快。因此 CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。</li>
<li>Redis 是单线程的，省去上下文切换线程的时间以及锁的性能消耗。</li>
<li>Redis 使用 IO 多路复用模型，可以处理并发的连接，提升 IO 的效率。</li>
<li>Redis 采用的单线程多进程集群的方案可以更好的利用每个核心的性能。</li>
</ol>
<p>Redis 使用的IO多路复用技术主要有：<code>select</code>、<code>epoll</code>、<code>evport</code>和<code>kqueue</code>等。每个 IO 多路复用函数库在 Redis 源码中都对应一个单独的文件，比如 ae_select.c，ae_epoll.c，ae_kqueue.c 等。Redis 会根据不同的操作系统，按照不同的优先级选择多路复用技术。事件响应框架一般都采用该架构，比如 netty 和 libevent。</p>
<p><img src="/images/Redis/IO底层实现和IO框架和上层应用的关系.png" alt=""></p>
<h3 id="IO多路复用程序的实现"><a href="#IO多路复用程序的实现" class="headerlink" title="IO多路复用程序的实现"></a>IO多路复用程序的实现</h3><p>下图是文件事件处理器，它有四个组成部分，分别是套接字、I/O多路复用程序、文件事件分派器以及事件处理器。</p>
<p><img src="/images/Redis/文件事件处理器.png" alt=""></p>
<p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行 accept、read、write 和 close 等操作时，就会产生一个文件事件。因为 Redis 通常会连接多个套接字，所以多个文件事件有可能并发的出现。IO 多路复用程序负责监听多个 Socket，并向文件事件派发器传递那些产生了事件的 Socket。</p>
<p>尽管多个文件事件可能会并发地出现，但 IO 多路复用程序会将所有待处理的事件都放到同一个队列（也就是后文中描述的<code>aeEventLoop</code>的<code>fired</code>就绪事件表）里边，然后文件事件处理器会以有序、同步、单 Socket 的方式处理该队列中的套接字，也就是处理就绪的文件事件。</p>
<h3 id="文件事件的类型"><a href="#文件事件的类型" class="headerlink" title="文件事件的类型"></a>文件事件的类型</h3><p>IO 多路复用程序可以监听多个 Socket 的<code>ae.h/AE_READABLE</code>事件和<code>ae.h/AE_WRITABLE</code>事件，这两类事件和 Socket 操作之间的对应关系如下：</p>
<ul>
<li>当 Socket 变得可读时（客户端对 Socket 执行 write 操作，或者执行 close 操作），或者有新的可应答 Socket 出现时（客户端对服务器的监听 Socket 执行 connect 操作）， Socket 产生 AE READABLE 事件。</li>
<li>当 Socket 变得可写时（客户端对 Socket 执行 read 操作）， Socket 产生 AE_WRITABLE 事件。</li>
</ul>
<p>IO 多路复用程序允许服务器同时监听套接字的 AE_READABLE 事件和 AE_WRITABLE 事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理 AE_READABLE 事件。也就是说，如果一个 Socket 又可读又可写的话，那么服务器将先读 Socket，后写 Socket。</p>
<h3 id="C-S之间事件处理过程"><a href="#C-S之间事件处理过程" class="headerlink" title="C/S之间事件处理过程"></a>C/S之间事件处理过程</h3><p><img src="/images/Redis/客户端服务端通信过程.png" style="zoom:50%;" /></p>
<ul>
<li>客户端向服务端发起建立 Socket 连接的请求，那么监听套接字将产生 AE_READABLE 事件，触发<strong>连接应答处理器</strong>执行。处理器会对客户端的连接请求进行应答，然后创建客户端 Socket，以及客户端状态，并将客户端套接字的 AE_READABLE 事件与<strong>命令请求处理器</strong>关联。</li>
<li>客户端建立连接后，向服务器发送命令，那么客户端 Socket 将产生 AE_READABLE 事件，触发<strong>命令请求处理器</strong>执行，处理器读取客户端命令，然后传递给相关程序去执行。</li>
<li>执行命令获得相应的命令回复，为了将命令回复传递给客户端，服务器将客户端 Socket 的 AE_WRITEABLE 事件与<strong>命令回复处理器</strong>关联。当客户端试图读取命令回复时，客户端 Socket 产生 AE_WRITEABLE 事件，触发<strong>命令回复处理器</strong>将命令回复全部写入到 Socket 中。</li>
</ul>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>下面为时间事件结构代码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/* 全局唯一ID */</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span> <span class="token comment">/* time event identifier. */</span>
    <span class="token comment">/* 秒精确的UNIX时间戳，记录时间事件到达的时间*/</span>
    <span class="token keyword">long</span> when_sec<span class="token punctuation">;</span> <span class="token comment">/* seconds */</span>
    <span class="token comment">/* 毫秒精确的UNIX时间戳，记录时间事件到达的时间*/</span>
    <span class="token keyword">long</span> when_ms<span class="token punctuation">;</span> <span class="token comment">/* milliseconds */</span>
    <span class="token comment">/* 时间处理器 */</span>
    aeTimeProc <span class="token operator">*</span>timeProc<span class="token punctuation">;</span>
    <span class="token comment">/* 事件结束回调函数，析构一些资源*/</span>
    aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">;</span>
    <span class="token comment">/* 私有数据 */</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span>
    <span class="token comment">/* 前驱节点 */</span>
    <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token comment">/* 后继节点 */</span>
    <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> aeTimeEvent<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="时间事件的类型"><a href="#时间事件的类型" class="headerlink" title="时间事件的类型"></a>时间事件的类型</h3><ul>
<li>定时事件：让一段程序在指定的时间之后执行一次。</li>
<li>周期性事件：让一段程序每隔指定时阃就执行一次。</li>
</ul>
<h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<p><img src="/images/Redis/时间事件.png" alt=""></p>
<p>一个时间事件是定时事件还是周期性事件取决于时间处理器的返回值：</p>
<ul>
<li>如果返回值是 AE_NOMORE，那么这个事件是一个定时事件，该事件在达到后删除，之后不会再重复</li>
<li>如果返回值是非 AE_NOMORE 的值，那么这个事件为周期性事件，当一个时间事件到达后，服务器会根据时间处理器的返回值，对时间事件的 <code>when</code> 属性进行更新，让这个事件在一段时间后再次达到。</li>
</ul>
<p>Redis 将所有时间事件都放在一个无序链表中，每次 Redis 会遍历整个链表，查找所有已经到达的时间事件，并且调用相应的事件处理器。注意，我们说保存时间事件的链表为无序链表，指的不是链表不按 ID 排序，而是说该链表不按 when 属性的大小排序。正因为链表没有按 when 属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理。</p>
<blockquote>
<p>无序链表并不影响时间事件处理器的性能</p>
<p>在目前版本中，正常模式下的 Redis 服务器只使用 serverCron 一个时间事件，而在 benchmark 模式下，服务器也只使用两个时间事件。在这种情况下，服务器几乎是将无序链表退化成一个指针来使用，所以使用无序链表来保存时间事件，并不影响事件执行的性能。</p>
</blockquote>
<h3 id="serverCron"><a href="#serverCron" class="headerlink" title="serverCron"></a>serverCron</h3><p>持续运行的 Redis 服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由<code>redis.c/serverCron</code>函数负责执行，它的主要工作包括：</p>
<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li>
<li>清理数据库中的过期键值对。</li>
<li>关闭和清理连接失效的客户端。</li>
<li>尝试进行AOF或RDB持久化操作。</li>
<li>如果服务器是主服务器，那么对从服务器进行定期同步。</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试。</li>
</ul>
<p>Redis 服务器以周期性事件的方式来运行 serverCron 函数，在服务器运行期间，每隔一段时间，serverCron 就会执行一次，直到服务器关闭为止。<br>在 Redis 2.6 版本，服务器默认规定 serverCron 每秒运行 10 次，平均每间隔 100 毫秒运行一次。<br>从 Redis 2.8 开始，用户可以通过修改hz选项来调整 serverCron 的每秒执行次数。</p>
<p>由于 serverCron 文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。因此时间事件的实际处理时间通常会比设定的到达时间晚一些。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="创建事件管理器"><a href="#创建事件管理器" class="headerlink" title="创建事件管理器"></a>创建事件管理器</h3><p>Redis 服务端在其初始化函数 <code>initServer</code>中，会创建事件管理器<code>aeEventLoop</code>对象。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 函数 aeCreateEventLoop 将创建一个事件管理器 */</span>
aeEventLoop <span class="token operator">*</span><span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span><span class="token keyword">int</span> setsize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token comment">/* 创建事件状态结构 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eventLoop <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    <span class="token comment">/* 创建未就绪事件表、就绪事件表 */</span>
    eventLoop<span class="token operator">-></span>events <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeFileEvent<span class="token punctuation">)</span><span class="token operator">*</span>setsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    eventLoop<span class="token operator">-></span>fired <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeFiredEvent<span class="token punctuation">)</span><span class="token operator">*</span>setsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-></span>events <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> eventLoop<span class="token operator">-></span>fired <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    <span class="token comment">/* 设置数组大小 */</span>
    eventLoop<span class="token operator">-></span>setsize <span class="token operator">=</span> setsize<span class="token punctuation">;</span>
    <span class="token comment">/* 初始化执行最近一次执行时间 */</span>
    eventLoop<span class="token operator">-></span>lastTime <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 初始化时间事件结构 */</span>
    eventLoop<span class="token operator">-></span>timeEventHead <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    eventLoop<span class="token operator">-></span>timeEventNextId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    eventLoop<span class="token operator">-></span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    eventLoop<span class="token operator">-></span>maxfd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    eventLoop<span class="token operator">-></span>beforesleep <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    eventLoop<span class="token operator">-></span>aftersleep <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">/* 将多路复用io与事件管理器关联起来 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeApiCreate</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    <span class="token comment">/* 初始化监听事件 */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> setsize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">=</span> AE_NONE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> eventLoop<span class="token punctuation">;</span>
err<span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiCreate</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    aeApiState <span class="token operator">*</span>state <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeApiState<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>state<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">/* 初始化epoll就绪事件表 */</span>
    state<span class="token operator">-></span>events <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span><span class="token punctuation">)</span><span class="token operator">*</span>eventLoop<span class="token operator">-></span>setsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>state<span class="token operator">-></span>events<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">zfree</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">/* 创建 epoll 实例 */</span>
    state<span class="token operator">-></span>epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 1024 is just a hint for the kernel */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token operator">-></span>epfd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">zfree</span><span class="token punctuation">(</span>state<span class="token operator">-></span>events<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">zfree</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">/* 事件管理器与epoll关联 */</span>
    eventLoop<span class="token operator">-></span>apidata <span class="token operator">=</span> state<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeApiState</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/* epoll_event 实例描述符*/</span>
    <span class="token keyword">int</span> epfd<span class="token punctuation">;</span>
    <span class="token comment">/* 存储epoll就绪事件表 */</span>
    <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> aeApiState<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>aeApiState</code>对象中<code>epfd</code>存储<code>epoll</code>的标识，<code>events</code>是一个<code>epoll</code>就绪事件数组，当有<code>epoll</code>事件发生时，所有发生的<code>epoll</code>事件和其描述符将存储在这个数组中。这个就绪事件数组由应用层开辟空间、内核负责把所有发生的事件填充到该数组。</p>
<h3 id="创建文件事件"><a href="#创建文件事件" class="headerlink" title="创建文件事件"></a>创建文件事件</h3><p><code>aeFileEvent</code>是文件事件结构，对于每一个具体的事件，都有读处理函数和写处理函数等。Redis 调用<code>aeCreateFileEvent</code>函数针对不同的套接字的读写事件注册对应的文件事件。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeFileEvent</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/* 监听事件类型掩码,值可以是 AE_READABLE 或 AE_WRITABLE */</span>
    <span class="token keyword">int</span> mask<span class="token punctuation">;</span>
    <span class="token comment">/* 读事件处理器 */</span>
    aeFileProc <span class="token operator">*</span>rfileProc<span class="token punctuation">;</span>
    <span class="token comment">/* 写事件处理器 */</span>
    aeFileProc <span class="token operator">*</span>wfileProc<span class="token punctuation">;</span>
    <span class="token comment">/* 多路复用库的私有数据 */</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> aeFileEvent<span class="token punctuation">;</span>
<span class="token comment">/* 使用typedef定义的处理器函数的函数类型 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token function">aeFileProc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> 
<span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>比如说，Redis 进行主从复制时，从服务器需要主服务器建立连接，它会发起一个 socekt连接，然后调用<code>aeCreateFileEvent</code>函数针对发起的socket的读写事件注册了对应的事件处理器，也就是<code>syncWithMaster</code>函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>AE_READABLE<span class="token operator">|</span>AE_WRITABLE<span class="token punctuation">,</span>syncWithMaster<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 符合aeFileProc的函数定义 */</span>
<span class="token keyword">void</span> <span class="token function">syncWithMaster</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>aeCreateFileEvent</code>的参数<code>fd</code>指的是具体的<code>socket</code>套接字，<code>proc</code>指<code>fd</code>产生事件时，具体的处理函数，<code>clientData</code>则是回调处理函数时需要传入的数据。<br><code>aeCreateFileEvent</code>主要做了三件事情：</p>
<ul>
<li>以<code>fd</code>为索引，在<code>events</code>未就绪事件表中找到对应事件。</li>
<li>调用<code>aeApiAddEvent</code>函数，该事件注册到具体的底层 I/O 多路复用中，本例为epoll。</li>
<li>填充事件的回调、参数、事件类型等参数。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span>
                       aeFileProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">/* 取出 fd 对应的文件事件结构, fd 代表具体的 socket 套接字 */</span>
    aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">/* 监听指定 fd 的指定事件 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span>
    <span class="token comment">/* 置文件事件类型，以及事件的处理器 */</span>
    fe<span class="token operator">-></span>mask <span class="token operator">|=</span> mask<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> fe<span class="token operator">-></span>rfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> fe<span class="token operator">-></span>wfileProc <span class="token operator">=</span> proc<span class="token punctuation">;</span>
    <span class="token comment">/* 私有数据 */</span>
    fe<span class="token operator">-></span>clientData <span class="token operator">=</span> clientData<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">></span> eventLoop<span class="token operator">-></span>maxfd<span class="token punctuation">)</span>
        eventLoop<span class="token operator">-></span>maxfd <span class="token operator">=</span> fd<span class="token punctuation">;</span>
    <span class="token keyword">return</span> AE_OK<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上文所说，Redis 基于的底层 I/O 多路复用库有多套，所以<code>aeApiAddEvent</code>也有多套实现，下面的源码是<code>epoll</code>下的实现。其核心操作就是调用<code>epoll</code>的<code>epoll_ctl</code>函数来向<code>epoll</code>注册响应事件。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    aeApiState <span class="token operator">*</span>state <span class="token operator">=</span> eventLoop<span class="token operator">-></span>apidata<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> ee <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">/* avoid valgrind warning */</span>
    <span class="token comment">/* 如果 fd 没有关联任何事件，那么这是一个 ADD 操作。如果已经关联了某个/某些事件，那么这是一个 MOD 操作。 */</span>
    <span class="token keyword">int</span> op <span class="token operator">=</span> eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">==</span> AE_NONE <span class="token operator">?</span>
            EPOLL_CTL_ADD <span class="token operator">:</span> EPOLL_CTL_MOD<span class="token punctuation">;</span>

    <span class="token comment">/* 注册事件到 epoll */</span>
    ee<span class="token punctuation">.</span>events <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    mask <span class="token operator">|=</span> eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">.</span>mask<span class="token punctuation">;</span> <span class="token comment">/* Merge old events */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> ee<span class="token punctuation">.</span>events <span class="token operator">|=</span> EPOLLIN<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> ee<span class="token punctuation">.</span>events <span class="token operator">|=</span> EPOLLOUT<span class="token punctuation">;</span>
    ee<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span>
    <span class="token comment">/* 调用epoll_ctl 系统调用，将事件加入epoll中 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">epoll_ctl</span><span class="token punctuation">(</span>state<span class="token operator">-></span>epfd<span class="token punctuation">,</span>op<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>ee<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>因为 Redis 中同时存在文件事件和时间事件两个事件类型，所以服务器必须对这两个事件进行调度，决定何时处理文件事件，何时处理时间事件，以及如何调度它们。</p>
<p>下图为事件管理器示意图，其事件驱动库的代码主要是在src/ae.c中实现的</p>
<p><img src="/images/Redis/事件管理器.png" alt=""></p>
<p><code>aeMain</code>函数以一个无限循环不断地调用<code>aeProcessEvents</code>函数来处理所有的事件。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    eventLoop<span class="token operator">-></span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventLoop<span class="token operator">-></span>stop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">/* 如果有需要在事件处理前执行的函数，那么执行它 */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-></span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            eventLoop<span class="token operator">-></span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* 开始处理事件*/</span>
        <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> AE_ALL_EVENTS<span class="token operator">|</span>AE_CALL_AFTER_SLEEP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面是<code>aeProcessEvents</code>的伪代码，它会首先计算距离当前时间最近的时间事件，以此计算一个超时时间；然后调用<code>aeApiPoll</code>函数去等待底层的I/O多路复用事件就绪；<code>aeApiPoll</code>函数返回之后，会处理所有已经产生文件事件和已经达到的时间事件。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 伪代码 */</span>
<span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/* 获取到达时间距离当前时间最接近的时间事件*/</span>
    time_event <span class="token operator">=</span> <span class="token function">aeSearchNearestTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 计算最接近的时间事件距离到达还有多少毫秒*/</span>
    remaind_ms <span class="token operator">=</span> time_event<span class="token punctuation">.</span>when <span class="token operator">-</span> <span class="token function">unix_ts_now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 如果事件已经到达，那么remaind_ms为负数，将其设置为0 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>remaind_ms <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> remaind_ms <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/* 根据 remaind_ms 的值，创建 timeval 结构*/</span>
    timeval <span class="token operator">=</span> <span class="token function">create_timeval_with_ms</span><span class="token punctuation">(</span>remaind_ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 结构决定，如果remaind_ms 的值为0，则aeApiPoll 调用后立刻返回，不阻塞*/</span>
    <span class="token comment">/* aeApiPoll调用epoll_wait函数，等待I/O事件*/</span>
    <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>timeval<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 处理所有已经产生的文件事件*/</span>
    <span class="token function">processFileEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 处理所有已经到达的时间事件*/</span>
    <span class="token function">processTimeEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与<code>aeApiAddEvent</code>类似，<code>aeApiPoll</code>也有多套实现，它其实就做了两件事情，调用<code>epoll_wait</code>阻塞等待<code>epoll</code>的事件就绪，超时时间就是之前根据最快达到时间事件计算而来的超时时间；然后将就绪的<code>epoll</code>事件转换到fired就绪事件。<code>aeApiPoll</code>就是上文所说的I/O多路复用程序。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>tvp<span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    aeApiState <span class="token operator">*</span>state <span class="token operator">=</span> eventLoop<span class="token operator">-></span>apidata<span class="token punctuation">;</span>
    <span class="token keyword">int</span> retval<span class="token punctuation">,</span> numevents <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 调用epoll_wait函数，等待时间为最近达到时间事件的时间计算而来。</span>
    retval <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>state<span class="token operator">-></span>epfd<span class="token punctuation">,</span>state<span class="token operator">-></span>events<span class="token punctuation">,</span>eventLoop<span class="token operator">-></span>setsize<span class="token punctuation">,</span>
            tvp <span class="token operator">?</span> <span class="token punctuation">(</span>tvp<span class="token operator">-></span>tv_sec<span class="token operator">*</span><span class="token number">1000</span> <span class="token operator">+</span> tvp<span class="token operator">-></span>tv_usec<span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 有至少一个事件就绪？</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> j<span class="token punctuation">;</span>
        <span class="token comment">/*为已就绪事件设置相应的模式，并加入到 eventLoop 的 fired 数组中*/</span>
        numevents <span class="token operator">=</span> retval<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numevents<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>e <span class="token operator">=</span> state<span class="token operator">-></span>events<span class="token operator">+</span>j<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>events <span class="token operator">&amp;</span> EPOLLIN<span class="token punctuation">)</span>
                mask <span class="token operator">|=</span> AE_READABLE<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>events <span class="token operator">&amp;</span> EPOLLOUT<span class="token punctuation">)</span>
                mask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>events <span class="token operator">&amp;</span> EPOLLERR<span class="token punctuation">)</span> 
                mask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>events <span class="token operator">&amp;</span> EPOLLHUP<span class="token punctuation">)</span>
                mask <span class="token operator">|=</span> AE_WRITABLE<span class="token punctuation">;</span>
            <span class="token comment">/* 设置就绪事件表元素 */</span>
            eventLoop<span class="token operator">-></span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> e<span class="token operator">-></span>data<span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
            eventLoop<span class="token operator">-></span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">=</span> mask<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token comment">// 返回已就绪事件个数</span>
    <span class="token keyword">return</span> numevents<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>processFileEvent</code>是处理就绪文件事件的伪代码，也是上文所述的文件事件分派器，它其实就是遍历<code>fired</code>就绪事件表，然后根据对应的事件类型来调用事件中注册的不同处理器，读事件调用<code>rfileProc</code>，而写事件调用<code>wfileProc</code>。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">processFileEvent</span><span class="token punctuation">(</span><span class="token keyword">int</span> numevents<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numevents<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">/* 从已就绪数组中获取事件 */</span>
        aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-></span>events<span class="token punctuation">[</span>eventLoop<span class="token operator">-></span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> mask <span class="token operator">=</span> eventLoop<span class="token operator">-></span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>mask<span class="token punctuation">;</span>
        <span class="token keyword">int</span> fd <span class="token operator">=</span> eventLoop<span class="token operator">-></span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">;</span>
        <span class="token keyword">int</span> fired <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> invert <span class="token operator">=</span> fe<span class="token operator">-></span>mask <span class="token operator">&amp;</span> AE_BARRIER<span class="token punctuation">;</span>
        <span class="token comment">/* 读事件 */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>invert <span class="token operator">&amp;&amp;</span> fe<span class="token operator">-></span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">/* 调用读处理函数 */</span>
            fe<span class="token operator">-></span><span class="token function">rfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-></span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
            fired<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">/* 写事件. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-></span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fired <span class="token operator">||</span> fe<span class="token operator">-></span>wfileProc <span class="token operator">!=</span> fe<span class="token operator">-></span>rfileProc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                fe<span class="token operator">-></span><span class="token function">wfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-></span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
                fired<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>invert <span class="token operator">&amp;&amp;</span> fe<span class="token operator">-></span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fired <span class="token operator">||</span> fe<span class="token operator">-></span>wfileProc <span class="token operator">!=</span> fe<span class="token operator">-></span>rfileProc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                fe<span class="token operator">-></span><span class="token function">rfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-></span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
                fired<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        processed<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而<code>processTimeEvents</code>是处理时间事件的函数，它会遍历<code>aeEventLoop</code>的事件事件列表，如果时间事件到达就执行其<code>timeProc</code>函数，并根据函数的返回值是否等于<code>AE_NOMORE</code>来决定该时间事件是否是周期性事件，并修改器到达时间。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    aeTimeEvent <span class="token operator">*</span>te<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> maxId<span class="token punctuation">;</span>
    <span class="token class-name">time_t</span> now <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    eventLoop<span class="token operator">-></span>lastTime <span class="token operator">=</span> now<span class="token punctuation">;</span>

    te <span class="token operator">=</span> eventLoop<span class="token operator">-></span>timeEventHead<span class="token punctuation">;</span>
    maxId <span class="token operator">=</span> eventLoop<span class="token operator">-></span>timeEventNextId<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">/* 遍历时间事件链表 */</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">long</span> now_sec<span class="token punctuation">,</span> now_ms<span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>

        <span class="token comment">/* 删除需要删除的时间事件 */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-></span>id <span class="token operator">==</span> AE_DELETED_EVENT_ID<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            aeTimeEvent <span class="token operator">*</span>next <span class="token operator">=</span> te<span class="token operator">-></span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-></span>prev<span class="token punctuation">)</span>
                te<span class="token operator">-></span>prev<span class="token operator">-></span>next <span class="token operator">=</span> te<span class="token operator">-></span>next<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                eventLoop<span class="token operator">-></span>timeEventHead <span class="token operator">=</span> te<span class="token operator">-></span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-></span>next<span class="token punctuation">)</span>
                te<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> te<span class="token operator">-></span>prev<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-></span>finalizerProc<span class="token punctuation">)</span>
                te<span class="token operator">-></span><span class="token function">finalizerProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> te<span class="token operator">-></span>clientData<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">zfree</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span><span class="token punctuation">;</span>
            te <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">/* id 大于最大maxId,是该循环周期生成的时间事件，不处理 */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>te<span class="token operator">-></span>id <span class="token operator">></span> maxId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            te <span class="token operator">=</span> te<span class="token operator">-></span>next<span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">aeGetTime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>now_sec<span class="token punctuation">,</span> <span class="token operator">&amp;</span>now_ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* 事件已经到达，调用其timeProc函数*/</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>now_sec <span class="token operator">></span> te<span class="token operator">-></span>when_sec <span class="token operator">||</span>
            <span class="token punctuation">(</span>now_sec <span class="token operator">==</span> te<span class="token operator">-></span>when_sec <span class="token operator">&amp;&amp;</span> now_ms <span class="token operator">>=</span> te<span class="token operator">-></span>when_ms<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> retval<span class="token punctuation">;</span>

            id <span class="token operator">=</span> te<span class="token operator">-></span>id<span class="token punctuation">;</span>
            retval <span class="token operator">=</span> te<span class="token operator">-></span><span class="token function">timeProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> id<span class="token punctuation">,</span> te<span class="token operator">-></span>clientData<span class="token punctuation">)</span><span class="token punctuation">;</span>
            processed<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token comment">/* 如果返回值不等于 AE_NOMORE,表示是一个周期性事件，修改其when_sec和when_ms属性*/</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">!=</span> AE_NOMORE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token function">aeAddMillisecondsToNow</span><span class="token punctuation">(</span>retval<span class="token punctuation">,</span><span class="token operator">&amp;</span>te<span class="token operator">-></span>when_sec<span class="token punctuation">,</span><span class="token operator">&amp;</span>te<span class="token operator">-></span>when_ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">/* 一次性事件，标记为需删除，下次遍历时会删除*/</span>
                te<span class="token operator">-></span>id <span class="token operator">=</span> AE_DELETED_EVENT_ID<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        te <span class="token operator">=</span> te<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> processed<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h3><p>当不在需要某个事件时，需要把事件删除掉。例如: 如果 fd 同时监听读事件、写事件。当不在需要监听写事件时，可以把该 fd 的写事件删除。</p>
<p><code>aeDeleteEventLoop</code>函数的执行过程总结为以下几个步骤<br>1、根据<code>fd</code>在未就绪表中查找到事件<br>2、取消该<code>fd</code>对应的相应事件标识符<br>3、调用<code>aeApiFree</code>函数，内核会将epoll监听红黑树上的相应事件监听取消。</p>
<h1 id="Redis事务调度"><a href="#Redis事务调度" class="headerlink" title="Redis事务调度"></a>Redis事务调度</h1><p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务（transaction）功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p>
<h2 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h2><p>一个事务从开始到结束通常会经历以下三个阶段：</p>
<ol>
<li>事务开始</li>
<li>命令入队</li>
<li>事务执行</li>
</ol>
<h3 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h3><p>MULTI 命令的执行标志着事务的开始：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">redis<span class="token operator">></span> MULTI
OK <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>MULTI 命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的 flags 属性中打开 REDIS_MULTI 标识来完成的。</p>
<h3 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h3><p><strong>入队前判断</strong></p>
<p>当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行。与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作。</p>
<p><img src="/images/Redis/开启事务后服务端判断命令去向.png" alt=""></p>
<p><strong>事务队列</strong></p>
<p>每个 Redis 客户端都有自己的事务状态，这个事务状态保存在客户端状态的 mstate 属性里面：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//...</span>
    
    <span class="token comment">//事务声明队列</span>
    multiState mstate<span class="token punctuation">;</span>
    
    <span class="token comment">//...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>事务状态包含一个事务队列，以及一个已入队命令的计数器（也可以说是事务队列的长度）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">multiState</span> <span class="token punctuation">&#123;</span>
    
    <span class="token comment">//事务队列 FIFO</span>
    multiCmd <span class="token operator">*</span>commands<span class="token punctuation">;</span>
    <span class="token comment">//已入队命令计数</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> multiState<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>事务队列是一个 multiCmd 类型的数组，数组中的每个 multiCmd 结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针、命令的参数，以及参数的数量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">multiCmd</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">//参数</span>
    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>
    
    <span class="token comment">//参数数量</span>
    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>
    
    <span class="token comment">//命令指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> multiCmd<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下图是事务状态数据结构</p>
<p><img src="/images/Redis/事务状态.png" alt=""></p>
<h3 id="事务执行"><a href="#事务执行" class="headerlink" title="事务执行"></a>事务执行</h3><p>当一个处于事务状态的客户端向服务器发送 EXEC 命令时，这个 EXEC 命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">EXEC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token comment">#创建空白的回复队列</span>
    reply_queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    
    <span class="token comment">#遍历事务队列中的每个项</span>
    <span class="token comment">#读取命令的参数，参数的个数，以及要执行的命令</span>
    <span class="token keyword">for</span> argv<span class="token punctuation">,</span> argc<span class="token punctuation">,</span> cmd <span class="token keyword">in</span> client<span class="token punctuation">.</span>mstate<span class="token punctuation">.</span>commands<span class="token punctuation">:</span>
        
        <span class="token comment">#执行命令，并取得命令的返回值</span>
        reply <span class="token operator">=</span> execute_command<span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> argc<span class="token punctuation">)</span>
        
        <span class="token comment">#将返回值追加到回复队列末尾</span>
        reply_queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>reply<span class="token punctuation">)</span>
    <span class="token comment">#移除REDTS_MULTI标识，让客户端回到非事务状态</span>
    client<span class="token punctuation">.</span>flags <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>REDIS_MULTI
    
    <span class="token comment">#清空客户端的事务状态，包括：</span>
	<span class="token comment">#1）清零入队命令计数器</span>
	<span class="token comment">#2）释放事务队列</span>
    
    client<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>
    release_transaction_queue<span class="token punctuation">(</span>client<span class="token punctuation">.</span>mstate<span class="token punctuation">.</span>commands<span class="token punctuation">)</span>
    
    <span class="token comment">#将事务的执行结果返回给客户端</span>
    send_reply_to_client<span class="token punctuation">(</span>client<span class="token punctuation">,</span> reply_queue<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="WATCH命令的实现"><a href="#WATCH命令的实现" class="headerlink" title="WATCH命令的实现"></a>WATCH命令的实现</h2><p>WATCH 命令是一个乐观锁（optimistic locking），它可以在 EXEC 命令执行之前，监视任意数量的数据库键，并在 EXEC 命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">WATCH <span class="token string">"name"</span>
MULTI
SET <span class="token string">"name"</span> <span class="token string">"peter"</span>
EXEC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在事务运行期间，监视的键被修改，服务器会拒绝执行客户端事务，并返回空回复。</p>
<h3 id="使用WATCH命令监视数据库键"><a href="#使用WATCH命令监视数据库键" class="headerlink" title="使用WATCH命令监视数据库键"></a>使用WATCH命令监视数据库键</h3><p>每个 Redis 数据库都保存着一个 watched_keys 字典，这个字典的键是某个被 WATCH 命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//...</span>
    
	<span class="token comment">//正在被WATCH命令监视的键</span>
    dict <span class="token operator">*</span>watched_keys<span class="token punctuation">;</span>
    
    <span class="token comment">//...</span>
<span class="token punctuation">&#125;</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过 watched_keys 字典，服务器可以清楚地知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。</p>
<p>下图是客户端 c1、c2、c10086 在监视 “name” 键，c3、c10086 在监视 “age” 键，c2、c4 在监视 “address” 键。其中 c10086 是运行 WATCH 命令后新增的。</p>
<p><img src="/images/Redis/WATCH命令数据结构.png" style="zoom:67%;" /></p>
<h3 id="监视机制的触发"><a href="#监视机制的触发" class="headerlink" title="监视机制的触发"></a>监视机制的触发</h3><p>所有对数据库进行修改的命令，比如 SET、PUSH、SADD、ZREM、DEL、FLUSHDB 等等，在执行之后都会调用 multi.c/touchWatchKey 函数对 watched_keys 字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么 touchWatchKey 函数会将监视被修改键的客户端的 REDIS_DIRTY_CAS 标识打开，表示该客户端的事务安全性已经被破坏。</p>
<p>客户端向服务器发送 EXEC 命令，如果客户端的 REDIS_DIRTY_CAS 标识已经打开，则表明客户端提交事务不再安全，因此服务端会拒绝执行客户端提交的事务。</p>
<h2 id="事务的ACID性质"><a href="#事务的ACID性质" class="headerlink" title="事务的ACID性质"></a>事务的ACID性质</h2><p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有耐久性（Durability）。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>事务具有原子性指的是，数据库将事务中的多个操作当作一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。</p>
<p>Redis 的事务和传统的关系型数据库事务的最大区别在于，Redis 不支持事务回滚机制（rollback），即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。</p>
<blockquote>
<p>Redis 的作者在事务功能的文档中解释说，不支持事务回滚是因为这种复杂的功能和 Redis 追求简单高效的设计主旨不相符，并且他认为，Redis 事务的执行时错误通常都是编程错误产生的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能。</p>
</blockquote>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。”一致”指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。Redis 通过谨慎的错误检测和简单的设计来保证事务的一致性。</p>
<p><strong>1. 入队错误</strong></p>
<p>如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么该事务在执行时，Redis 将拒绝执行这个事务。</p>
<blockquote>
<p>2.6.5 版本以前入队错误 Redis 会直接忽略并继续向下执行</p>
</blockquote>
<p><strong>2. 执行错误</strong></p>
<p>关于执行错误有两个需要说明的地方：</p>
<ul>
<li>执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时被触发。</li>
<li>即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令（包括执行命令所产生的结果）不会被出错的命令影响。</li>
</ul>
<p>对数据库键执行了错误类型的操作是事务执行期间最常见的错误之一</p>
<p><strong>3. 服务器停机</strong></p>
<p>如果 Redis 服务器在执行事务的过程中停机，那么根据服务器所使用的持久化模式，可能有以下情况出现</p>
<ul>
<li>如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。</li>
<li>如果服务器运行在 RDB 模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的 RDB 文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的 RDB 文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li>
<li>如果服务器运行在 AOF 模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的 AOF 文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的 AOF 文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。</li>
</ul>
<p>综上所述，无论 Redis 服务器运行在哪种持久化模式下，事务执行中途发生的停机都不会影响数据库的一致性。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。</p>
<p>因为 Redis 使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis 的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。</p>
<h3 id="耐久性"><a href="#耐久性" class="headerlink" title="耐久性"></a>耐久性</h3><p>事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。</p>
<p>因为Reds的事务不过是简单地用队列包裹起了一组 Redis 命令，Redis 并没有为事务提供任何额外的持久化功能，所以 Redis 事务的耐久性由 Redis 所使用的持久化模式决定：</p>
<ul>
<li>当服务器在无持久化的内存模式下运作时，事务不具有耐久性：一旦服务器停机包括事务数据在内的所有服务器数据都将丢失。</li>
<li>当服务器在 RDB 持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行 BGSAVE 命令，对数据库进行保存操作，并且异步执行的 BGSAVE 不能保证事务数据被第一时间保存到硬盘里面，因此 RDB 持久化模式下的事务也不具有耐久性。</li>
<li>当服务器运行在 AOF 持久化模式下，并且 appendfsync 选项的值为 always 时程序总会在执行命令之后调用同步（sync）函数，将命令数据真正地保存到硬盘里面，因此这种配置下的事务是具有耐久性的。</li>
<li>当服务器运行在 AOF 持久化模式下，并且 appendfsync 选项的值为 everysec 时，程序会每秒同步一次命令数据到硬盘。因为停机可能会恰好发生在等待同步的那一秒钟之内，这可能会造成事务数据丢失，所以这种配置下的事务不具有耐久性。</li>
<li>当服务器运行在 AOF 持久化模式下，并且 appendfsync 选项的值为 no 时，程序会交由操作系统来决定何时将命令数据同步到硬盘。因为事务数据可能在等待同步的过程中丢失，所以这种配置下的事务不具有耐久性。</li>
</ul>
<blockquote>
<p>no-appendfsync-on-rewrite 配置选项对耐久性的影响</p>
<p>配置选项 no-appendfsync-on-rewrite 可以配合 appendfsync 选项为 always 或者 everysec 的 AOF 持久化模式使用。当 no-appendfsync-on-rewrite 选项处于打开状态时，在执行 BGSAVE 命令或者 BGREWRITEAOF 命令期间，服务器会暂时停止对 AOF 文件进行同步，从而尽可能地减少 IO 阻塞。但是这样来，关于 “always模式的AOF持久化可以保证事务的耐久性” 这一结论将不再成立，因为在服务器停止对 AOF 文件进行同步期间，事务结果可能会因为停机而丢失。</p>
<p>因此，如果服务器打开了 no-appendfsync-on-rewrite 选项，那么即使服务器运行在 always 模式的 AOF 持久化之下，事务也不具有耐久性。在默认配置下，no-appendfsync-on-rewrite 处于关闭状态。</p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
              <a href="/tags/Event/" rel="tag"># Event</a>
              <a href="/tags/Transaction/" rel="tag"># Transaction</a>
              <a href="/tags/ACID/" rel="tag"># ACID</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/23/Tomcat-1-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" rel="prev" title="Tomcat 架构设计">
      <i class="fa fa-chevron-left"></i> Tomcat 架构设计
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/27/Redis-%E7%9B%B8%E5%85%B3%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/" rel="next" title="Redis 相关功能实现">
      Redis 相关功能实现 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E4%BA%8B%E4%BB%B6%E8%B0%83%E5%BA%A6"><span class="nav-number">1.</span> <span class="nav-text">Redis事件调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.1.</span> <span class="nav-text">文件事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">IO多路复用程序的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">文件事件的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-S%E4%B9%8B%E9%97%B4%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">C&#x2F;S之间事件处理过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.2.</span> <span class="nav-text">时间事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">时间事件的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91"><span class="nav-number">1.2.2.</span> <span class="nav-text">实现逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#serverCron"><span class="nav-number">1.2.3.</span> <span class="nav-text">serverCron</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">创建事件管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.3.2.</span> <span class="nav-text">创建文件事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">1.3.3.</span> <span class="nav-text">事件处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.3.4.</span> <span class="nav-text">删除事件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E4%BA%8B%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="nav-number">2.</span> <span class="nav-text">Redis事务调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.</span> <span class="nav-text">事务的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%BC%80%E5%A7%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">事务开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E5%85%A5%E9%98%9F"><span class="nav-number">2.1.2.</span> <span class="nav-text">命令入队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="nav-number">2.1.3.</span> <span class="nav-text">事务执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WATCH%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">WATCH命令的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8WATCH%E5%91%BD%E4%BB%A4%E7%9B%91%E8%A7%86%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE"><span class="nav-number">2.2.1.</span> <span class="nav-text">使用WATCH命令监视数据库键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E8%A7%86%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A7%A6%E5%8F%91"><span class="nav-number">2.2.2.</span> <span class="nav-text">监视机制的触发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E6%80%A7%E8%B4%A8"><span class="nav-number">2.3.</span> <span class="nav-text">事务的ACID性质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">2.3.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">2.3.2.</span> <span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="nav-number">2.3.3.</span> <span class="nav-text">隔离性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%90%E4%B9%85%E6%80%A7"><span class="nav-number">2.3.4.</span> <span class="nav-text">耐久性</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang Zihao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">142</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">284</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Zihao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
