<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="当内存分配的时候，剩余的空间不能满足要分配的对象时就会优先触发新生代回收（Young GC，YGC）。G1的 YGC 收集的内存是不固定的，每次回收的内存可能并不相同，即每次回收的分区数目是不固定的，但是每一次 YGC 都是收集所有的新生代分区，所以每一次 GC 之后都会调整新生代分区的数目。">
<meta property="og:type" content="article">
<meta property="og:title" content="G1 YoungGC过程">
<meta property="og:url" content="http://example.com/2022/07/22/G1-2-YoungGC%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="Lanchester Blog">
<meta property="og:description" content="当内存分配的时候，剩余的空间不能满足要分配的对象时就会优先触发新生代回收（Young GC，YGC）。G1的 YGC 收集的内存是不固定的，每次回收的内存可能并不相同，即每次回收的分区数目是不固定的，但是每一次 YGC 都是收集所有的新生代分区，所以每一次 GC 之后都会调整新生代分区的数目。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/JDK/%E5%B9%B4%E8%BD%BB%E4%BB%A3GC%E8%BF%87%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="http://example.com/images/JDK/YGC1.png">
<meta property="og:image" content="http://example.com/images/JDK/YGC2.png">
<meta property="og:image" content="http://example.com/images/JDK/YGC3.png">
<meta property="og:image" content="http://example.com/images/JDK/YGC4.png">
<meta property="og:image" content="http://example.com/images/JDK/YGC5.png">
<meta property="article:published_time" content="2022-07-22T02:21:40.000Z">
<meta property="article:modified_time" content="2022-08-11T04:26:04.396Z">
<meta property="article:author" content="Wang Zihao">
<meta property="article:tag" content="JDK">
<meta property="article:tag" content="GC">
<meta property="article:tag" content="G1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/JDK/%E5%B9%B4%E8%BD%BB%E4%BB%A3GC%E8%BF%87%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png">

<link rel="canonical" href="http://example.com/2022/07/22/G1-2-YoungGC%E8%BF%87%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>G1 YoungGC过程 | Lanchester Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lanchester Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Leave a leaf</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/22/G1-2-YoungGC%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang Zihao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lanchester Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          G1 YoungGC过程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-22 10:21:40" itemprop="dateCreated datePublished" datetime="2022-07-22T10:21:40+08:00">2022-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-11 12:26:04" itemprop="dateModified" datetime="2022-08-11T12:26:04+08:00">2022-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>当内存分配的时候，剩余的空间不能满足要分配的对象时就会优先触发新生代回收（Young GC，YGC）。G1的 YGC 收集的内存是不固定的，每次回收的内存可能并不相同，即每次回收的分区数目是不固定的，但是每一次 YGC 都是收集所有的新生代分区，所以每一次 GC 之后都会调整新生代分区的数目。</p>
<span id="more"></span>

<h1 id="YGC-简述"><a href="#YGC-简述" class="headerlink" title="YGC 简述"></a>YGC 简述</h1><p>完全年轻代 GC 是只选择年轻代区域（Eden&#x2F;Survivor）进入回收集合（Collection Set，简称CSet）进行回收的模式。新创建的对象分配至 Eden 区域，当 Eden 区域内存耗尽时触发 YGC，将选择的年轻代区域内标记存活的对象移动至 Survivor 区，达到晋升年龄的就晋升到老年代区域，然后清空原区域。</p>
<p>下面是一个完全年轻代GC过程的简单示意图：</p>
<p><img src="/images/JDK/%E5%B9%B4%E8%BD%BB%E4%BB%A3GC%E8%BF%87%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<h1 id="YGC-算法过程"><a href="#YGC-算法过程" class="headerlink" title="YGC 算法过程"></a>YGC 算法过程</h1><p>当 JVM 无法将新对象分配到 Eden 区域时，会触发年轻代的垃圾回收（年轻代垃圾回收是完全暂停的，虽然部分过程是并行，但暂停和并行并不冲突）。也会称为“evacuation pause”。</p>
<h2 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h2><blockquote>
<p>STW: Stop The World</p>
</blockquote>
<p>进行收集之前需要 STW。</p>
<h2 id="选择收集集合"><a href="#选择收集集合" class="headerlink" title="选择收集集合"></a>选择收集集合</h2><blockquote>
<p>选择收集集合: Choose CSet</p>
</blockquote>
<p>G1会在遵循用户设置的 GC 暂停时间上限的基础上，选择一个最大年轻带区域数，将这个数量的所有年轻代区域作为收集集合。</p>
<p>如下图所示，此时 A&#x2F;B&#x2F;C 三个年轻代区域都已经作为收集集合，区域A中的 A 对象和区域 B 中的 E 对象，被 ROOTS 直接引用。</p>
<blockquote>
<p>图上为了简单，将RS直接引用到对象，实际上 RS 引用的是对象所在的 CardPage</p>
</blockquote>
<p><img src="/images/JDK/YGC1.png"></p>
<h2 id="（并行）根处理"><a href="#（并行）根处理" class="headerlink" title="（并行）根处理"></a>（并行）根处理</h2><blockquote>
<p>（并行）根处理: Root Scanning</p>
</blockquote>
<p>接下来，需要从 GC ROOTS 遍历，查找从 ROOTS 直达到收集集合的对象，移动他们到 Survivor 区域的同时将他们的引用对象加入标记栈。</p>
<p>如下图所示，在根处理阶段，被 GC ROOTS 直接引用的 A&#x2F;E 两个对象直接被复制到了 Survivor 区域 M，同时 A&#x2F;E 两个对象所引用路线上的所有对象，都被加入了标记栈（Mark Stack），这里包括 <code>E-&gt;C-&gt;F</code>，这个 F 对象也会被加入标记栈中。</p>
<p><img src="/images/JDK/YGC2.png"></p>
<h2 id="（并行）RSet扫描"><a href="#（并行）RSet扫描" class="headerlink" title="（并行）RSet扫描"></a>（并行）RSet扫描</h2><blockquote>
<p>（并行）RSet扫描: Scan RS</p>
</blockquote>
<p>将 RSet 作为 ROOTS 遍历，查找可直达到收集集合的对象，移动他们到 Survivor 区域的同时将他们的引用对象加入标记栈。</p>
<p>在 RSet 扫描之前，还有一步更新 RSet（Update RS）的步骤，因为 RSet 是先写日志，再通过一个 Refine 线程进行处理日志来维护 RSet 数据的，这里的更新 RSet 就是为了保证 RSet 日志被处理完成，RSet 数据完整才可以进行扫描</p>
<p>如下图所示，老年代区域 C 中引用年轻代 A 的这个引用关系，被记录在年轻代的 RSet 中，此时遍历这个 RS。由于老年代 C 区域中 D 对象在 OHR 并不包含在 CSet 中，因此不处理，将其引用的年轻代 A 中的 B 对象移动到 Survivor 区域，并将年轻代 A 中的 B 对象的引用对象添加到标记栈中。</p>
<blockquote>
<p>当 D 对象不处理，将 B 对象添加到标记栈？还是将 D 对象移动到 Survivor 后续引用添加到标记栈？需要追源码确认。</p>
</blockquote>
<p><img src="/images/JDK/YGC3.png"></p>
<h2 id="（并行）复制"><a href="#（并行）复制" class="headerlink" title="（并行）复制"></a>（并行）复制</h2><blockquote>
<p>（并行）复制: Evacuation &#x2F; Object Copy</p>
</blockquote>
<p>遍历上面的标记栈，将栈内的所有所有的对象移动至 Survivor 区域（其实说是移动，本质上还是复制）。</p>
<p>如下图所示，标记栈中记录的 C&#x2F;F&#x2F;B 对象被移动到 Survivor 区域中</p>
<p><img src="/images/JDK/YGC4.png"></p>
<p>当对象年龄超过晋升的阈值时，对象会直接移动到老年代区域，而不是 Survivor 区域。</p>
<h2 id="Redirty"><a href="#Redirty" class="headerlink" title="Redirty"></a>Redirty</h2><p>Redirty 的目的就是为了重构 RSet，保证引用关系的正确性。我们发现因为对象发生了复制，此时 老年代 C 区域中 D 对象指向年轻代 M 区域的 B 对象，但 RSet 的引用还没有变化，所以需要重构 RSet。</p>
<blockquote>
<p>RSet 引用没有变化，此时 Region A 的 RSet 的存储状态是啥？RSet 的结构是什么？我并不清楚。</p>
</blockquote>
<p><img src="/images/JDK/YGC5.png"></p>
<h2 id="释放空间"><a href="#释放空间" class="headerlink" title="释放空间"></a>释放空间</h2><p>Clear CT（清理Card Table），Free CSet（清理回收集合），清空移动前的区域添加到空闲区等等，这些操作一般耗时都很短。</p>
<h1 id="YGC-过程日志"><a href="#YGC-过程日志" class="headerlink" title="YGC 过程日志"></a>YGC 过程日志</h1><pre class="line-numbers language-none"><code class="language-none">3.378: [GC pause (G1 Evacuation Pause) (young), 0.0015185 secs]
   [Parallel Time: 0.7 ms, GC Workers: 4] # 并行GC线程
      [GC Worker Start (ms): Min: 3378.1, Avg: 3378.3, Max: 3378.6, Diff: 0.5]
      # Min 最早开始的线程时间 Max 最晚开始时间 Avg 平均开始时间 Diff 最早最晚时间差
      [Ext Root Scanning (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 0.6]
      # 根扫描，包含所有强引用根，类型如下：
      # 1. Java根：Thread、JNI、CLDG
      # 2. JVM根： StringTable、Universe、JNI Handles、ObjectSynchronizer、
      #           FlatProfiler、Management、SystemDictionary、JVMTI
      # 还会扫描CodeCache Roots处理RSet时的统计值，包含下面的：
      # UpdateRS、ScanRS 和 Code Root Scan
      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      # 这个是GC线程更新RSet的时间花费，注意这里的时间和我们在Refine里面处理RSet的时间没关系
      # 它们是不同线程处理
         [Processed Buffers: Min: 0, Avg: 0.2, Max: 1, Diff: 1, Sum: 1]
      [Scan RS (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.3]
      # 扫描RSet找到被引用的对象
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Object Copy (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]
      # 活着的对象复制到新分区花费的时间
      [Termination (ms): Min: 0.0, Avg: 0.2, Max: 0.3, Diff: 0.3, Sum: 0.7]
      # GC线程结束的时间
         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]
      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]
      # 并行处理时其他处理花费的时间，基本都是释放资源
      [GC Worker Total (ms): Min: 0.1, Avg: 0.4, Max: 0.6, Diff: 0.6, Sum: 1.8]
      # 并行GC花费的时间
      [GC Worker End (ms): Min: 3378.7, Avg: 3378.7, Max: 3378.8, Diff: 0.1]
      # GC线程结束的时间信息
   
   # 下面是其他任务部分
   [Code Root Fixup: 0.0 ms]
   [Code Root Purge: 0.0 ms]
   # 代码扫描属于并行部分，包含了代码的调整和回收
   [Clear CT: 0.1 ms]
   # 清除卡表的时间
   [Other: 0.7 ms]
      [Choose CSet: 0.0 ms]
      [Ref Proc: 0.5 ms]
      # 引用处理，发现哪些引用可以被清除
      [Ref Enq: 0.0 ms]
      # 引用重新激活
      [Redirty Cards: 0.1 ms]
      # 重构RSet的花费时间
      [Humongous Register: 0.0 ms]
      # 大对象处理时间
      	[Humongous Total: 2]
      	# 有两个大对象
      	[Humongous Candidate: 0]
      	# 可回收大对象0个
      [Humongous Reclaim: 0.1 ms]
      [Free CSet: 0.1 ms]
   [Eden: 304.0M(304.0M)-&gt;0.0B(304.0M) Survivors: 2048.0K-&gt;2048.0K Heap: 304.5M(512.0M)-&gt;529.0K(512.0M)]
 [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.00 secs] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><strong>在GC日志的最后稍微提一下日志为什么需要对Code Root扫描和调整？</strong></p>
<p>Java 代码在满足一定条件之后（比如执行多次），JIT 编译器会把这样的代码进行编译，这样的代码中有直接访问 OOP 对象的语句，因此当对象发生移动之后，必须重新调整代码中对象的引用位置，所以需要对Code Root进行扫描、调整，如果能释放的话还会进行释放。</p>
</blockquote>
<p>需要注意的是，如果 GC 日志开头有 <code>[GC pause (G1 Humongous Allocation) (young) (initial-mark)</code> 表示这次的 YGC 发生后，就会开始并发标记。</p>
<pre class="line-numbers language-none"><code class="language-none">0.140: [GC concurrent-root-region-scan-start]
# 把YHR中Survivor分区作为根，开始并发标记根扫描
0.140: [GC concurrent-root-region-scan-end, 0.0003290 secs]
# 并发标记根扫描结束
0.140: [GC concurrent-mark-start]
# 开始并发标记子阶段，从所有根引用（包括Survivor和强根入栈等出发，对整个堆进行标记）
0.140: [GC concurrent-mark-end, 0.0002506 secs]
# 标记结束
0.144: [GC remark, 0.0014324 secs]
# 开始再标记子阶段，包括再标记、引用处理、类卸载处理信息
0.145: [GC cleanup 111M-&gt;111M(256M), 0.0005997 secs]
# 清除处理，回收整个分区垃圾、调整 RSet 以减轻后续GC中RSet根的处理时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="YGC-参数"><a href="#YGC-参数" class="headerlink" title="YGC 参数"></a>YGC 参数</h1><p><strong>ParallelGCThreads</strong></p>
<p>ParallelGCThreads，默认值为0，表示的是并行执行 GC 的线程个数。G1 可以根据 CPU 的个数自行推断线程数；GC 是 CPU 密集型的任务，通常来说线程个数不应该超过 CPU 核数，一般不用设置该值。</p>
<p><strong>MaxTenuringThreshold</strong></p>
<p>在对新生代收集的过程中，如果对象在 YGC 发生了一定次数之后还存活，这意味着对象有很大的概率存活更长的时间，所以通常会把它晋升到老生代。而这个次数可以通过参数 MaxTenuringThreshold 控制，默认值是 15，即发生 15 次 YGC 后，对象仍然存活，存活的对象会晋升到老生代。这个值最大只能是 15。减小该值可以会把对象更早地提升到老生代。这个参数并非能达到绝对控制，比如晋升失败会导致对象原地不动，如果 survival 区不够大，可能直接放到老年代。</p>
<p><strong>G1RsetScanBlockSize</strong></p>
<p>参数 G1RsetScanBlockSize，默认值为 64，指扫描 Rset 时一次处理的量，其目的是为了加速处理速度；如果计算能力较强，可以增大该值。</p>
<p><strong>SurvivorRatio</strong></p>
<p>参数 SurvivorRatio，默认值为 8，指 Eden 和 Survivor 分区之间的比例；减小该值，将导致 Survivor 分区大小变大，G1 中并不会因为增大该值直接导致 Eden 变小，Eden 是根据 GC 的时间来预测的。</p>
<p><strong>TargetSurvivorRatio</strong></p>
<p>参数 TargetSurvivorRatio，默认值为 50，表示期望 Survivor 的大小。增大该值，则用于下一次 Survivor 的空间变大，晋升到 Old 分区的概率会减少。</p>
<p><strong>ParGCArrayScanChunk</strong></p>
<p>参数 ParGCArrayScanChunk，默认值为 50，表示当一个对象数组的长度超过这个阈值之后，不会一次性遍历它，而是分多次处理，每次的长度都是这个阈值，只有最后一次处理的长度在 ParGCArrayScanChunk 和 2×ParGCArrayScanChunk 之间。减小该值会减少栈溢出的情况，增大该值效率会略有提升。</p>
<p><strong>ResizePLAB</strong></p>
<p>参数 ResizePLAB，默认值为 true，表示在垃圾回收结束后会根据内存的使用情况来调整 PLAB 的大小，但是目前 G1 中的 GC 线程在不同的阶段如 Evac，引用处理等都会涉及内存分配，所以在 PLAB 的调整上是根据整体内存的使用情况进行的，这个成本比较高。因此在一些基准测试中发现禁止该选项可能有更好的效果，但这并不一定也适用于你的应用，关于 PLAB 效率和性能有一个 bug，如果使用该选项也可以进行调整并测试。关于 PLAB 在 JDK9 等后面的版本中会引入相关参数。</p>
<p><strong>YoungPLABSize</strong></p>
<p>参数 YoungPLABSize，默认值为 4096，是新生代 PLAB 缓存大小。在 32 位 JVM 中 PLAB 为 16KB，在 64 位 JVM 中为 32KB，表示对象从 Eden 复制到 Survivor 时，每次请求 16KB 作为分配缓存，提高分配效率。增大该值可以提高分配的效率，但是可能增加内存碎片，同时可能使得S分区很快耗尽；实际调优中可以尝试先减小该值。</p>
<p><strong>OldPLABSize</strong></p>
<p>参数 OldPLABSize，默认值为 1024，指老生代 PLAB 缓存大小。在 32 位JVM中 PLAB 为 4KB，64 位 JVM 中为 8KB，表示对象从 Eden 复制到 Old 时，每次请求 4KB 作为分配缓存，提高分配效率。增大该值可以提高分配的效率，但是可能增加内存碎片；通常来说 Old 分区空间更大，实际调优中可以尝试先增大该值。</p>
<p><strong>ParallelGCBufferWastePct</strong></p>
<p>参数 ParallelGCBufferWastePct，默认值为10，表示对象从 Eden 到 Survivor 或者 Old 区的时候，如果剩余空间小于这个比例，且不能分配新对象时可以丢弃这个 PLAB 块，申请一个新的 PLAB，所以这个值越大分配的效率越高，内存浪费也越严重；这个参数和 TLABRefillWasteFraction 类似。</p>
<p><strong>G1EagerReclaimHumongousObjects</strong></p>
<p>参数 G1EagerReclaimHumongousObjects，默认值为true，表示在 YGC 时收集大对象；有应用测试发现 YGC 时回收大对象会引起性能问题，如果遇到可以关闭选项。</p>
<p><strong>G1EagerReclaimHumongousObjectsWithStaleRefs</strong></p>
<p>参数 G1EagerReclaimHumongousObjectsWithStaleRefs，默认值为 true，表示在 YGC 时判定哪些大对象分区可以收集，如果为 true 表示当时大对象分区 RSet 的引用关系数小于 G1RSetSparseRegionEntries（默认值为0）可以尝试收集，如果为 false 则只有 RSet 中的引用数为 0 才会收集。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JDK/" rel="tag"># JDK</a>
              <a href="/tags/GC/" rel="tag"># GC</a>
              <a href="/tags/G1/" rel="tag"># G1</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/22/G1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" rel="prev" title="G1 基本概念">
      <i class="fa fa-chevron-left"></i> G1 基本概念
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/22/G1-3-MixedGC%E8%BF%87%E7%A8%8B/" rel="next" title="G1 MixedGC过程">
      G1 MixedGC过程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#YGC-%E7%AE%80%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">YGC 简述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#YGC-%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">YGC 算法过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STW"><span class="nav-number">2.1.</span> <span class="nav-text">STW</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%94%B6%E9%9B%86%E9%9B%86%E5%90%88"><span class="nav-number">2.2.</span> <span class="nav-text">选择收集集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E5%B9%B6%E8%A1%8C%EF%BC%89%E6%A0%B9%E5%A4%84%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">（并行）根处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E5%B9%B6%E8%A1%8C%EF%BC%89RSet%E6%89%AB%E6%8F%8F"><span class="nav-number">2.4.</span> <span class="nav-text">（并行）RSet扫描</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%EF%BC%88%E5%B9%B6%E8%A1%8C%EF%BC%89%E5%A4%8D%E5%88%B6"><span class="nav-number">2.5.</span> <span class="nav-text">（并行）复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redirty"><span class="nav-number">2.6.</span> <span class="nav-text">Redirty</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4"><span class="nav-number">2.7.</span> <span class="nav-text">释放空间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#YGC-%E8%BF%87%E7%A8%8B%E6%97%A5%E5%BF%97"><span class="nav-number">3.</span> <span class="nav-text">YGC 过程日志</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#YGC-%E5%8F%82%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">YGC 参数</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang Zihao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">266</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Zihao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
